[
    {
        "problemId": 1,
        "courseId": "ibm",
        "title": "HCF Without Recursion",
        "difficulty": "Easy",
        "description": "Write a program to find the Highest Common Factor (HCF) of two numbers without using recursion.",
        "examples": [
          {
            "input": "70 15\n",
            "output": "5\n"
          }
        ],
        "constraints": [
          "1 <= numbers <= 10^9"
        ],
        "testCases": [
          {
            "input": "70 15\n",
            "expectedOutput": "5\n"
          },
          {
            "input": "12 18\n",
            "expectedOutput": "6\n"
          },
          {
            "input": "25 10\n",
            "expectedOutput": "5\n"
          },
          {
            "input": "17 23\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "48 16\n",
            "expectedOutput": "16\n"
          },
          {
            "input": "100 50\n",
            "expectedOutput": "50\n"
          },
          {
            "input": "1 100\n",
            "expectedOutput": "1\n"
          }
        ],
        "hints": [
          "Use the Euclidean algorithm to find the HCF.",
          "The Euclidean algorithm involves repeatedly applying the division operation until the remainder is 0.",
          "The last non-zero remainder is the HCF.",
          "Iteratively calculate the remainder using the modulo operator.",
          "Handle edge cases like when one of the numbers is 0 or 1."
        ],
        "tags": ["HCF", "Euclidean Algorithm", "Mathematics", "Iteration"]
      },
       {
        "problemId": 2,
        "courseId": "ibm",
        "title": "String Compression Correction",
        "difficulty": "Medium",
        "description": "Consider a string, S, that is a series of characters, each followed by its frequency as an integer. The string is not compressed correctly, so there may be multiple occurrences of the same character. A properly compressed string will consist of one instance of each character in alphabetical order followed by the total count of that character within the string.",
        "examples": [
          {
            "input": "a2b1c3a1\n",
            "output": "a3b1c3\n"
          },
          {
            "input": "z1y2x3z2\n",
            "output": "x3y2z3\n"
          }
        ],
        "constraints": [
          "1 <= length of string <= 1000",
          "The string will contain only lowercase English letters and positive integers.",
          "The integers will represent the frequency of the preceding character."
        ],
        "testCases": [
          {
            "input": "a2b1c3a1\n",
            "expectedOutput": "a3b1c3\n"
          },
          {
            "input": "z1y2x3z2\n",
            "expectedOutput": "x3y2z3\n"
          },
          {
            "input": "a1b1c1d1e1\n",
            "expectedOutput": "a1b1c1d1e1\n"
          },
          {
            "input": "a10b20c30\n",
            "expectedOutput": "a10b20c30\n"
          },
          {
            "input": "a1a1a1a1a1\n",
            "expectedOutput": "a5\n"
          },
          {
            "input": "z1a1b1c1y1\n",
            "expectedOutput": "a1b1c1y1z1\n"
          },
          {
            "input": "a1b1c1a1b1c1\n",
            "expectedOutput": "a2b2c2\n"
          }
        ],
        "hints": [
          "Parse the input string to extract characters and their frequencies.",
          "Use a hash map or dictionary to store the total frequency of each character.",
          "Sort the characters in alphabetical order.",
          "Construct the output string by appending each character followed by its total frequency.",
          "Handle the edge case where the input string is empty."
        ],
        "tags": ["String Compression", "String Manipulation", "Hash Map", "Sorting"]
      },
       {
        "problemId": 3,
        "courseId": "ibm",
        "title": "Decimal to Binary",
        "difficulty": "Easy",
        "description": "Write a program to convert a decimal number to its binary representation.",
        "examples": [
          {
            "input": "10\n",
            "output": "1010\n"
          },
          {
            "input": "7\n",
            "output": "111\n"
          }
        ],
        "constraints": [
          "0 <= decimal number <= 10^9"
        ],
        "testCases": [
          {
            "input": "10\n",
            "expectedOutput": "1010\n"
          },
          {
            "input": "7\n",
            "expectedOutput": "111\n"
          },
          {
            "input": "0\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "1\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "15\n",
            "expectedOutput": "1111\n"
          },
          {
            "input": "16\n",
            "expectedOutput": "10000\n"
          },
          {
            "input": "100\n",
            "expectedOutput": "1100100\n"
          }
        ],
        "hints": [
          "Repeatedly divide the decimal number by 2 and store the remainders.",
          "The remainders, when read in reverse order, form the binary representation.",
          "Use a loop to perform the division and store the remainders.",
          "Handle the edge case where the decimal number is 0.",
          "Construct the binary string by concatenating the remainders in reverse order."
        ],
        "tags": ["Decimal to Binary", "Number Conversion", "Bit Manipulation"]
      },
      {
        "problemId": 4,
        "courseId": "ibm",
        "title": "Fibonacci Triangle",
        "difficulty": "Medium",
        "description": "Generate a Fibonacci triangle up to a given number of rows. The Fibonacci triangle is a triangular array where each row contains Fibonacci numbers.",
        "examples": [
          {
            "input": "5\n",
            "output": "1\n1 1\n2 3 5\n8 13 21 34\n55 89 144 233 377\n"
          },
          {
            "input": "3\n",
            "output": "1\n1 1\n2 3 5\n"
          }
        ],
        "constraints": [
          "1 <= number of rows <= 20"
        ],
        "testCases": [
          {
            "input": "5\n",
            "expectedOutput": "1\n1 1\n2 3 5\n8 13 21 34\n55 89 144 233 377\n"
          },
          {
            "input": "3\n",
            "expectedOutput": "1\n1 1\n2 3 5\n"
          },
          {
            "input": "1\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "2\n",
            "expectedOutput": "1\n1 1\n"
          },
          {
            "input": "4\n",
            "expectedOutput": "1\n1 1\n2 3 5\n8 13 21 34\n"
          },
          {
            "input": "6\n",
            "expectedOutput": "1\n1 1\n2 3 5\n8 13 21 34\n55 89 144 233 377\n610 987 1597 2584 4181 6765\n"
          },
          {
            "input": "7\n",
            "expectedOutput": "1\n1 1\n2 3 5\n8 13 21 34\n55 89 144 233 377\n610 987 1597 2584 4181 6765\n10946 17711 28657 46368 75025 121393 196418\n"
          }
        ],
        "hints": [
          "Generate Fibonacci numbers iteratively and store them in a list.",
          "Print the Fibonacci numbers in a triangular pattern.",
          "The first row contains the first Fibonacci number.",
          "The second row contains the next two Fibonacci numbers.",
          "The third row contains the next three Fibonacci numbers, and so on.",
          "Use nested loops to control the rows and columns of the triangle.",
          "Format the output to align the numbers in the triangle."
        ],
        "tags": ["Fibonacci Triangle", "Fibonacci Numbers", "Pattern Printing", "Iteration"]
      },
       {
        "problemId": 5,
        "courseId": "ibm",
        "title": "Prefix XOR to Original Array",
        "difficulty": "Medium",
        "description": "Given an array pref, where pref[i] is the prefix XOR of the original array arr, find the original array arr. Note: There is always a unique arr for a given pref.",
        "examples": [
          {
            "input": "5\n5 2 0 3 1\n",
            "output": "5 7 2 3 2\n"
          },
          {
            "input": "3\n1 2 3\n",
            "output": "1 3 1\n"
          }
        ],
        "constraints": [
          "1 <= n <= 10^5",
          "0 <= pref[i] <= 10^9"
        ],
        "testCases": [
          {
            "input": "5\n5 2 0 3 1\n",
            "expectedOutput": "5 7 2 3 2\n"
          },
          {
            "input": "3\n1 2 3\n",
            "expectedOutput": "1 3 1\n"
          },
          {
            "input": "1\n10\n",
            "expectedOutput": "10\n"
          },
          {
            "input": "4\n0 1 2 3\n",
            "expectedOutput": "0 1 3 1\n"
          },
          {
            "input": "4\n1 3 2 0\n",
            "expectedOutput": "1 2 1 2\n"
          },
          {
            "input": "6\n1 2 3 4 5 6\n",
            "expectedOutput": "1 3 1 7 1 3\n"
          },
          {
            "input": "6\n6 5 4 3 2 1\n",
            "expectedOutput": "6 3 1 7 3 3\n"
          }
        ],
        "hints": [
          "The first element of the original array arr is the same as the first element of the prefix XOR array pref.",
          "For subsequent elements, arr[i] can be calculated as pref[i] XOR pref[i-1].",
          "Iterate through the prefix XOR array pref and calculate the original array arr using the XOR operation.",
          "Handle the edge case where the input array has only one element."
        ],
        "tags": ["Prefix XOR", "Array", "Bitwise XOR"]
      },
       {
        "problemId": 6,
        "courseId": "ibm",
        "title": "Edit Distance",
        "difficulty": "Medium",
        "description": "Given two strings, word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character, Delete a character, Replace a character.",
        "examples": [
          {
            "input": "horse ros\n",
            "output": "3\n"
          },
          {
            "input": "intention execution\n",
            "output": "5\n"
          }
        ],
        "constraints": [
          "0 <= word1.length, word2.length <= 500",
          "word1 and word2 consist of lowercase English letters."
        ],
        "testCases": [
          {
            "input": "horse ros\n",
            "expectedOutput": "3\n"
          },
          {
            "input": "intention execution\n",
            "expectedOutput": "5\n"
          },
          {
            "input": "a b\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "abc def\n",
            "expectedOutput": "3\n"
          },
          {
            "input": "abc abc\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "abc ab\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "ab abc\n",
            "expectedOutput": "1\n"
          }
        ],
        "hints": [
          "Use dynamic programming to solve this problem.",
          "Create a 2D array dp of size (word1.length + 1) x (word2.length + 1).",
          "Initialize the first row and column of dp with the lengths of the prefixes of word1 and word2.",
          "Iterate through the array and calculate the minimum number of operations for each subproblem.",
          "If the characters at the current positions are the same, dp[i][j] = dp[i-1][j-1].",
          "Otherwise, dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1.",
          "Return dp[word1.length][word2.length]."
        ],
        "tags": ["Edit Distance", "Dynamic Programming", "String Manipulation"]
      },
       {
        "problemId": 7,
        "courseId": "ibm",
        "title": "Stone Balls Game",
        "difficulty": "Hard",
        "description": "Aryan and Ankit play a game with N boxes. There are an even number of boxes arranged in a row, and each box has a positive integer number of stone balls, denoted by balls(i). The objective of the game is to end with the most balls. The total number of balls across all the boxes is odd, so there are no ties. Aryan and Ankit take turns picking all the balls from either the beginning or the end of the row of boxes. Aryan always plays first. Both players play optimally, meaning they make decisions to maximize their number of balls. The game ends when there are no more boxes left. Assume Aryan and Ankit play optimally. Print Aryan if Aryan wins, and print Ankit if Ankit wins.",
        "examples": [
          {
            "input": "4\n1 2 3 4\n",
            "output": "Aryan\n"
          },
          {
            "input": "6\n1 2 3 10 5 1\n",
            "output": "Aryan\n"
          }
        ],
        "constraints": [
          "1 <= N <= 10^2",
          "1 <= Arr(i) <= 10^4"
        ],
        "testCases": [
          {
            "input": "4\n1 2 3 4\n",
            "expectedOutput": "Aryan\n"
          },
          {
            "input": "6\n1 2 3 10 5 1\n",
            "expectedOutput": "Aryan\n"
          },
          {
            "input": "2\n1 2\n",
            "expectedOutput": "Ankit\n"
          },
          {
            "input": "8\n1 2 3 4 5 6 7 8\n",
            "expectedOutput": "Aryan\n"
          },
          {
            "input": "10\n1 2 3 4 5 10 9 8 7 6\n",
            "expectedOutput": "Aryan\n"
          },
          {
            "input": "4\n5 1 2 10\n",
            "expectedOutput": "Aryan\n"
          },
          {
            "input": "6\n10 1 2 3 4 5\n",
            "expectedOutput": "Aryan\n"
          }
        ],
        "hints": [
          "Use dynamic programming to solve this problem.",
          "Create a 2D array dp of size N x N to store the maximum difference in balls that Aryan can achieve.",
          "Initialize the diagonal of dp with the values of the input array.",
          "Iterate through the array and calculate the maximum difference for each subproblem.",
          "dp[i][j] = max(balls[i] - dp[i+1][j], balls[j] - dp[i][j-1]).",
          "If dp[0][N-1] > 0, Aryan wins. Otherwise, Ankit wins.",
          "Handle the edge cases where N is 2."
        ],
        "tags": ["Stone Balls Game", "Dynamic Programming", "Game Theory"]
      },
       {
        "problemId": 8,
        "courseId": "ibm",
        "title": "Power Set with Specific Order",
        "difficulty": "Medium",
        "description": "You are given an integer array nums of unique elements, return all possible power sets. (All subsets). The solution set must not contain duplicate subsets. Print the subsets in a specific order, starting with the largest indexed element and proceeding with combinations that include the largest indexed elements first and then the second largest indexed element, and so on.",
        "examples": [
          {
            "input": "3\n1\n2\n3\n",
            "output": "[3]\n[2, 3]\n[2]\n[1, 3]\n[1, 2, 3]\n[1, 2]\n[1]\n[]\n"
          },
          {
            "input": "2\n-1\n1\n",
            "output": "[1]\n[-1, 1]\n[-1]\n[]\n"
          }
        ],
        "constraints": [
          "1 <= nums.length <= 10",
          "-10 <= nums[i] <= 10",
          "All the numbers of nums are unique."
        ],
        "testCases": [
          {
            "input": "3\n1\n2\n3\n",
            "expectedOutput": "[3]\n[2, 3]\n[2]\n[1, 3]\n[1, 2, 3]\n[1, 2]\n[1]\n[]\n"
          },
          {
            "input": "2\n-1\n1\n",
            "expectedOutput": "[1]\n[-1, 1]\n[-1]\n[]\n"
          },
          {
            "input": "1\n5\n",
            "expectedOutput": "[5]\n[]\n"
          },
          {
            "input": "4\n4\n3\n2\n1\n",
            "expectedOutput": "[1]\n[2, 1]\n[2]\n[3, 1]\n[3, 2, 1]\n[3, 2]\n[3]\n[4, 1]\n[4, 2, 1]\n[4, 2]\n[4, 3, 1]\n[4, 3, 2, 1]\n[4, 3, 2]\n[4, 3]\n[4]\n[]\n"
          },
          {
            "input": "5\n-5\n-4\n-3\n-2\n-1\n",
            "expectedOutput": "[-1]\n[-2, -1]\n[-2]\n[-3, -1]\n[-3, -2, -1]\n[-3, -2]\n[-3]\n[-4, -1]\n[-4, -2, -1]\n[-4, -2]\n[-4, -3, -1]\n[-4, -3, -2, -1]\n[-4, -3, -2]\n[-4, -3]\n[-4]\n[-5, -1]\n[-5, -2, -1]\n[-5, -2]\n[-5, -3, -1]\n[-5, -3, -2, -1]\n[-5, -3, -2]\n[-5, -3]\n[-5, -4, -1]\n[-5, -4, -2, -1]\n[-5, -4, -2]\n[-5, -4, -3, -1]\n[-5, -4, -3, -2, -1]\n[-5, -4, -3, -2]\n[-5, -4, -3]\n[-5, -4]\n[-5]\n[]\n"
          },
          {
            "input": "6\n1\n-2\n3\n-4\n5\n-6\n",
            "expectedOutput": "[-6]\n[5, -6]\n[5]\n[-4, -6]\n[-4, 5, -6]\n[-4, 5]\n[-4]\n[3, -6]\n[3, 5, -6]\n[3, 5]\n[3, -4, -6]\n[3, -4, 5, -6]\n[3, -4, 5]\n[3, -4]\n[3]\n[-2, -6]\n[-2, 5, -6]\n[-2, 5]\n[-2, -4, -6]\n[-2, -4, 5, -6]\n[-2, -4, 5]\n[-2, -4]\n[-2, 3, -6]\n[-2, 3, 5, -6]\n[-2, 3, 5]\n[-2, 3, -4, -6]\n[-2, 3, -4, 5, -6]\n[-2, 3, -4, 5]\n[-2, 3, -4]\n[-2, 3]\n[-2]\n[1, -6]\n[1, 5, -6]\n[1, 5]\n[1, -4, -6]\n[1, -4, 5, -6]\n[1, -4, 5]\n[1, -4]\n[1, 3, -6]\n[1, 3, 5, -6]\n[1, 3, 5]\n[1, 3, -4, -6]\n[1, 3, -4, 5, -6]\n[1, 3, -4, 5]\n[1, 3, -4]\n[1, 3]\n[1, -2, -6]\n[1, -2, 5, -6]\n[1, -2, 5]\n[1, -2, -4, -6]\n[1, -2, -4, 5, -6]\n[1, -2, -4, 5]\n[1, -2, -4]\n[1, -2, 3, -6]\n[1, -2, 3, 5, -6]\n[1, -2, 3, 5]\n[1, -2, 3, -4, -6]\n[1, -2, 3, -4, 5, -6]\n[1, -2, 3, -4, 5]\n[1, -2, 3, -4]\n[1, -2, 3]\n[1, -2]\n[1]\n[]\n"
          }
        ],
        "hints": [
          "Use a recursive approach to generate all subsets.",
          "Start by including the largest indexed element in the subsets.",
          "Recursively generate subsets with and without the current element.",
          "Print the subsets in the specified order.",
          "Handle the base case where the array is empty.",
          "Convert output to string format so it matches the expected output"
        ],
        "tags": ["Power Set", "Subsets", "Recursion", "Combinations"]
      },
       {
        "problemId": 9,
        "courseId": "ibm",
        "title": "Diagonal Sort Matrix",
        "difficulty": "Medium",
        "description": "A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.",
        "examples": [
          {
            "input": "3 3\n3 3 1\n2 2 1\n1 1 1\n",
            "output": "1 3 1\n1 2 2\n1 1 3\n"
          },
          {
            "input": "2 2\n11 25\n66 12\n",
            "output": "11 25\n12 66\n"
          }
        ],
        "constraints": [
          "1 <= M, N <= 10^2",
          "1 <= mat[i][j] <= 10^2"
        ],
        "testCases": [
          {
            "input": "3 3\n3 3 1\n2 2 1\n1 1 1\n",
            "expectedOutput": "1 3 1\n1 2 2\n1 1 3\n"
          },
          {
            "input": "2 2\n11 25\n66 12\n",
            "expectedOutput": "11 25\n12 66\n"
          },
          {
            "input": "4 4\n1 2 3 4\n5 1 2 3\n9 5 1 2\n9 9 5 1\n",
            "expectedOutput": "1 2 3 4\n1 1 2 3\n2 1 1 2\n5 5 1 9\n"
          },
          {
            "input": "1 1\n10\n",
            "expectedOutput": "10\n"
          },
          {
            "input": "2 3\n1 2 3\n4 5 6\n",
            "expectedOutput": "1 2 3\n4 5 6\n"
          },
          {
            "input": "3 2\n1 2\n3 4\n5 6\n",
            "expectedOutput": "1 2\n3 4\n5 6\n"
          },
          {
            "input": "5 5\n1 2 3 4 5\n6 7 8 9 10\n11 12 13 14 15\n16 17 18 19 20\n21 22 23 24 25\n",
            "expectedOutput": "1 2 3 4 5\n6 7 8 9 10\n11 12 13 14 15\n16 17 18 19 20\n21 22 23 24 25\n"
          }
        ],
        "hints": [
          "Iterate through the topmost row and leftmost column to identify the starting points of each diagonal.",
          "For each diagonal, extract the elements, sort them, and update the matrix.",
          "Use a list to store the elements of each diagonal.",
          "Sort the list in ascending order.",
          "Update the matrix with the sorted diagonal elements.",
          "Handle the edge cases where the matrix has only one row or one column."
        ],
        "tags": ["Diagonal Sort", "Matrix Manipulation", "Sorting"]
      },
       {
        "problemId": 10,
        "courseId": "ibm",
        "title": "Minimum Non-Decreasing Subsequence for Unique Elements",
        "difficulty": "Hard",
        "description": "Anna, a talented mathematician at the National Institute of Mathematics, was tasked with organizing a large collection of positive integers. She needed to find the smallest group of numbers (a subsequence) that, when removed from the collection, would leave her with a set of unique numbers. The numbers in the subsequence had to be in non-decreasing order, and Anna only had a limited amount of time to complete the task. Help Anna identify and print the subsequence that, when taken from an array of length N, leaves her with a collection of distinct integers. Since there may be multiple subsequences that can be removed to achieve this result, the subsequence that is both non-decreasing and smallest in length will be considered the optimal solution. If no such subsequence can be found, Anna must print -1.",
        "examples": [
          {
            "input": "5\n1 2 2 3 4\n",
            "output": "2\n"
          },
          {
            "input": "6\n1 2 2 3 3 4\n",
            "output": "2 3\n"
          },
          {
            "input": "4\n1 2 3 4\n",
            "output": "-1\n"
          },
          {
            "input": "5\n1 1 1 1 1\n",
            "output": "1 1 1 1\n"
          },
          {
            "input": "6\n1 2 2 2 3 3\n",
            "output": "2 2 3\n"
          }
        ],
        "constraints": [
          "1 <= N <= 10^5",
          "1 <= Arr[i] <= 10^6"
        ],
        "testCases": [
          {
            "input": "5\n1 2 2 3 4\n",
            "expectedOutput": "2\n"
          },
          {
            "input": "6\n1 2 2 3 3 4\n",
            "expectedOutput": "2 3\n"
          },
          {
            "input": "4\n1 2 3 4\n",
            "expectedOutput": "-1\n"
          },
          {
            "input": "5\n1 1 1 1 1\n",
            "expectedOutput": "1 1 1 1\n"
          },
          {
            "input": "6\n1 2 2 2 3 3\n",
            "expectedOutput": "2 2 3\n"
          },
          {
            "input": "7\n1 2 2 3 3 3 4\n",
            "expectedOutput": "2 3 3\n"
          },
          {
            "input": "8\n1 2 2 3 3 4 4 4\n",
            "expectedOutput": "2 3 4 4\n"
          }
        ],
        "hints": [
          "Use a hash map or set to count the frequency of each element in the array.",
          "Iterate through the array and identify duplicate elements.",
          "Construct a subsequence of duplicate elements in non-decreasing order.",
          "Minimize the length of the subsequence.",
          "If no duplicates are found, print -1.",
          "Maintain the non-decreasing order of the subsequence.",
          "If there are multiple subsequences of the same length, return any one of them."
        ],
        "tags": ["Minimum Subsequence", "Unique Elements", "Array Manipulation", "Hashing"]
      },
       {
        "problemId": 11,
        "courseId": "ibm",
        "title": "Monster Defeat Quest",
        "difficulty": "Medium",
        "description": "While playing an RPG game, you were assigned to complete one of the hardest quests in this game. There are n monsters you’ll need to defeat in this quest. Each monster i is described with two integer numbers – poweri and bonusi. To defeat this monster, you’ll need at least poweri experience points. If you try fighting this monster without having enough experience points, you lose immediately. You will also gain bonusi experience points if you defeat this monster. You can defeat monsters in any order. The quest turned out to be very hard – you try to defeat the monsters but keep losing repeatedly. Your friend told you that this quest is impossible to complete. Knowing that, you’re interested, what is the maximum possible number of monsters you can defeat?",
        "examples": [
          {
            "input": "2\n1\n1\n2\n2\n2\n1\n",
            "output": "2\n"
          },
          {
            "input": "3\n1\n1\n2\n3\n2\n1\n1\n1\n",
            "output": "2\n"
          },
          {
            "input": "4\n10\n10\n11\n12\n13\n1\n2\n3\n4\n",
            "output": "4\n"
          },
          {
            "input": "1\n1\n1\n1\n",
            "output": "1\n"
          },
          {
            "input": "5\n5\n10\n1\n2\n3\n4\n1\n2\n3\n4\n5\n",
            "output": "5\n"
          }
        ],
        "constraints": [
          "1 <= n <= 10^3",
          "1 <= e <= 10^9",
          "1 <= poweri <= 10^9",
          "1 <= bonusi <= 10^9"
        ],
        "testCases": [
          {
            "input": "2\n1\n1\n2\n2\n2\n1\n",
            "expectedOutput": "2\n"
          },
          {
            "input": "3\n1\n1\n2\n3\n2\n1\n1\n1\n",
            "expectedOutput": "2\n"
          },
          {
            "input": "4\n10\n10\n11\n12\n13\n1\n2\n3\n4\n",
            "expectedOutput": "4\n"
          },
          {
            "input": "1\n1\n1\n1\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "5\n5\n10\n1\n2\n3\n4\n1\n2\n3\n4\n5\n",
            "expectedOutput": "5\n"
          }
        ],
        "hints": [
          "Sort the monsters based on the difference between poweri and bonusi.",
          "Iterate through the sorted monsters and check if you have enough experience to defeat them.",
          "If you can defeat a monster, update your experience and increment the count.",
          "Return the count of defeated monsters.",
          "Handle the edge cases where n is 1 or e is 0."
        ],
        "tags": ["Monster Defeat", "RPG Game", "Greedy Algorithm", "Sorting"]
      },
       {
        "problemId": 12,
        "courseId": "ibm",
        "title": "Ancestral Tree Siblings",
        "difficulty": "Medium",
        "description": "Given an ancestral tree represented as an array, find the siblings of a given person X. The tree is structured such that the emperor is at the root (index 0), and their children are at indices (2i + 1) and (2i + 2). Return the sorted list of siblings. If no siblings exist, return [-1].",
        "examples": [
          {
            "input": "5\n[1, 2, 3, 4, 5]\n1\n",
            "output": "[-1]\n"
          },
          {
            "input": "6\n[1, 2, 3, 4, 5, 6]\n5\n",
            "output": "[4, 6]\n"
          }
        ],
        "constraints": [
          "1 <= N <= 100",
          "1 <= Arr[i] <= 100",
          "X is present in the Array"
        ],
        "testCases": [
          {
            "input": "5\n[1, 2, 3, 4, 5]\n1\n",
            "expectedOutput": "[-1]\n"
          },
          {
            "input": "6\n[1, 2, 3, 4, 5, 6]\n5\n",
            "expectedOutput": "[4, 6]\n"
          },
          {
            "input": "7\n[1, 2, 3, 4, 5, 6, 7]\n4\n",
            "expectedOutput": "[6]\n"
          },
          {
            "input": "7\n[1, 2, 3, 4, 5, 6, 7]\n6\n",
            "expectedOutput": "[4]\n"
          },
          {
            "input": "7\n[1, 2, 3, 4, 5, 6, 7]\n7\n",
            "expectedOutput": "[]\n"
          },
          {
            "input": "3\n[1,2,3]\n2\n",
            "expectedOutput": "[3]\n"
          },
          {
            "input": "3\n[1,2,3]\n3\n",
            "expectedOutput": "[2]\n"
          }
        ],
        "hints": [
          "Find the index of X in the array.",
          "Calculate the parent's index using the formula (X_index - 1) // 2.",
          "Find the children of the parent using the formulas 2 * parent_index + 1 and 2 * parent_index + 2.",
          "Return the children that are not X, sorted in ascending order.",
          "If X is the root, or if there are no siblings, return [-1] or empty array respectively."
        ],
        "tags": ["Ancestral Tree", "Siblings", "Array", "Tree Traversal"]
      },
       {
        "problemId": 13,
        "courseId": "ibm",
        "title": "Best Stock Buy Price",
        "difficulty": "Medium",
        "description": "Given an array representing the daily change in stock price over N days, find the best (lowest) price to buy the stock to maximize potential profit. The initial stock price is 0.",
        "examples": [
          {
            "input": "5\n[-39957, -17136, 35466, 21820, -26711]\n",
            "output": "-57093\n"
          },
          {
            "input": "5\n[-39957, -17136, 1, 2, -26711]\n",
            "output": "-80801\n"
          },
          {
            "input": "9\n[-4527, -1579, -38732, -43669, -9287, -48068, -30293, -30867, 18677]\n",
            "output": "-207022\n"
          }
        ],
        "constraints": [
          "1 <= N <= 100",
          "-100000 <= change in stock price <= 100000"
        ],
        "testCases": [
          {
            "input": "5\n[-39957, -17136, 35466, 21820, -26711]\n",
            "expectedOutput": "-57093\n"
          },
          {
            "input": "5\n[-39957, -17136, 1, 2, -26711]\n",
            "expectedOutput": "-80801\n"
          },
          {
            "input": "9\n[-4527, -1579, -38732, -43669, -9287, -48068, -30293, -30867, 18677]\n",
            "expectedOutput": "-207022\n"
          },
          {
            "input": "3\n[1,2,3]\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "3\n[-1,-2,-3]\n",
            "expectedOutput": "-6\n"
          },
          {
            "input": "1\n[10]\n",
            "expectedOutput": "0\n"
          },
          {
             "input": "4\n[-1,2,-3,4]\n",
             "expectedOutput": "-4\n"
          }
        ],
        "hints": [
          "Calculate the cumulative stock price for each day.",
          "Keep track of the minimum cumulative stock price encountered.",
          "The minimum cumulative stock price is the best buy price.",
          "Handle the edge case where all price changes are positive."
        ],
        "tags": ["Stock Price", "Maximum Profit", "Cumulative Sum", "Array"]
      },
       {
        "problemId": 14,
        "courseId": "ibm",
        "title": "Count Numbers with K Set Bits",
        "difficulty": "Medium",
        "description": "Calculate the number of numbers which are less than a given value n and have exactly k set bits in their binary form.",
        "examples": [
          {
            "input": "7 2\n",
            "output": "3\n"
          }
        ],
        "constraints": [
          "1 <= n <= 10000",
          "1 <= k <= 10"
        ],
        "testCases": [
          {
            "input": "7 2\n",
            "expectedOutput": "3\n"
          },
          {
            "input": "10 2\n",
            "expectedOutput": "3\n"
          },
          {
            "input": "16 3\n",
            "expectedOutput": "4\n"
          },
          {
            "input": "32 4\n",
            "expectedOutput": "5\n"
          },
          {
            "input": "100 3\n",
            "expectedOutput": "20\n"
          },
          {
            "input": "1000 5\n",
            "expectedOutput": "126\n"
          },
          {
            "input": "10000 10\n",
            "expectedOutput": "1\n"
          }
        ],
        "hints": [
          "Iterate through all numbers from 1 to n-1.",
          "For each number, count the number of set bits in its binary representation.",
          "If the set bit count is equal to k, increment a counter.",
          "Return the counter.",
          "To count set bits, use bitwise operations or string conversion to binary.",
          "Optimize for large n values if necessary."
        ],
        "tags": ["Set Bits", "Binary Representation", "Bitwise Operations", "Counting"]
      },
       {
        "problemId": 15,
        "courseId": "ibm",
        "title": "Class Monitor Selection",
        "difficulty": "Medium",
        "description": "Given a sequence of student ranks, determine the number of times the HOD had to cut a name from the monitor selection list. The HOD only replaces the current monitor if a student with a lower rank arrives.",
        "examples": [
          {
            "input": "6\n4 3 7 2 6 1\n",
            "output": "3\n"
          }
        ],
        "constraints": [
          "1 <= Number of Visiting <= 10^9",
          "1 <= ranks <= 10000"
        ],
        "testCases": [
          {
            "input": "6\n4 3 7 2 6 1\n",
            "expectedOutput": "3\n"
          },
          {
            "input": "5\n1 2 3 4 5\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "5\n5 4 3 2 1\n",
            "expectedOutput": "4\n"
          },
          {
            "input": "7\n1 1 1 1 1 1 1\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "8\n8 7 6 5 4 3 2 1\n",
            "expectedOutput": "7\n"
          },
           {
            "input":"10\n10 9 8 7 6 5 4 3 2 1\n",
            "expectedOutput":"9\n"
           },
           {
            "input":"10\n1 1 2 2 3 3 4 4 5 5\n",
            "expectedOutput":"0\n"
           }
        ],
        "hints": [
          "Initialize the current monitor's rank with the first rank in the input.",
          "Iterate through the remaining ranks.",
          "If a rank is lower than the current monitor's rank, increment the cut count and update the monitor's rank.",
          "Return the cut count.",
          "Handle the edge case where the input contains only one rank."
        ],
        "tags": ["Monitor Selection", "Rank Comparison", "Counting", "Array"]
      },
       {
        "problemId": 16,
        "courseId": "ibm",
        "title": "Total Momentum of Linked List Particles",
        "difficulty": "Easy",
        "description": "Given a linked list representing particles with mass and velocity, calculate the total momentum of the entity formed by these particles. Momentum is calculated as mass * velocity.",
        "examples": [
          {
            "input": "4\n1 3\n2 4\n2 3\n4 5\n",
            "output": "37\n"
          }
        ],
        "constraints": [
          "1 <= n <= 10000",
          "1 <= m, v <= 100"
        ],
        "testCases": [
          {
            "input": "4\n1 3\n2 4\n2 3\n4 5\n",
            "expectedOutput": "37\n"
          },
          {
            "input": "1\n10 10\n",
            "expectedOutput": "100\n"
          },
          {
            "input": "2\n1 1\n2 2\n",
            "expectedOutput": "5\n"
          },
          {
            "input": "3\n5 2\n3 4\n1 1\n",
            "expectedOutput": "23\n"
          },
          {
            "input": "5\n1 1\n1 2\n1 3\n1 4\n1 5\n",
            "expectedOutput": "15\n"
          },
          {
            "input": "5\n10 1\n9 2\n8 3\n7 4\n6 5\n",
            "expectedOutput": "100\n"
          },
          {
            "input": "6\n1 100\n100 1\n1 100\n100 1\n1 100\n100 1\n",
            "expectedOutput": "303\n"
          }
        ],
        "hints": [
          "Iterate through the linked list (or the input lines).",
          "For each node (or line), calculate the momentum (mass * velocity).",
          "Sum the momentum of all particles.",
          "Return the total momentum."
        ],
        "tags": ["Momentum", "Linked List", "Physics", "Calculation"]
      },
       {
        "problemId": 17,
        "courseId": "ibm",
        "title": "Profit Division",
        "difficulty": "Medium",
        "description": "Given an array of profits, divide the profits between Anand and Brijesh such that the difference between their total profits is minimized. Each profit must be assigned to only one person.",
        "examples": [
          {
            "input": "4\n1 2 3 4\n",
            "output": "0\n"
          }
        ],
        "constraints": [
          "1 <= N <= 10^3",
          "0 <= Profits <= 1000"
        ],
        "testCases": [
          {
            "input": "4\n1 2 3 4\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "3\n1 2 3\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "5\n1 2 3 4 5\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "2\n1 1000\n",
            "expectedOutput": "999\n"
          },
          {
            "input": "1\n100\n",
            "expectedOutput": "100\n"
          },
          {
            "input": "6\n10 10 10 10 10 10\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "7\n1 2 3 4 5 6 7\n",
            "expectedOutput": "0\n"
          }
        ],
        "hints": [
          "Calculate the total sum of all profits.",
          "Use dynamic programming or recursion to find the subset of profits that sums closest to half of the total sum.",
          "The minimum difference is the absolute difference between the total sum and twice the sum of the closest subset.",
          "Handle the edge cases where N is 1 or 2.",
          "Consider using a boolean array to represent whether a particular sum is achievable."
        ],
        "tags": ["Profit Division", "Subset Sum", "Dynamic Programming", "Recursion"]
      },
       {
        "problemId": 18,
        "courseId": "ibm",
        "title": "Balanced Sum",
        "difficulty": "Medium",
        "description": "Given an array of numbers, find the index of the smallest array element (the pivot), for which the sums of all elements to the left and to the right are equal. The array may not be reordered. It is guaranteed that a solution always exists.",
        "examples": [
          {
            "input": "4\n1\n2\n3\n3\n",
            "output": "2\n"
          },
          {
            "input": "5\n1\n2\n3\n4\n6\n",
            "output": "3\n"
          }
        ],
        "constraints": [
          "3 <= n <= 10^5",
          "1 <= arr[i] <= 2 * 10^4, where 0 <= i < n"
        ],
        "testCases": [
          {
            "input": "4\n1\n2\n3\n3\n",
            "expectedOutput": "2\n"
          },
          {
            "input": "5\n1\n2\n3\n4\n6\n",
            "expectedOutput": "3\n"
          },
          {
            "input": "3\n1\n2\n3\n",
            "expectedOutput": "2\n"
          },
          {
            "input": "6\n1\n2\n3\n4\n5\n15\n",
            "expectedOutput": "5\n"
          },
          {
            "input": "7\n1\n2\n3\n4\n5\n6\n21\n",
            "expectedOutput": "6\n"
          },
          {
            "input": "5\n2\n2\n2\n2\n8\n",
            "expectedOutput": "4\n"
          },
          {
            "input": "5\n10\n10\n10\n10\n40\n",
            "expectedOutput": "4\n"
          }
        ],
        "hints": [
          "Calculate the total sum of the array.",
          "Iterate through the array, keeping track of the left sum.",
          "For each element, calculate the right sum using the total sum and the left sum.",
          "If the left sum equals the right sum, return the current index.",
          "Handle edge cases and avoid integer overflow."
        ],
        "tags": ["Balanced Sum", "Array", "Prefix Sum", "Sum Calculation"]
      },
       {
        "problemId": 19,
        "courseId": "ibm",
        "title": "Maximum Subarray Sum",
        "difficulty": "Medium",
        "description": "Given an array of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
        "examples": [
          {
            "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]\n",
            "output": "6\n"
          },
          {
            "input": "[1]\n",
            "output": "1\n"
          },
          {
            "input": "[5,4,-1,7,8]\n",
            "output": "23\n"
          }
        ],
        "constraints": [
          "1 <= length of array <= 10^5",
          "-10^4 <= array elements <= 10^4"
        ],
        "testCases": [
          {
            "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]\n",
            "expectedOutput": "6\n"
          },
          {
            "input": "[1]\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "[5,4,-1,7,8]\n",
            "expectedOutput": "23\n"
          },
          {
            "input": "[-1]\n",
            "expectedOutput": "-1\n"
          },
          {
            "input": "[-2, -3, -1]\n",
            "expectedOutput": "-1\n"
          },
          {
            "input": "[0]\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "[-2, 1]\n",
            "expectedOutput": "1\n"
          }
        ],
        "hints": [
          "Use Kadane's Algorithm.",
          "Initialize two variables: max_so_far and current_max.",
          "Iterate through the array.",
          "Update current_max by taking the maximum of the current element and the sum of the current element and current_max.",
          "Update max_so_far by taking the maximum of max_so_far and current_max.",
          "Return max_so_far."
        ],
        "tags": ["Maximum Subarray", "Kadane's Algorithm", "Dynamic Programming", "Array"]
      },
       {
        "problemId": 20,
        "courseId": "ibm",
        "title": "Sort Array Ascending and Descending",
        "difficulty": "Easy",
        "description": "Given an array of integers, sort it in both ascending and descending order.",
        "examples": [
          {
            "input": "[5, 1, 4, 2, 8]\n",
            "output": "Ascending: [1, 2, 4, 5, 8]\nDescending: [8, 5, 4, 2, 1]\n"
          },
          {
            "input": "[10, 5, 20, 15]\n",
            "output": "Ascending: [5, 10, 15, 20]\nDescending: [20, 15, 10, 5]\n"
          }
        ],
        "constraints": [
          "1 <= length of array <= 10^4",
          "-10^4 <= array elements <= 10^4"
        ],
        "testCases": [
          {
            "input": "[5, 1, 4, 2, 8]\n",
            "expectedOutput": "Ascending: [1, 2, 4, 5, 8]\nDescending: [8, 5, 4, 2, 1]\n"
          },
          {
            "input": "[10, 5, 20, 15]\n",
            "expectedOutput": "Ascending: [5, 10, 15, 20]\nDescending: [20, 15, 10, 5]\n"
          },
          {
            "input": "[1]\n",
            "expectedOutput": "Ascending: [1]\nDescending: [1]\n"
          },
          {
            "input": "[-1, -2, -3]\n",
            "expectedOutput": "Ascending: [-3, -2, -1]\nDescending: [-1, -2, -3]\n"
          },
          {
            "input": "[0, 0, 0]\n",
            "expectedOutput": "Ascending: [0, 0, 0]\nDescending: [0, 0, 0]\n"
          },
          {
            "input": "[1, 2, 3, 4, 5]\n",
            "expectedOutput": "Ascending: [1, 2, 3, 4, 5]\nDescending: [5, 4, 3, 2, 1]\n"
          },
          {
            "input": "[5, 4, 3, 2, 1]\n",
            "expectedOutput": "Ascending: [1, 2, 3, 4, 5]\nDescending: [5, 4, 3, 2, 1]\n"
          }
        ],
        "hints": [
          "Use built-in sorting functions or implement a sorting algorithm (e.g., quicksort, mergesort).",
          "Sort the array in ascending order.",
          "Sort the array in descending order.",
          "Return both sorted arrays.",
          "Handle edge cases like empty arrays or arrays with single elements."
        ],
        "tags": ["Sorting", "Array Manipulation", "Ascending Order", "Descending Order"]
      },
       {
        "problemId": 21,
        "courseId": "ibm",
        "title": "Shortest Path in Graph",
        "difficulty": "Medium",
        "description": "Given a graph represented as an adjacency list and two nodes (source and destination), find the shortest path between the two nodes.",
        "examples": [
          {
            "input": "Graph: {0: [1, 2], 1: [2, 3], 2: [3], 3: []}\nSource: 0\nDestination: 3\n",
            "output": "[0, 1, 3]\n"
          },
          {
            "input": "Graph: {0: [1, 2], 1: [3], 2: [3], 3: []}\nSource: 0\nDestination: 3\n",
            "output": "[0, 1, 3]\n"
          }
        ],
        "constraints": [
          "1 <= number of nodes <= 100",
          "Nodes are represented by integers.",
          "The graph may be directed or undirected.",
          "A path between the source and destination is guaranteed to exist."
        ],
        "testCases": [
          {
            "input": "Graph: {0: [1, 2], 1: [2, 3], 2: [3], 3: []}\nSource: 0\nDestination: 3\n",
            "expectedOutput": "[0, 1, 3]\n"
          },
          {
            "input": "Graph: {0: [1, 2], 1: [3], 2: [3], 3: []}\nSource: 0\nDestination: 3\n",
            "expectedOutput": "[0, 1, 3]\n"
          },
          {
            "input": "Graph: {0: [1], 1: [2], 2: [3], 3: [4], 4: []}\nSource: 0\nDestination: 4\n",
            "expectedOutput": "[0, 1, 2, 3, 4]\n"
          },
          {
            "input": "Graph: {0: [2], 1: [3], 2: [4], 3: [4], 4: []}\nSource: 0\nDestination: 4\n",
            "expectedOutput": "[0, 2, 4]\n"
          },
          {
            "input": "Graph: {0: [1, 2, 3], 1: [4], 2: [4], 3: [4], 4: []}\nSource: 0\nDestination: 4\n",
            "expectedOutput": "[0, 1, 4]\n"
          },
          {
            "input": "Graph: {0: [1, 2], 1: [3], 2: [3], 3: [4], 4: []}\nSource: 0\nDestination: 4\n",
            "expectedOutput": "[0, 1, 3, 4]\n"
          },
          {
            "input": "Graph: {0: [1, 2], 1: [2, 3], 2: [3, 4], 3: [4], 4: []}\nSource: 0\nDestination: 4\n",
            "expectedOutput": "[0, 2, 4]\n"
          }
        ],
        "hints": [
          "Use Breadth-First Search (BFS) to find the shortest path.",
          "Maintain a queue for nodes to be visited and a dictionary to store the parent of each node.",
          "Start BFS from the source node.",
          "When the destination node is reached, backtrack from the destination to the source using the parent dictionary to construct the shortest path.",
          "Handle the case where the source and destination are the same node."
        ],
        "tags": ["Shortest Path", "Graph", "BFS", "Breadth-First Search"]
      },
       {
        "problemId": 22,
        "courseId": "ibm",
        "title": "Is Binary Search Tree",
        "difficulty": "Medium",
        "description": "Given a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.",
        "examples": [
          {
            "input": "Tree: [2, 1, 3]\n",
            "output": "true\n"
          },
          {
            "input": "Tree: [5, 1, 4, null, null, 3, 6]\n",
            "output": "false\n"
          }
        ],
        "constraints": [
          "1 <= number of nodes <= 10^4",
          "-2^31 <= node values <= 2^31 - 1"
        ],
        "testCases": [
          {
            "input": "Tree: [2, 1, 3]\n",
            "expectedOutput": "true\n"
          },
          {
            "input": "Tree: [5, 1, 4, null, null, 3, 6]\n",
            "expectedOutput": "false\n"
          },
          {
            "input": "Tree: [10, 5, 15, null, null, 6, 20]\n",
            "expectedOutput": "false\n"
          },
          {
            "input": "Tree: [10, 5, 15, null, null, 12, 20]\n",
            "expectedOutput": "true\n"
          },
          {
            "input": "Tree: [1]\n",
            "expectedOutput": "true\n"
          },
          {
            "input": "Tree: []\n",
            "expectedOutput": "true\n"
          },
          {
            "input": "Tree: [2,2,2]\n",
            "expectedOutput": "false\n"
          }
        ],
        "hints": [
          "Use an in-order traversal of the tree.",
          "During the traversal, keep track of the previously visited node's value.",
          "If the current node's value is less than or equal to the previous node's value, the tree is not a BST.",
          "Alternatively, use recursion with upper and lower bounds for each node's value.",
          "Pass the minimum and maximum allowed values for the left and right subtrees during recursion.",
          "Handle the edge cases where the tree is empty or has only one node."
        ],
        "tags": ["Binary Search Tree", "BST", "Tree Traversal", "Recursion", "In-Order Traversal"]
      },
       {
        "problemId": 23,
        "courseId": "ibm",
        "title": "Two Sum",
        "difficulty": "Easy",
        "description": "Given an array of integers, find the two numbers that add up to a specific target sum. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
        "examples": [
          {
            "input": "Array: [2, 7, 11, 15]\nTarget: 9\n",
            "output": "[0, 1]\n"
          },
          {
            "input": "Array: [3, 2, 4]\nTarget: 6\n",
            "output": "[1, 2]\n"
          },
          {
            "input": "Array: [3, 3]\nTarget: 6\n",
            "output": "[0, 1]\n"
          }
        ],
        "constraints": [
          "2 <= length of array <= 10^4",
          "-10^9 <= array elements <= 10^9",
          "-10^9 <= target sum <= 10^9",
          "There is exactly one solution."
        ],
        "testCases": [
          {
            "input": "Array: [2, 7, 11, 15]\nTarget: 9\n",
            "expectedOutput": "[0, 1]\n"
          },
          {
            "input": "Array: [3, 2, 4]\nTarget: 6\n",
            "expectedOutput": "[1, 2]\n"
          },
          {
            "input": "Array: [3, 3]\nTarget: 6\n",
            "expectedOutput": "[0, 1]\n"
          },
          {
            "input": "Array: [-1, -2, -3, -4, -5]\nTarget: -8\n",
            "expectedOutput": "[2, 4]\n"
          },
          {
            "input": "Array: [0, 4, 3, 0]\nTarget: 0\n",
            "expectedOutput": "[0, 3]\n"
          },
          {
            "input": "Array: [10, 20, 30, 40, 50]\nTarget: 70\n",
            "expectedOutput": "[2, 3]\n"
          },
          {
            "input": "Array: [-10, -20, -30, -40, -50]\nTarget: -60\n",
            "expectedOutput": "[1, 2]\n"
          }
        ],
        "hints": [
          "Use a hash map to store the numbers and their indices.",
          "Iterate through the array and check if the complement (target - current number) exists in the hash map.",
          "If the complement exists, return the indices of the current number and the complement.",
          "Handle the case where the input array contains duplicate numbers.",
          "Consider using a set if indices are not required"
        ],
        "tags": ["Two Sum", "Hash Map", "Array", "Two Pointers"]
      },
      {
        "problemId": 24,
        "courseId": "ibm",
        "title": "Clone Linked List",
        "difficulty": "Medium",
        "description": "Given a linked list, create a deep copy (clone) of it. The linked list may contain random pointers in addition to the next pointer.",
        "examples": [
          {
            "input": "List: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n",
            "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]\n"
          },
          {
            "input": "List: [[1,1],[2,1]]\n",
            "output": "[[1,1],[2,1]]\n"
          },
          {
            "input": "List: [[3,null],[3,0],[3,null]]\n",
            "output": "[[3,null],[3,0],[3,null]]\n"
          }
        ],
        "constraints": [
          "0 <= length of list <= 1000",
          "-10^4 <= Node.val <= 10^4",
          "Node.random is either null or a valid index in the list."
        ],
        "testCases": [
          {
            "input": "List: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n",
            "expectedOutput": "[[7,null],[13,0],[11,4],[10,2],[1,0]]\n"
          },
          {
            "input": "List: [[1,1],[2,1]]\n",
            "expectedOutput": "[[1,1],[2,1]]\n"
          },
          {
            "input": "List: [[3,null],[3,0],[3,null]]\n",
            "expectedOutput": "[[3,null],[3,0],[3,null]]\n"
          },
          {
            "input": "List: []\n",
            "expectedOutput": "[]\n"
          },
          {
            "input": "List: [[1,null]]\n",
            "expectedOutput": "[[1,null]]\n"
          },
          {
            "input": "List: [[1,0]]\n",
            "expectedOutput": "[[1,0]]\n"
          },
          {
            "input": "List: [[1,0],[2,0]]\n",
            "expectedOutput": "[[1,0],[2,0]]\n"
          }
        ],
        "hints": [
          "Use a hash map to store the mapping between original nodes and their clones.",
          "Iterate through the original list and create a new node for each original node.",
          "Store the mapping between original nodes and their clones in the hash map.",
          "Iterate through the original list again and set the next and random pointers of the cloned nodes using the hash map.",
          "Return the head of the cloned list.",
          "Handle the edge case where the input list is empty."
        ],
        "tags": ["Clone Linked List", "Linked List", "Hash Map", "Deep Copy"]
      },
       {
        "problemId": 25,
        "courseId": "ibm",
        "title": "Is Bipartite Graph",
        "difficulty": "Medium",
        "description": "Given an undirected graph, determine if it is bipartite. A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. The graph is given as an adjacency list.",
        "examples": [
          {
            "input": "Graph: [[1, 3], [0, 2], [1, 3], [0, 2]]\n",
            "output": "true\n"
          },
          {
            "input": "Graph: [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\n",
            "output": "false\n"
          }
        ],
        "constraints": [
          "1 <= number of nodes <= 100",
          "0 <= node values < number of nodes",
          "The graph is undirected.",
          "The graph may not be connected."
        ],
        "testCases": [
          {
            "input": "Graph: [[1, 3], [0, 2], [1, 3], [0, 2]]\n",
            "expectedOutput": "true\n"
          },
          {
            "input": "Graph: [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\n",
            "expectedOutput": "false\n"
          },
          {
            "input": "Graph: [[1], [0], [3], [2]]\n",
            "expectedOutput": "true\n"
          },
          {
            "input": "Graph: [[1, 2], [0, 2], [0, 1]]\n",
            "expectedOutput": "false\n"
          },
          {
            "input": "Graph: [[], [2, 4, 6], [1, 4, 8, 9], [7, 8], [1, 2, 8, 9], [7, 8], [1, 9], [3, 5], [2, 4, 3], [2, 4, 6]]\n",
            "expectedOutput": "false\n"
          },
          {
            "input": "Graph: [[1], [0, 3], [3], [1, 2]]\n",
            "expectedOutput": "true\n"
          },
          {
            "input": "Graph: [[], [2], [1]]\n",
            "expectedOutput": "true\n"
          }
        ],
        "hints": [
          "Use Breadth-First Search (BFS) or Depth-First Search (DFS).",
          "Color the nodes with two colors (e.g., 0 and 1).",
          "Start from an arbitrary node and color it with one color.",
          "Color all its neighbors with the opposite color.",
          "Continue coloring the neighbors' neighbors and so on.",
          "If you encounter a neighbor that has the same color as the current node, the graph is not bipartite.",
          "If the graph is not connected, repeat the process for each connected component.",
          "Handle the case where the graph is empty or has only one node."
        ],
        "tags": ["Bipartite Graph", "Graph", "BFS", "DFS", "Graph Coloring"]
      },
       {
        "problemId": 26,
        "courseId": "ibm",
        "title": "Missing Number",
        "difficulty": "Easy",
        "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
        "examples": [
          {
            "input": "[3, 0, 1]\n",
            "output": "2\n"
          },
          {
            "input": "[0, 1]\n",
            "output": "2\n"
          },
          {
            "input": "[9, 6, 4, 2, 3, 5, 7, 0, 1]\n",
            "output": "8\n"
          }
        ],
        "constraints": [
          "n == nums.length",
          "1 <= n <= 10^4",
          "0 <= nums[i] <= n",
          "All the numbers of nums are unique."
        ],
        "testCases": [
          {
            "input": "[3, 0, 1]\n",
            "expectedOutput": "2\n"
          },
          {
            "input": "[0, 1]\n",
            "expectedOutput": "2\n"
          },
          {
            "input": "[9, 6, 4, 2, 3, 5, 7, 0, 1]\n",
            "expectedOutput": "8\n"
          },
          {
            "input": "[0]\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "[1]\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "[0, 2, 3]\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "[1, 2, 3]\n",
            "expectedOutput": "0\n"
          }
        ],
        "hints": [
          "Calculate the sum of numbers from 0 to n using the formula n * (n + 1) / 2.",
          "Calculate the sum of the numbers in the given array.",
          "The missing number is the difference between the two sums.",
          "Alternatively, use bitwise XOR to find the missing number.",
          "XOR all numbers from 0 to n and XOR all numbers in the array. The result is the missing number.",
          "This approach satisfies the O(1) extra space complexity requirement."
        ],
        "tags": ["Array", "Hash Table", "Math", "Binary Search", "Bit Manipulation", "Sorting"]
      },
       {
        "problemId": 27,
        "courseId": "ibm",
        "title": "Phone Number Conversion",
        "difficulty": "Medium",
        "description": "Given a phone number in words, convert it to digits. The phone number will be 10 digits long. Repeating digits will be shortened using the words 'double' and 'triple'.",
        "examples": [
          {
            "input": "six four eight three\n",
            "output": "6483000000\n"
          },
          {
            "input": "one double two three\n",
            "output": "1223000000\n"
          },
          {
            "input": "triple five six seven\n",
            "output": "5556700000\n"
          },
          {
            "input": "double two triple four\n",
            "output": "2244400000\n"
          },
          {
            "input": "double one double two double three double four double five\n",
            "output": "1122334455\n"
          }
      
        ],
        "constraints": [
          "The input string will only contain the words 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'double', 'triple'.",
          "The resulting phone number will be 10 digits long.",
          "The input string will be a valid representation of a 10 digit number."
        ],
        "testCases": [
          {
            "input": "six four eight three\n",
            "expectedOutput": "6483000000\n"
          },
          {
            "input": "one double two three\n",
            "expectedOutput": "1223000000\n"
          },
          {
            "input": "triple five six seven\n",
            "expectedOutput": "5556700000\n"
          },
          {
            "input": "double two triple four\n",
            "expectedOutput": "2244400000\n"
          },
           {
            "input": "zero zero zero zero zero zero zero zero zero zero\n",
            "expectedOutput": "0000000000\n"
           },
           {
            "input": "nine nine nine nine nine nine nine nine nine nine\n",
            "expectedOutput": "9999999999\n"
           },
          {
            "input": "double one double two double three double four double five\n",
            "expectedOutput": "1122334455\n"
          }
        ],
        "hints": [
          "Create a dictionary to map word representations of digits to their numerical values.",
          "Iterate through the input string, processing each word.",
          "Keep track of repeating digits using counters.",
          "Handle the 'double' and 'triple' keywords to expand the repeating digits.",
          "Build the resulting digit string.",
          "Ensure the resulting string is 10 digits long by appending zeros if necessary."
        ],
        "tags": ["Phone Number Conversion", "String Manipulation", "Dictionary", "Text Processing"]
      },
       {
        "problemId": 28,
        "courseId": "ibm",
        "title": "Longest Common Prefix",
        "difficulty": "Easy",
        "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
        "examples": [
          {
            "input": "[\"flower\", \"flow\", \"flight\"]\n",
            "output": "\"fl\"\n"
          },
          {
            "input": "[\"dog\", \"racecar\", \"car\"]\n",
            "output": "\"\"\n"
          }
        ],
        "constraints": [
          "1 <= strs.length <= 200",
          "0 <= strs[i].length <= 200",
          "strs[i] consists of only lowercase English letters if it is non-empty."
        ],
        "testCases": [
          {
            "input": "[\"flower\", \"flow\", \"flight\"]\n",
            "expectedOutput": "\"fl\"\n"
          },
          {
            "input": "[\"dog\", \"racecar\", \"car\"]\n",
            "expectedOutput": "\"\"\n"
          },
          {
            "input": "[\"apple\", \"application\", \"apply\"]\n",
            "expectedOutput": "\"appl\"\n"
          },
          {
            "input": "[\"a\"]\n",
            "expectedOutput": "\"a\"\n"
          },
          {
            "input": "[]\n",
            "expectedOutput": "\"\"\n"
          },
          {
            "input": "[\"abc\", \"abcd\", \"abcde\"]\n",
            "expectedOutput": "\"abc\"\n"
          },
          {
            "input": "[\"aa\", \"a\"]\n",
            "expectedOutput": "\"a\"\n"
          }
        ],
        "hints": [
          "Iterate through the characters of the first string.",
          "For each character, check if all other strings have the same character at the same index.",
          "If all strings have the same character, append it to the result.",
          "If any string has a different character or is shorter, return the result.",
          "Handle edge cases like empty arrays or empty strings."
        ],
        "tags": ["String"]
      },
      {
        "problemId": 29,
        "courseId": "ibm",
        "title": "3Sum",
        "difficulty": "Medium",
        "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
        "examples": [
          {
            "input": "[-1, 0, 1, 2, -1, -4]\n",
            "output": "[[-1, -1, 2], [-1, 0, 1]]\n"
          },
          {
            "input": "[0, 1, 1]\n",
            "output": "[]\n"
          },
          {
            "input": "[0, 0, 0]\n",
            "output": "[[0, 0, 0]]\n"
          }
        ],
        "constraints": [
          "3 <= nums.length <= 3000",
          "-10^5 <= nums[i] <= 10^5"
        ],
        "testCases": [
          {
            "input": "[-1, 0, 1, 2, -1, -4]\n",
            "expectedOutput": "[[-1, -1, 2], [-1, 0, 1]]\n"
          },
          {
            "input": "[0, 1, 1]\n",
            "expectedOutput": "[]\n"
          },
          {
            "input": "[0, 0, 0]\n",
            "expectedOutput": "[[0, 0, 0]]\n"
          },
          {
            "input": "[-2, 0, 1, 1, 2]\n",
            "expectedOutput": "[[-2, 0, 2], [-2, 1, 1]]\n"
          },
          {
            "input": "[-2, -2, -2, 0, 0, 0, 2, 2, 2]\n",
            "expectedOutput": "[[-2, 0, 2], [0, 0, 0]]\n"
          },
          {
            "input": "[-1, 0, 1, 0]\n",
            "expectedOutput": "[[-1, 0, 1]]\n"
          },
          {
            "input": "[-1, -1, -1, 0, 1, 2]\n",
            "expectedOutput": "[[-1, -1, 2], [-1, 0, 1]]\n"
          }
        ],
        "hints": [
          "Sort the array.",
          "Iterate through the array and fix one number (nums[i]).",
          "Use two pointers (left and right) to find the other two numbers (nums[left] and nums[right]) such that nums[i] + nums[left] + nums[right] == 0.",
          "Move the left and right pointers towards each other based on the sum of the three numbers.",
          "Skip duplicate numbers to avoid duplicate triplets.",
          "Handle edge cases like empty arrays or arrays with fewer than three elements."
        ],
        "tags": ["Array", "Two Pointers", "Sorting"]
      },
      {
        "problemId": 30,
        "courseId": "ibm",
        "title": "Distinct Cost Pairs",
        "difficulty": "Medium",
        "description": "Given an array of project costs and a target difference, find the number of distinct pairs of project costs where their absolute difference is equal to the target value. Two pairs are distinct if they differ in at least one value.",
        "examples": [
          {
            "input": "3\n[1, 3, 5]\n2\n",
            "output": "2\n"
          }
        ],
        "constraints": [
          "1 <= target <= 10^9",
          "1 <= N <= 10^5",
          "1 <= projectCosts[i] <= 2 * 10^9"
        ],
        "testCases": [
          {
            "input": "3\n[1, 3, 5]\n2\n",
            "expectedOutput": "2\n"
          },
          {
            "input": "4\n[1, 5, 3, 7]\n4\n",
            "expectedOutput": "2\n"
          },
          {
            "input": "5\n[1, 1, 2, 3, 4]\n1\n",
            "expectedOutput": "3\n"
          },
          {
            "input": "2\n[1, 1000]\n999\n",
            "expectedOutput": "1\n"
          },
          {
            "input": "1\n[1]\n10\n",
            "expectedOutput": "0\n"
          },
          {
            "input": "6\n[1, 1, 1, 2, 2, 3]\n1\n",
            "expectedOutput": "5\n"
          },
          {
            "input": "4\n[10, 20, 30, 40]\n10\n",
            "expectedOutput": "3\n"
          }
        ],
        "hints": [
          "Sort the array to efficiently find pairs.",
          "Use two pointers to iterate through the sorted array.",
          "Calculate the absolute difference between the two pointers' values.",
          "If the difference equals the target, increment the count and move both pointers.",
          "If the difference is less than the target, move the right pointer.",
          "If the difference is greater than the target, move the left pointer.",
          "Handle duplicate pairs carefully to ensure distinctness.",
          "Consider using a set to store unique pairs."
        ],
        "tags": ["Distinct Pairs", "Target Difference", "Sorting", "Two Pointers"]
      }
]