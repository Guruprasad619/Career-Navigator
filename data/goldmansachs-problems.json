[
	{
  "problemId": 1,
  "courseId": "goldmansachs",
  "title": "Trapping Rain Water",
  "difficulty": "Hard",
  "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
  "examples": [
    {
      "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
      "output": "6",
      "explanation": "The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped."
    },
    {
      "input": "height = [4,2,0,3,2,5]",
      "output": "9"
    }
  ],
  "constraints": [
    "n == height.length",
    "1 <= n <= 2 * 10^4",
    "0 <= height[i] <= 10^5"
  ],
  "testCases": [
    {
      "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
      "expectedOutput": "6"
    },
    {
      "input": "[4,2,0,3,2,5]",
      "expectedOutput": "9"
    },
    {
      "input": "[2,0,2]",
      "expectedOutput": "2"
    },
    {
      "input": "[3,0,1,0,4]",
      "expectedOutput": "7"
    },
    {
      "input": "[6,4,2,0,3,2,0,3,1,4,5,3,2,7,5,3,0,1,2,1]",
      "expectedOutput": "53"
    },
    {
      "input": "[1,2,3,4,5]",
      "expectedOutput": "0"
    },
    {
      "input": "[5,4,3,2,1]",
      "expectedOutput": "0"
    }
  ],
  "hints": [
    "Use two pointers to traverse the array from both ends.",
    "Maintain the maximum height seen from the left and right pointers.",
    "Calculate the water trapped at each position based on the minimum of the left and right maximum heights.",
    "Move the pointer with the smaller maximum height towards the center.",
    "Sum up the water trapped at each position to get the total trapped water."
  ],
  "tags": ["Array", "Two Pointers", "Dynamic Programming", "Stack", "Monotonic Stack"]
},
{
  "problemId": 2,
  "courseId": "goldmansachs",
  "title": "Minimum Size Subarray Sum",
  "difficulty": "Medium",
  "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.",
  "examples": [
    {
      "input": "target = 7, nums = [2,3,1,2,4,3]",
      "output": "2",
      "explanation": "The subarray [4,3] has the minimal length under the problem constraint."
    },
    {
      "input": "target = 4, nums = [1,4,4]",
      "output": "1"
    },
    {
      "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
      "output": "0"
    }
  ],
  "constraints": [
    "1 <= target <= 10^9",
    "1 <= nums.length <= 10^5",
    "1 <= nums[i] <= 10^4"
  ],
  "testCases": [
    {
      "input": "7 [2,3,1,2,4,3]",
      "expectedOutput": "2"
    },
    {
      "input": "4 [1,4,4]",
      "expectedOutput": "1"
    },
    {
      "input": "11 [1,1,1,1,1,1,1,1]",
      "expectedOutput": "0"
    },
    {
      "input": "15 [1,2,3,4,5]",
      "expectedOutput": "3"
    },
    {
      "input": "5 [1,2,3,4,5]",
      "expectedOutput": "2"
    },
    {
      "input": "1 [1]",
      "expectedOutput": "1"
    },
    {
      "input": "100 [1,1,1,1,1,1,1,1,1,1,100]",
      "expectedOutput": "1"
    }
  ],
  "hints": [
    "Use a sliding window approach.",
    "Maintain a window of elements and calculate their sum.",
    "If the sum is greater than or equal to the target, update the minimum length and shrink the window from the left.",
    "If the sum is less than the target, expand the window from the right.",
    "Continue this process until the right pointer reaches the end of the array.",
    "If no subarray is found, return 0."
  ],
  "tags": ["Array", "Binary Search", "Sliding Window", "Prefix Sum"]
},
{
  "problemId": 3,
  "courseId": "goldmansachs",
  "title": "Game of Life",
  "difficulty": "Medium",
  "description": "Given a 2D board representing the current state of the Game of Life, update the board to reflect its next state. The rules of the Game of Life are: Any live cell with fewer than two live neighbors dies; Any live cell with two or three live neighbors lives on; Any live cell with more than three live neighbors dies; Any dead cell with exactly three live neighbors becomes a live cell.",
  "examples": [
    {
      "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
      "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
    },
    {
      "input": "board = [[1,1],[1,0]]",
      "output": "[[1,1],[1,1]]"
    }
  ],
  "constraints": [
    "m == board.length",
    "n == board[i].length",
    "1 <= m, n <= 25",
    "board[i][j] is 0 or 1"
  ],
  "testCases": [
    {
      "input": "[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
      "expectedOutput": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
    },
    {
      "input": "[[1,1],[1,0]]",
      "expectedOutput": "[[1,1],[1,1]]"
    },
    {
      "input": "[[0]]",
      "expectedOutput": "[[0]]"
    },
    {
      "input": "[[1]]",
      "expectedOutput": "[[0]]"
    },
    {
      "input": "[[1,0,1],[0,1,0],[1,0,1]]",
      "expectedOutput": "[[0,1,0],[1,0,1],[0,1,0]]"
    },
     {
      "input": "[[0,0,0,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0]]",
      "expectedOutput": "[[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,1,1,0],[0,0,0,0,0]]"
    },
    {
      "input": "[[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]",
      "expectedOutput": "[[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]"
    }
  ],
  "hints": [
    "To solve it in-place, use bit manipulation to store the next state of a cell in the same cell.",
    "Use two bits to represent a cell's state: the least significant bit for the current state and the second least significant bit for the next state.",
    "Iterate through the board and count the live neighbors for each cell.",
    "Update the second least significant bit based on the Game of Life rules.",
    "After updating all cells, shift the bits to get the next state.",
    "To handle the infinite board scenario, consider using a sparse matrix or a hash map to store the live cells."
  ],
  "tags": ["Array", "Matrix", "Simulation"]
},
{
  "problemId": 4,
  "courseId": "goldmansachs",
  "title": "Median of Two Sorted Arrays",
  "difficulty": "Hard",
  "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
  "examples": [
    {
      "input": "nums1 = [1,3], nums2 = [2]",
      "output": "2.00000",
      "explanation": "merged array = [1,2,3] and median is 2."
    },
    {
      "input": "nums1 = [1,2], nums2 = [3,4]",
      "output": "2.50000",
      "explanation": "merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
    }
  ],
  "constraints": [
    "nums1.length == m",
    "nums2.length == n",
    "0 <= m <= 1000",
    "0 <= n <= 1000",
    "1 <= m + n <= 2000",
    "-10^6 <= nums1[i], nums2[i] <= 10^6"
  ],
  "testCases": [
    {
      "input": "[1,3] [2]",
      "expectedOutput": "2.00000"
    },
    {
      "input": "[1,2] [3,4]",
      "expectedOutput": "2.50000"
    },
    {
      "input": "[0,0] [0,0]",
      "expectedOutput": "0.00000"
    },
    {
      "input": "[] [1]",
      "expectedOutput": "1.00000"
    },
    {
      "input": "[2] []",
      "expectedOutput": "2.00000"
    },
    {
      "input": "[1,2,3,4,5] [6,7,8,9,10]",
      "expectedOutput": "5.50000"
    },
    {
      "input": "[1,2,3] [4,5,6,7,8]",
      "expectedOutput": "4.50000"
    }
  ],
  "hints": [
    "Use binary search to find the partition that divides the two arrays into two halves with equal or almost equal lengths.",
    "The median can be calculated from the maximum of the left halves and the minimum of the right halves.",
    "Handle the edge cases where one of the arrays is empty or the partition is at the beginning or end of an array.",
    "Ensure the time complexity is O(log(min(m, n))) by performing binary search on the smaller array."
  ],
  "tags": ["Array", "Binary Search", "Divide and Conquer"]
},
{
  "problemId": 5,
  "courseId": "goldmansachs",
  "title": "Knight Probability in Chessboard",
  "difficulty": "Medium",
  "description": "On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. Return the probability that the knight remains on the board after it has stopped moving.",
  "examples": [
    {
      "input": "n = 3, k = 2, row = 0, column = 0",
      "output": "0.06250",
      "explanation": "There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625."
    },
    {
      "input": "n = 1, k = 0, row = 0, column = 0",
      "output": "1.00000"
    }
  ],
  "constraints": [
    "1 <= n <= 25",
    "0 <= k <= 100",
    "0 <= row, column <= n - 1"
  ],
  "testCases": [
    {
      "input": "3 2 0 0",
      "expectedOutput": "0.06250"
    },
    {
      "input": "1 0 0 0",
      "expectedOutput": "1.00000"
    },
    {
      "input": "8 3 6 4",
      "expectedOutput": "0.12500"
    },
    {
      "input": "6 1 2 2",
      "expectedOutput": "0.25000"
    },
    {
      "input": "25 100 0 0",
      "expectedOutput": "0.00000"
    },
    {
      "input": "8 1 0 0",
      "expectedOutput": "0.25000"
    },
    {
      "input": "8 2 0 0",
      "expectedOutput": "0.12500"
    }
  ],
  "hints": [
    "Use dynamic programming to solve this problem.",
    "Create a 3D array dp where dp[i][r][c] represents the probability of the knight being at cell (r, c) after i moves.",
    "Initialize dp[0][row][column] to 1.0, as the knight starts at (row, column).",
    "For each move i from 1 to k, iterate through all cells (r, c) on the board.",
    "For each cell (r, c), calculate the probability of the knight reaching that cell from its eight possible moves in the previous move (i-1).",
    "Update dp[i][r][c] with the sum of these probabilities, divided by 8 (the number of possible moves).",
    "Sum up the probabilities dp[k][r][c] for all cells (r, c) on the board to get the final probability.",
    "Handle the edge cases where the knight moves off the board."
  ],
  "tags": ["Dynamic Programming"]
},
{
  "problemId": 6,
  "courseId": "goldmansachs",
  "title": "First Unique Character in a String",
  "difficulty": "Easy",
  "description": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.",
  "examples": [
    {
      "input": "s = \"leetcode\"",
      "output": "0",
      "explanation": "The character 'l' at index 0 is the first character that does not occur at any other index."
    },
    {
      "input": "s = \"loveleetcode\"",
      "output": "2"
    },
    {
      "input": "s = \"aabb\"",
      "output": "-1"
    }
  ],
  "constraints": [
    "1 <= s.length <= 10^5",
    "s consists of only lowercase English letters."
  ],
  "testCases": [
    {
      "input": "leetcode",
      "expectedOutput": "0"
    },
    {
      "input": "loveleetcode",
      "expectedOutput": "2"
    },
    {
      "input": "aabb",
      "expectedOutput": "-1"
    },
    {
      "input": "z",
      "expectedOutput": "0"
    },
    {
      "input": "dddccdbba",
      "expectedOutput": "8"
    },
    {
      "input": "abcabc",
      "expectedOutput": "-1"
    },
    {
      "input": "aabbc",
      "expectedOutput": "4"
    }
  ],
  "hints": [
    "Use a hash table (dictionary) to store the frequency of each character in the string.",
    "Iterate through the string and update the frequency of each character in the hash table.",
    "Iterate through the string again and check the frequency of each character in the hash table.",
    "If a character has a frequency of 1, return its index.",
    "If no character has a frequency of 1, return -1."
  ],
  "tags": ["Hash Table", "String", "Queue", "Counting"]
},
{
  "problemId": 7,
  "courseId": "goldmansachs",
  "title": "Fraction Addition and Subtraction",
  "difficulty": "Medium",
  "description": "Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format. The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1.",
  "examples": [
    {
      "input": "expression = \"-1/2+1/2\"",
      "output": "\"0/1\""
    },
    {
      "input": "expression = \"-1/2+1/2+1/3\"",
      "output": "\"1/3\""
    },
    {
      "input": "expression = \"1/3-1/2\"",
      "output": "\"-1/6\""
    }
  ],
  "constraints": [
    "The input string only contains '0' to '9', '/', '+' and '-'.",
    "Each fraction (input and output) has the format ±numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.",
    "The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.",
    "The number of given fractions will be in the range [1, 10].",
    "The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int."
  ],
  "testCases": [
    {
      "input": "-1/2+1/2",
      "expectedOutput": "0/1"
    },
    {
      "input": "-1/2+1/2+1/3",
      "expectedOutput": "1/3"
    },
    {
      "input": "1/3-1/2",
      "expectedOutput": "-1/6"
    },
    {
      "input": "1/2+1/2",
      "expectedOutput": "1/1"
    },
    {
      "input": "-1/2-1/2",
      "expectedOutput": "-1/1"
    },
    {
      "input": "1/2-1/3+1/4",
      "expectedOutput": "7/12"
    },
    {
      "input": "1/5-2/3+3/7",
      "expectedOutput": "-8/105"
    }
  ],
  "hints": [
    "Parse the input string to extract the numerator and denominator of each fraction.",
    "Perform the addition and subtraction operations on the fractions.",
    "Simplify the final fraction to its irreducible form.",
    "Convert the result to the desired string format.",
    "Handle negative fractions correctly.",
    "Calculate the greatest common divisor (GCD) to simplify the fraction."
  ],
  "tags": ["Math", "String", "Simulation"]
},
{
  "problemId": 8,
  "courseId": "goldmansachs",
  "title": "String Compression",
  "difficulty": "Medium",
  "description": "Given an array of characters chars, compress it using the specified algorithm. The compressed string should be stored in the input array chars. Return the new length of the array.",
  "examples": [
    {
      "input": "chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
      "output": "Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]",
      "explanation": "The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\"."
    },
    {
      "input": "chars = [\"a\"]",
      "output": "Return 1, and the first character of the input array should be: [\"a\"]",
      "explanation": "The only group is \"a\", which remains uncompressed since it's a single character."
    },
    {
      "input": "chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
      "output": "Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].",
      "explanation": "The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\"."
    }
  ],
  "constraints": [
    "1 <= chars.length <= 2000",
    "chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol."
  ],
  "testCases": [
    {
      "input": "[\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
      "expectedOutput": "[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]"
    },
    {
      "input": "[\"a\"]",
      "expectedOutput": "[\"a\"]"
    },
    {
      "input": "[\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
      "expectedOutput": "[\"a\",\"b\",\"1\",\"2\"]"
    },
    {
      "input": "[\"a\",\"b\",\"c\"]",
      "expectedOutput": "[\"a\",\"b\",\"c\"]"
    },
    {
      "input": "[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"]",
      "expectedOutput": "[\"a\",\"1\",\"1\"]"
    },
    {
      "input": "[\"a\",\"b\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\"]",
      "expectedOutput": "[\"a\",\"b\",\"c\",\"1\",\"1\"]"
    }

  ],
  "hints": [
    "Use two pointers: one to read the characters and one to write the compressed characters.",
    "Iterate through the characters array and count the consecutive repeating characters.",
    "When a different character is encountered or the end of the array is reached, write the character and its count (if greater than 1) to the compressed array.",
    "Update the write pointer accordingly.",
    "Return the write pointer as the new length of the compressed array."
  ],
  "tags": ["Two Pointers", "String"]
},
{
  "problemId": 9,
  "courseId": "goldmansachs",
  "title": "Shortest Subarray with Sum at Least K",
  "difficulty": "Hard",
  "description": "Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.",
  "examples": [
    {
      "input": "nums = [1], k = 1",
      "output": "1"
    },
    {
      "input": "nums = [1,2], k = 4",
      "output": "-1"
    },
    {
      "input": "nums = [2,-1,2], k = 3",
      "output": "3"
    }
  ],
  "constraints": [
    "1 <= nums.length <= 10^5",
    "-10^5 <= nums[i] <= 10^5",
    "1 <= k <= 10^9"
  ],
  "testCases": [
    {
      "input": "[1] 1",
      "expectedOutput": "1"
    },
    {
      "input": "[1,2] 4",
      "expectedOutput": "-1"
    },
    {
      "input": "[2,-1,2] 3",
      "expectedOutput": "3"
    },
    {
      "input": "[1,2,3,4,5] 11",
      "expectedOutput": "3"
    },
    {
      "input": "[84,-37,32,40,95] 167",
      "expectedOutput": "3"
    },
    {
      "input": "[1,2,-3,4,5] 7",
      "expectedOutput": "2"
    },
    {
      "input": "[-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1] 1",
      "expectedOutput": "2"
    }
  ],
  "hints": [
    "Use a prefix sum array to efficiently calculate the sum of subarrays.",
    "Use a monotonic queue (deque) to store the indices of the prefix sum array.",
    "Maintain the deque in increasing order of prefix sums.",
    "For each index i, check if the prefix sum at i minus the prefix sum at the front of the deque is greater than or equal to k.",
    "If it is, update the minimum length and remove the front element from the deque.",
    "Also, remove elements from the back of the deque that have prefix sums greater than or equal to the current prefix sum.",
    "Return the minimum length or -1 if no such subarray exists."
  ],
  "tags": ["Array", "Binary Search", "Queue", "Sliding Window", "Heap (Priority Queue)", "Prefix Sum", "Monotonic Queue"]
},
{
  "problemId": 10,
  "courseId": "goldmansachs",
  "title": "Fraction to Recurring Decimal",
  "difficulty": "Medium",
  "description": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.",
  "examples": [
    {
      "input": "numerator = 1, denominator = 2",
      "output": "\"0.5\""
    },
    {
      "input": "numerator = 2, denominator = 1",
      "output": "\"2\""
    },
    {
      "input": "numerator = 4, denominator = 333",
      "output": "\"0.(012)\""
    }
  ],
  "constraints": [
    "-2^31 <= numerator, denominator <= 2^31 - 1",
    "denominator != 0",
    "The length of the answer string is less than 10^4."
  ],
  "testCases": [
    {
      "input": "1 2",
      "expectedOutput": "0.5"
    },
    {
      "input": "2 1",
      "expectedOutput": "2"
    },
    {
      "input": "4 333",
      "expectedOutput": "0.(012)"
    },
    {
      "input": "1 6",
      "expectedOutput": "0.1(6)"
    },
    {
      "input": "-1 2",
      "expectedOutput": "-0.5"
    },
    {
      "input": "1 -2",
      "expectedOutput": "-0.5"
    },
    {
      "input": "-1 -2",
      "expectedOutput": "0.5"
    }
  ],
  "hints": [
    "Handle the sign of the result.",
    "Perform long division to get the integer and fractional parts.",
    "Use a hash map to store the remainders and their positions.",
    "If a remainder repeats, enclose the repeating part in parentheses.",
    "Handle the case where the fractional part terminates.",
    "Handle the case where the numerator is 0."
  ],
  "tags": ["Hash Table", "Math", "String"]
},
{
  "problemId": 11,
  "courseId": "goldmansachs",
  "title": "Remove Comments",
  "difficulty": "Medium",
  "description": "Given a C++ program, remove comments from it. The program source is an array of strings source where source[i] is the ith line of the source code. Return the source code in the same format after removing the comments.",
  "examples": [
    {
      "input": "source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]",
      "output": "[\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]",
      "explanation": "The block comment in the first line and lines 6-9 are removed. The line comment in line 4 is also removed."
    },
    {
      "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
      "output": "[\"ab\"]",
      "explanation": "The block comment spanning multiple lines is removed, and the implicit newline characters are deleted."
    }
  ],
  "constraints": [
    "1 <= source.length <= 100",
    "0 <= source[i].length <= 80",
    "source[i] consists of printable ASCII characters.",
    "Every open block comment is eventually closed.",
    "There are no single-quote or double-quote in the input."
  ],
  "testCases": [
    {
      "input": "[\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]",
      "expectedOutput": "[\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]"
    },
    {
      "input": "[\"a/*comment\", \"line\", \"more_comment*/b\"]",
      "expectedOutput": "[\"ab\"]"
    },
    {
      "input": "[\"//comment\", \"int main()\", \"{ \", \"  int a;\", \"}\"]",
      "expectedOutput": "[\"int main()\",\"{ \",\"  int a;\",\"}\"]"
    },
    {
      "input": "[\"int main()\", \"{ \", \"  /* comment */ int a;\", \"}\"]",
      "expectedOutput": "[\"int main()\",\"{ \",\"  int a;\",\"}\"]"
    },
    {
      "input": "[\"int main()\", \"{ \", \"  /* comment /* nested */ */ int a;\", \"}\"]",
      "expectedOutput": "[\"int main()\",\"{ \",\"  int a;\",\"}\"]"
    },
    {
      "input": "[\"int main()\", \"{ \", \"  /* comment // inside */ int a;\", \"}\"]",
      "expectedOutput": "[\"int main()\",\"{ \",\"  int a;\",\"}\"]"
    },
    {
      "input": "[\"a//b/*c*/d\", \"e/*f//g*/h\", \"i/*j*/k//l\", \"m/*n*/o\"]",
      "expectedOutput": "[\"ad\",\"eh\",\"ik\",\"o\"]"
    }
  ],
  "hints": [
    "Iterate through each line of the source code.",
    "Maintain a boolean flag to track whether you are currently inside a block comment.",
    "For each character in the line, check for the start and end of line comments and block comments.",
    "If a line comment is encountered, ignore the rest of the line.",
    "If a block comment starts, set the flag to true and ignore characters until the end of the block comment.",
    "If a block comment ends, set the flag to false.",
    "Append the characters that are not part of a comment to the result string.",
    "If the result string is not empty, add it to the result list."
  ],
  "tags": ["Array", "String"]
},
{
  "problemId": 12,
  "courseId": "goldmansachs",
  "title": "Product of Array Except Self",
  "difficulty": "Medium",
  "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. You must write an algorithm that runs in O(n) time and without using the division operation.",
  "examples": [
    {
      "input": "nums = [1,2,3,4]",
      "output": "[24,12,8,6]"
    },
    {
      "input": "nums = [-1,1,0,-3,3]",
      "output": "[0,0,9,0,0]"
    }
  ],
  "constraints": [
    "2 <= nums.length <= 10^5",
    "-30 <= nums[i] <= 30",
    "The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer."
  ],
  "testCases": [
    {
      "input": "[1,2,3,4]",
      "expectedOutput": "[24,12,8,6]"
    },
    {
      "input": "[-1,1,0,-3,3]",
      "expectedOutput": "[0,0,9,0,0]"
    },
    {
      "input": "[1,0]",
      "expectedOutput": "[0,1]"
    },
    {
      "input": "[0,0]",
      "expectedOutput": "[0,0]"
    },
    {
      "input": "[1,1,1,1]",
      "expectedOutput": "[1,1,1,1]"
    },
    {
      "input": "[1,2]",
      "expectedOutput": "[2,1]"
    },
    {
      "input": "[-1,1]",
      "expectedOutput": "[1,-1]"
    }
  ],
  "hints": [
    "Create two arrays, left and right, to store the product of elements to the left and right of each element, respectively.",
    "Calculate the left array by iterating from left to right and multiplying the previous element's product.",
    "Calculate the right array by iterating from right to left and multiplying the previous element's product.",
    "Calculate the answer array by multiplying the left and right products for each element.",
    "To solve in O(1) extra space, use the output array to store the left products and then calculate the right products in place."
  ],
  "tags": ["Array", "Prefix Sum"]
},
{
  "problemId": 13,
  "courseId": "goldmansachs",
  "title": "Climbing Stairs",
  "difficulty": "Easy",
  "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
  "examples": [
    {
      "input": "n = 2",
      "output": "2",
      "explanation": "There are two ways to climb to the top: 1. 1 step + 1 step, 2. 2 steps"
    },
    {
      "input": "n = 3",
      "output": "3",
      "explanation": "There are three ways to climb to the top: 1. 1 step + 1 step + 1 step, 2. 1 step + 2 steps, 3. 2 steps + 1 step"
    }
  ],
  "constraints": [
    "1 <= n <= 45"
  ],
  "testCases": [
    {
      "input": "2",
      "expectedOutput": "2"
    },
    {
      "input": "3",
      "expectedOutput": "3"
    },
    {
      "input": "1",
      "expectedOutput": "1"
    },
    {
      "input": "4",
      "expectedOutput": "5"
    },
    {
      "input": "5",
      "expectedOutput": "8"
    },
    {
      "input": "6",
      "expectedOutput": "13"
    },
    {
      "input": "10",
      "expectedOutput": "89"
    }
  ],
  "hints": [
    "To reach the nth step, you could have come from the (n-1)th step or the (n-2)th step.",
    "The number of ways to reach the nth step is the sum of the number of ways to reach the (n-1)th step and the (n-2)th step.",
    "Use dynamic programming or memoization to avoid redundant calculations.",
    "The base cases are n = 1 (1 way) and n = 2 (2 ways)."
  ],
  "tags": ["Math", "Dynamic Programming", "Memoization"]
},
{
  "problemId": 14,
  "courseId": "goldmansachs",
  "title": "Group Anagrams",
  "difficulty": "Medium",
  "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
  "examples": [
    {
      "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
      "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
      "explanation": "There is no string in strs that can be rearranged to form \"bat\". The strings \"nat\" and \"tan\" are anagrams as they can be rearranged to form each other. The strings \"ate\", \"eat\", and \"tea\" are anagrams as they can be rearranged to form each other."
    },
    {
      "input": "strs = [\"\"]",
      "output": "[[\"\"]]"
    },
    {
      "input": "strs = [\"a\"]",
      "output": "[[\"a\"]]"
    }
  ],
  "constraints": [
    "1 <= strs.length <= 10^4",
    "0 <= strs[i].length <= 100",
    "strs[i] consists of lowercase English letters."
  ],
  "testCases": [
    {
      "input": "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
      "expectedOutput": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
    },
    {
      "input": "[\"\"]",
      "expectedOutput": "[[\"\"]]"
    },
    {
      "input": "[\"a\"]",
      "expectedOutput": "[[\"a\"]]"
    },
    {
      "input": "[\"abc\",\"cba\",\"bac\",\"foo\",\"ofo\"]",
      "expectedOutput": "[[\"abc\",\"cba\",\"bac\"],[\"foo\",\"ofo\"]]"
    },
    {
      "input": "[\"listen\",\"silent\",\"triangle\",\"integral\",\"garden\",\"ranged\"]",
      "expectedOutput": "[[\"listen\",\"silent\"],[\"triangle\",\"integral\"],[\"garden\",\"ranged\"]]"
    },
    {
      "input": "[\"ant\",\"tan\",\"act\",\"tac\",\"cat\"]",
      "expectedOutput": "[[\"ant\",\"tan\"],[\"act\",\"tac\",\"cat\"]]"
    },
    {
      "input": "[\"ddddddddddg\",\"ddddddddddt\"]",
      "expectedOutput": "[[\"ddddddddddg\"],[\"ddddddddddt\"]]"
    }
  ],
  "hints": [
    "Use a hash map to group anagrams.",
    "The key of the hash map can be the sorted string or a character count representation of the string.",
    "Iterate through the array of strings and add each string to the corresponding group in the hash map.",
    "Return the values of the hash map as the result."
  ],
  "tags": ["Array", "Hash Table", "String", "Sorting"]
},
{
  "problemId": 15,
  "courseId": "goldmansachs",
  "title": "Reaching Points",
  "difficulty": "Hard",
  "description": "Given four integers sx, sy, tx, and ty, return true if it is possible to convert the point (sx, sy) to the point (tx, ty) through some operations, or false otherwise. The allowed operation on some point (x, y) is to convert it to either (x, x + y) or (x + y, y).",
  "examples": [
    {
      "input": "sx = 1, sy = 1, tx = 3, ty = 5",
      "output": "true",
      "explanation": "One series of moves that transforms the starting point to the target is: (1, 1) -> (1, 2) (1, 2) -> (3, 2) (3, 2) -> (3, 5)"
    },
    {
      "input": "sx = 1, sy = 1, tx = 2, ty = 2",
      "output": "false"
    },
    {
      "input": "sx = 1, sy = 1, tx = 1, ty = 1",
      "output": "true"
    }
  ],
  "constraints": [
    "1 <= sx, sy, tx, ty <= 10^9"
  ],
  "testCases": [
    {
      "input": "1 1 3 5",
      "expectedOutput": "true"
    },
    {
      "input": "1 1 2 2",
      "expectedOutput": "false"
    },
    {
      "input": "1 1 1 1",
      "expectedOutput": "true"
    },
    {
      "input": "1 1 1 1000000000",
      "expectedOutput": "true"
    },
    {
      "input": "1 1 1000000000 1",
      "expectedOutput": "true"
    },
    {
      "input": "1 1 2 1000000000",
      "expectedOutput": "false"
    },
    {
      "input": "1 1000000000 2",
      "expectedOutput": "false"
    }
  ],
  "hints": [
    "Start from the target point (tx, ty) and work backwards towards the starting point (sx, sy).",
    "If tx > ty, then (tx, ty) must have come from (tx - ty, ty). If ty > tx, then (tx, ty) must have come from (tx, ty - tx).",
    "If tx == sx and ty == sy, then return true.",
    "If tx < sx or ty < sy, then return false.",
    "Use the modulo operator to optimize the backward traversal when tx or ty are large."
  ],
  "tags": ["Math"]
},
{
  "problemId": 16,
  "courseId": "goldmansachs",
  "title": "Design HashMap",
  "difficulty": "Easy",
  "description": "Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class with put, get, and remove methods.",
  "examples": [
    {
      "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"] [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
      "output": "[null, null, null, 1, -1, null, 1, null, -1]",
      "explanation": "MyHashMap myHashMap = new MyHashMap(); myHashMap.put(1, 1); myHashMap.put(2, 2); myHashMap.get(1); // return 1 myHashMap.get(3); // return -1 myHashMap.put(2, 1); myHashMap.get(2); // return 1 myHashMap.remove(2); myHashMap.get(2); // return -1"
    }
  ],
  "constraints": [
    "0 <= key, value <= 10^6",
    "At most 10^4 calls will be made to put, get, and remove."
  ],
  "testCases": [
    {
      "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"] [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
      "expectedOutput": "[null, null, null, 1, -1, null, 1, null, -1]"
    },
    {
      "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"remove\", \"get\"] [[], [1, 1], [2, 2], [1], [2], [2]]",
      "expectedOutput": "[null, null, null, 1, null, -1]"
    },
    {
      "input": "[\"MyHashMap\", \"put\", \"get\", \"remove\", \"get\"] [[], [1, 1], [1], [1], [1]]",
      "expectedOutput": "[null, null, 1, null, -1]"
    },
    {
      "input": "[\"MyHashMap\", \"put\", \"put\", \"put\", \"get\", \"get\", \"get\"] [[], [1, 1], [2, 2], [3, 3], [1], [2], [3]]",
      "expectedOutput": "[null, null, null, null, 1, 2, 3]"
    },
    {
      "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"remove\", \"get\", \"put\", \"get\", \"remove\", \"get\"] [[], [1, 1], [2, 2], [1], [1], [1], [1,3],[1],[1],[1]]",
      "expectedOutput": "[null, null, null, 1, null, -1, null, 3, null, -1]"
    },
    {
      "input": "[\"MyHashMap\", \"put\", \"put\", \"put\", \"put\", \"get\", \"get\", \"get\", \"get\", \"remove\", \"remove\", \"get\", \"get\"] [[], [1,1],[2,2],[1000000,1000000],[100,100],[1],[2],[1000000],[100],[1],[1000000],[1],[1000000]]",
      "expectedOutput": "[null, null, null, null, 1, 2, 1000000, 100, null, null, -1, -1]"
    },
    {
      "input": "[\"MyHashMap\",\"put\",\"put\",\"get\",\"get\",\"put\",\"get\",\"remove\",\"get\",\"put\",\"get\",\"remove\",\"get\",\"put\",\"get\",\"remove\",\"get\"] + [[],[1,1],[2,2],[1],[3],[2,1],[2],[2],[2],[100000,100000],[100000],[100000],[100000],[1,1],[1],[1],[1]]",
      "expectedOutput": "[null,null,null,1,-1,null,1,null,-1,null,100000,null,-1,null,1,null,-1]"
    }
  ],
  "hints": [
    "Use an array of linked lists or an array of arrays to store the key-value pairs.",
    "Use a hash function to map the key to an index in the array.",
    "Handle collisions by storing multiple key-value pairs in the same index.",
    "Implement the put, get, and remove methods by traversing the linked list or array at the corresponding index.",
    "Resize the array if the number of key-value pairs becomes too large to maintain good performance."
  ],
  "tags": ["Array", "Hash Table", "Linked List", "Design", "Hash Function"]
},
{
  "problemId": 17,
  "courseId": "goldmansachs",
  "title": "Best Time to Buy and Sell Stock",
  "difficulty": "Easy",
  "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
  "examples": [
    {
      "input": "prices = [7,1,5,3,6,4]\n",
      "output": "5\n",
      "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell."
    },
    {
      "input": "prices = [7,6,4,3,1]\n",
      "output": "0\n",
      "explanation": "In this case, no transactions are done and the max profit = 0."
    }
  ],
  "constraints": [
    "1 <= prices.length <= 10^5",
    "0 <= prices[i] <= 10^4"
  ],
  "testCases": [
    {
      "input": "[7,1,5,3,6,4]\n",
      "expectedOutput": "5\n"
    },
    {
      "input": "[7,6,4,3,1]\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "[2,4,1]\n",
      "expectedOutput": "2\n"
    },
    {
      "input": "[2,1,2,1,0,1,2]\n",
      "expectedOutput": "2\n"
    },
    {
      "input": "[3,3]\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "[1]\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "[1,2,3,4,5,6,7,8,9]\n",
      "expectedOutput": "8\n"
    }
  ],
  "hints": [
    "Use two pointers, one for the buy price and one for the sell price.",
    "Initialize the buy price to the first element of the array and the maximum profit to 0.",
    "Iterate through the array and update the buy price if a lower price is found.",
    "Calculate the profit for each sell price and update the maximum profit if a higher profit is found.",
    "Return the maximum profit."
  ],
  "tags": ["Array", "Dynamic Programming"]
},
{
  "problemId": 18,
  "courseId": "goldmansachs",
  "title": "Robot Bounded In Circle",
  "difficulty": "Medium",
  "description": "On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions: \"G\": go straight 1 unit, \"L\": turn 90 degrees to the left, \"R\": turn 90 degrees to the right. The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.",
  "examples": [
    {
      "input": "instructions = \"GGLLGG\"\n",
      "output": "true\n",
      "explanation": "The robot is initially at (0, 0) facing the north direction. Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (0, 2) --> (0, 1) --> (0, 0). Based on that, we return true."
    },
    {
      "input": "instructions = \"GG\"\n",
      "output": "false\n",
      "explanation": "The robot is initially at (0, 0) facing the north direction. Repeating the instructions, keeps advancing in the north direction and does not go into cycles. Based on that, we return false."
    },
    {
      "input": "instructions = \"GL\"\n",
      "output": "true\n",
      "explanation": "The robot is initially at (0, 0) facing the north direction. Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (-1, 1) --> (-1, 0) --> (0, 0). Based on that, we return true."
    }
  ],
  "constraints": [
    "1 <= instructions.length <= 100",
    "instructions[i] is 'G', 'L' or 'R'."
  ],
  "testCases": [
    {
      "input": "\"GGLLGG\"\n",
      "expectedOutput": "true\n"
    },
    {
      "input": "\"GG\"\n",
      "expectedOutput": "false\n"
    },
    {
      "input": "\"GL\"\n",
      "expectedOutput": "true\n"
    },
    {
      "input": "\"GRGLGRGL\"\n",
      "expectedOutput": "true\n"
    },
    {
      "input": "\"GR\"\n",
      "expectedOutput": "false\n"
    },
    {
      "input": "\"LLG\"\n",
      "expectedOutput": "true\n"
    },
    {
      "input": "\"RRRGG\"\n",
      "expectedOutput": "false\n"
    }
  ],
  "hints": [
    "Simulate the robot's movement and keep track of its position and direction.",
    "If the robot returns to the starting position (0, 0) after one cycle of instructions, it is bounded in a circle.",
    "If the robot does not return to the starting position but changes its direction, it is also bounded in a circle.",
    "If the robot continues to move in the same direction and does not return to the starting position, it is not bounded in a circle.",
    "The robot is bounded in a circle if and only if (looking at the final vector) it changes direction (i.e. doesn't stay pointing north), or it moves 0."
  ],
  "tags": ["Math", "String", "Simulation"]
},
{
  "problemId": 19,
  "courseId": "goldmansachs",
  "title": "Container With Most Water",
  "difficulty": "Medium",
  "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container.",
  "examples": [
    {
      "input": "height = [1,8,6,2,5,4,8,3,7]\n",
      "output": "49\n",
      "explanation": "The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49."
    },
    {
      "input": "height = [1,1]\n",
      "output": "1\n"
    }
  ],
  "constraints": [
    "n == height.length",
    "2 <= n <= 10^5",
    "0 <= height[i] <= 10^4"
  ],
  "testCases": [
    {
      "input": "[1,8,6,2,5,4,8,3,7]\n",
      "expectedOutput": "49\n"
    },
    {
      "input": "[1,1]\n",
      "expectedOutput": "1\n"
    },
    {
      "input": "[4,3,2,1,4]\n",
      "expectedOutput": "16\n"
    },
    {
      "input": "[1,2,1]\n",
      "expectedOutput": "2\n"
    },
    {
      "input": "[1,2,3,4,5,6,7,8,9,10]\n",
      "expectedOutput": "25\n"
    },
    {
      "input": "[10,9,8,7,6,5,4,3,2,1]\n",
      "expectedOutput": "25\n"
    },
    {
      "input": "[2,3,10,5,7,8,9]\n",
      "expectedOutput": "36\n"
    }
  ],
  "hints": [
    "Use two pointers, one at the beginning and one at the end of the array.",
    "Calculate the area formed by the two pointers and update the maximum area.",
    "Move the pointer with the smaller height towards the center.",
    "Repeat until the two pointers meet.",
    "The area is determined by the shorter height multiplied by the distance between the lines."
  ],
  "tags": ["Array", "Two Pointers", "Greedy"]
},
{
  "problemId": 20,
  "courseId": "goldmansachs",
  "title": "Minimum Path Sum",
  "difficulty": "Medium",
  "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time.",
  "examples": [
    {
      "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]\n",
      "output": "7\n",
      "explanation": "Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum."
    },
    {
      "input": "grid = [[1,2,3],[4,5,6]]\n",
      "output": "12\n"
    }
  ],
  "constraints": [
    "m == grid.length",
    "n == grid[i].length",
    "1 <= m, n <= 200",
    "0 <= grid[i][j] <= 200"
  ],
  "testCases": [
    {
      "input": "[[1,3,1],[1,5,1],[4,2,1]]\n",
      "expectedOutput": "7\n"
    },
    {
      "input": "[[1,2,3],[4,5,6]]\n",
      "expectedOutput": "12\n"
    },
    {
      "input": "[[1]]\n",
      "expectedOutput": "1\n"
    },
    {
      "input": "[[1,2],[5,6],[1,1]]\n",
      "expectedOutput": "8\n"
    },
    {
      "input": "[[1,2,3,4],[5,6,7,8]]\n",
      "expectedOutput": "26\n"
    },
    {
      "input": "[[1,2],[1,100]]\n",
      "expectedOutput": "102\n"
    },
    {
      "input": "[[1,100],[1,2]]\n",
      "expectedOutput": "4\n"
    }
  ],
  "hints": [
    "Use dynamic programming to solve this problem.",
    "Create a 2D array dp of the same size as the grid to store the minimum path sums.",
    "Initialize dp[0][0] with grid[0][0].",
    "Calculate the first row and first column of dp by adding the previous cell's value and the current cell's value from the grid.",
    "For the remaining cells, calculate dp[i][j] as the minimum of dp[i-1][j] and dp[i][j-1], plus grid[i][j].",
    "The result is stored in dp[m-1][n-1]."
  ],
  "tags": ["Array", "Dynamic Programming", "Matrix"]
},
{
  "problemId": 21,
  "courseId": "goldmansachs",
  "title": "Taxi Passenger Collection",
  "difficulty": "Hard",
  "description": "A taxi driver needs to pick up passengers and drop them at the railway station (n-1, n-1) and return to the starting point (0, 0). The city map is represented as a square matrix where 0 or positive values are paths, 1 represents a passenger, and -1 represents an obstruction. The taxi can only move right or down towards the railway station and left or up on the return journey. When passing through a cell with a passenger, the passenger is picked up, and the cell becomes a path. The goal is to maximize the number of passengers collected.",
  "examples": [
    {
      "input": "4\n4\n0 0 0 1\n1 0 0 0\n0 0 0 0\n0 0 0 0\n",
      "output": "2\n",
      "explanation": "The driver can collect a maximum of 2 passengers by taking the path (0,0) -> (0,1) -> (0,2) -> (0,3) -> (1,3) -> (2,3) -> (3,3) -> (3,2) -> (3,1) -> (3,0) -> (2,0) -> (1,0) -> (0,0)."
    },
    {
      "input": "3\n3\n0 1 -1\n1 0 -1\n1 1 1\n",
      "output": "5\n",
      "explanation": "The driver can collect a maximum of 5 passengers by taking the path (0,0) -> (0,1) -> (1,1) -> (2,1) -> (2,2) -> (2,1) -> (2,0) -> (1,0) -> (0,0)."
    }
  ],
  "constraints": [
    "1 <= n <= 50",
    "mat[i][j] == -1, 0, or 1"
  ],
  "testCases": [
    {
      "input": "4\n4\n0 0 0 1\n1 0 0 0\n0 0 0 0\n0 0 0 0\n",
      "expectedOutput": "2\n"
    },
    {
      "input": "3\n3\n0 1 -1\n1 0 -1\n1 1 1\n",
      "expectedOutput": "5\n"
    },
    {
      "input": "2\n2\n1 1\n1 1\n",
      "expectedOutput": "3\n"
    },
    {
      "input": "2\n2\n0 0\n0 0\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "3\n3\n0 0 1\n0 0 1\n1 1 0\n",
      "expectedOutput": "3\n"
    },
    {
      "input": "3\n3\n-1 -1 -1\n-1 -1 -1\n-1 -1 -1\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "4\n4\n0 1 0 0\n0 1 0 0\n0 1 0 0\n0 1 0 0\n",
      "expectedOutput": "4\n"
    }
  ],
  "hints": [
    "Use dynamic programming to solve this problem.",
    "Consider the problem as two people moving from (0,0) to (n-1, n-1) simultaneously.",
    "Use a 3D DP array dp[i][j][k] where i and j are the coordinates of the first person, and k is the column of the second person.",
    "Calculate the maximum passengers collected at each state by considering all possible moves.",
    "Handle the case where both people are at the same cell and pick up the passenger only once.",
    "Handle obstructions (-1) appropriately."
  ],
  "tags": ["Dynamic Programming", "Matrix", "Depth-First Search"]
},
{
  "problemId": 22,
  "courseId": "goldmansachs",
  "title": "Maximum Loss in Stock Trading",
  "difficulty": "Easy",
  "description": "Given a list of daily stock prices, find the maximum loss possible by buying a stock on one day and selling it on a later day. Return 0 if no loss is possible.",
  "examples": [
    {
      "input": "Prices = [10, 4, 2, 9]\n",
      "output": "8\n",
      "explanation": "The maximum loss is incurred when buying at 10 and selling at 2. Return 10 - 2 = 8."
    },
    {
      "input": "Price = [1, 2, 3, 4]\n",
      "output": "0\n",
      "explanation": "The price went up every day, so no loss is possible. Return 0."
    }
  ],
  "constraints": [
    "1 <= prices.length <= 10^5",
    "0 <= prices[i] <= 10^4"
  ],
  "testCases": [
    {
      "input": "7\n1\n8\n4\n2\n10\n3\n2\n",
      "expectedOutput": "8\n"
    },
    {
      "input": "4\n10\n4\n2\n9\n",
      "expectedOutput": "8\n"
    },
    {
      "input": "4\n1\n2\n3\n4\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "5\n5\n4\n3\n2\n1\n",
      "expectedOutput": "4\n"
    },
    {
      "input": "6\n1\n2\n3\n1\n2\n3\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "3\n10\n5\n1\n",
      "expectedOutput": "9\n"
    },
    {
      "input": "1\n100\n",
      "expectedOutput": "0\n"
    }
  ],
  "hints": [
    "Iterate through the array and keep track of the maximum price encountered so far.",
    "For each price, calculate the loss if the stock is sold at that price (maximum price - current price).",
    "Update the maximum loss if a larger loss is found.",
    "If the current price is greater than the maximum price, update the maximum price.",
    "Return the maximum loss."
  ],
  "tags": ["Array"]
},
{
  "problemId": 23,
  "courseId": "goldmansachs",
  "title": "Fountain Activation",
  "difficulty": "Medium",
  "description": "Given an array locations[] representing the coverage limit of fountains in a one-dimensional garden, determine the minimum number of fountains that need to be activated to cover the entire garden.",
  "examples": [
    {
      "input": "3\n0 2 1\n",
      "output": "1\n",
      "explanation": "For position 1: range 1 to 1. For position 2: range 1 to 3. For position 3: range 2 to 3. Only the fountain at position 2 needs to be activated."
    },
    {
      "input": "3\n1 1 1\n",
      "output": "1\n",
      "explanation": "For position 1: range 1 to 2. For position 2: range 1 to 3. For position 3: range 2 to 3. Activating the 2nd fountain covers the entire garden."
    }
  ],
  "constraints": [
    "1 <= n <= 10^5",
    "0 <= locations[i] <= min(n, 100)"
  ],
  "testCases": [
    {
      "input": "3\n1 1 1\n",
      "expectedOutput": "1\n"
    },
    {
      "input": "3\n0 2 1\n",
      "expectedOutput": "1\n"
    },
    {
      "input": "4\n1 2 1 1\n",
      "expectedOutput": "1\n"
    },
    {
      "input": "5\n1 1 1 1 1\n",
      "expectedOutput": "2\n"
    },
    {
      "input": "6\n2 1 0 2 1 0\n",
      "expectedOutput": "2\n"
    },
    {
      "input": "1\n0\n",
      "expectedOutput": "1\n"
    },
    {
      "input": "2\n0 0\n",
      "expectedOutput": "2\n"
    }
  ],
  "hints": [
    "Calculate the coverage range for each fountain.",
    "Use an array to store the maximum right coverage for each position.",
    "Iterate through the garden and greedily select the fountain that extends the coverage the farthest.",
    "Keep track of the current coverage and the number of activated fountains.",
    "If the current coverage is less than the garden length, activate the next fountain that extends the coverage the farthest.",
    "Return the number of activated fountains."
  ],
  "tags": ["Greedy", "Array"]
},
{
  "problemId": 24,
  "courseId": "goldmansachs",
  "title": "Job Scheduling for Maximum Earnings",
  "difficulty": "Medium",
  "description": "Given a list of jobs with start time, end time, and profit, find the maximum profit Anirudh can earn and the remaining jobs and earnings for other employees. Anirudh can only perform one job at a time.",
  "examples": [
    {
      "input": "3\n0900\n1030\n100\n1000\n1200\n500\n1100\n1200\n300\n",
      "output": "2\n400\n",
      "explanation": "Anirudh chooses the job with the highest profit (1000-1200, profit 500). The remaining jobs (0900-1030, profit 100 and 1100-1200, profit 300) have a total profit of 400."
    },
    {
      "input": "5\n0805\n0830\n100\n0835\n0900\n100\n0905\n0930\n100\n0935\n1000\n100\n1005\n1030\n100\n",
      "output": "0\n0\n",
      "explanation": "Anirudh can perform all jobs as there are no overlapping jobs. Therefore, no jobs and no earnings are left for other employees."
    }
  ],
  "constraints": [
    "0 <= n <= 10000",
    "start-time < end-time"
  ],
  "testCases": [
    {
      "input": "3\n0900\n1030\n100\n1000\n1200\n500\n1100\n1200\n300\n",
      "expectedOutput": "2\n400\n"
    },
    {
      "input": "5\n0805\n0830\n100\n0835\n0900\n100\n0905\n0930\n100\n0935\n1000\n100\n1005\n1030\n100\n",
      "expectedOutput": "0\n0\n"
    },
    {
      "input": "2\n1000\n1200\n200\n1100\n1300\n100\n",
      "expectedOutput": "1\n100\n"
    },
    {
      "input": "4\n0900\n1000\n100\n1000\n1100\n200\n1100\n1200\n300\n1200\n1300\n400\n",
      "expectedOutput": "0\n0\n"
    },
    {
      "input": "1\n1000\n1200\n500\n",
      "expectedOutput": "0\n0\n"
    },
    {
      "input": "3\n0900\n1000\n100\n1100\n1200\n100\n1300\n1400\n100\n",
      "expectedOutput": "0\n0\n"
    },
    {
      "input": "4\n0900\n1000\n100\n1000\n1100\n200\n1200\n1300\n300\n1300\n1400\n400\n",
      "expectedOutput": "0\n0\n"
    }
  ],
  "hints": [
    "Parse the input to create a list of jobs with start time, end time, and profit.",
    "Sort the jobs in descending order of profit.",
    "Iterate through the sorted jobs and select a job if it does not overlap with previously selected jobs.",
    "Calculate the total profit of the selected jobs and the remaining jobs.",
    "Return the number of remaining jobs and their total profit."
  ],
  "tags": ["Greedy", "Sorting", "Array"]
},
{
  "problemId": 25,
  "courseId": "goldmansachs",
  "title": "Binary Tree S-Expression",
  "difficulty": "Hard",
  "description": "Given a list of node-pair edges representing a binary tree, translate it into its lexicographically smallest S-expression or report any errors that do not conform to the definition of a binary tree.",
  "examples": [
    {
      "input": "(B,D) (D,E) (A,B) (C,F) (E,G) (A,C)\n",
      "output": "A(B(D(E(G))))(C(F)))\n",
      "explanation": "The tree can be represented as A(B(D(E(G))))(C(F)))."
    },
    {
      "input": "(C,E)(D,F)(A,B)(A,C)(B,K)\n",
      "output": "A(B(K))(C(E)))D(F))\n"
    }
  ],
  "constraints": [
    "All node names are single characters in the range ascii[A-Z].",
    "The maximum node count is 26.",
    "There is no specific order to the input (parent, child) pairs."
  ],
  "testCases": [
    {
      "input": "(B,D) (D,E) (A,B) (C,F) (E,G) (A,C)\n",
      "expectedOutput": "A(B(D(E(G))))(C(F)))\n"
    },
    {
      "input": "(C,E)(D,F)(A,B)(A,C)(B,K)\n",
      "expectedOutput": "A(B(K))(C(E)))D(F))\n"
    },
    {
      "input": "(P,Q)(P,R)(Q,T)(R,W)(U,V)(Q,S)(R,U)(U,Z)(S,I)(W,Y)\n",
      "expectedOutput": "P(Q(S(I))(T))(R(U(V)(Z))(W(Y))))\n"
    },
    {
      "input": "(A,B)(A,C)(B,D)(C,E)(D,F)(E,G)(F,H)(G,I)(H,J)\n",
      "expectedOutput": "A(B(D(F(H(J)))))(C(E(G(I)))))\n"
    },
    {
      "input": "(A,B)(A,C)(B,D)(B,E)(C,F)(C,G)\n",
      "expectedOutput": "A(B(D)(E))(C(F)(G)))\n"
    },
    {
      "input": "(A,B)(A,C)(B,D)(B,E)(C,F)(C,G)(D,H)(E,I)(F,J)(G,K)\n",
      "expectedOutput": "A(B(D(H))(E(I)))(C(F(J))(G(K))))\n"
    },
    {
      "input": "(A,B)(A,C)(B,D)(B,E)(C,F)(C,G)(D,H)(E,I)(F,J)(G,K)(H,L)(I,M)(J,N)(K,O)\n",
      "expectedOutput": "A(B(D(H(L)))(E(I(M))))(C(F(J(N)))(G(K(O)))))\n"
    },
    {
      "input": "(A,B)(A,C)(B,D)(B,E)(C,F)(C,G)(D,H)(E,I)(F,J)(G,K)(H,L)(I,M)(J,N)(K,O)(L,P)(M,Q)(N,R)(O,S)(P,T)(Q,U)(R,V)(S,W)(T,X)(U,Y)(V,Z)\n",
      "expectedOutput": "A(B(D(H(L(P(T(X))))))(E(I(M(Q(U(Y))))))))(C(F(J(N(R(V(Z))))))(G(K(O(W))))))\n"
    }
  ],
  "hints": [
    "Parse the input to create a graph representation of the tree.",
    "Check for errors: more than 2 children, duplicate edges, cycles, and multiple roots.",
    "Find the root node(s) of the tree.",
    "If there are multiple roots, report Code Stopped4.",
    "Use a recursive function to build the S-expression.",
    "Sort the children of each node lexicographically.",
    "Return the S-expression or the error code."
  ],
  "tags": ["Graph", "Tree", "String", "Recursion"]
},
{
  "problemId": 26,
  "courseId": "goldmansachs",
  "title": "Taxi to Airport",
  "difficulty": "Medium",
  "description": "Ajay needs to reach the airport at (n-1, m-1) from (0, 0) in a 2D grid within k minutes. The grid contains blocked ('#') and unblocked ('.') cells. The taxi can move to adjacent cells in 1 second. Determine if the taxi can reach the airport within k seconds.",
  "examples": [
    {
      "input": "3\n..##\n#.##\n#...\n5\n",
      "output": "Yes\n",
      "explanation": "It takes 5 seconds to reach the airport. If k >= 5, return 'Yes'."
    },
    {
      "input": "2\n..\n..\n3\n",
      "output": "Yes\n",
      "explanation": "The taxi can reach the airport in 2 seconds. If k >= 2, return 'Yes'."
    }
  ],
  "constraints": [
    "1 <= rows <= 500",
    "0 <= maxTime <= 10^6"
  ],
  "testCases": [
    {
      "input": "2\n..\n..\n3\n",
      "expectedOutput": "Yes\n"
    },
    {
      "input": "3\n..##\n#.##\n#...\n5\n",
      "expectedOutput": "Yes\n"
    },
    {
      "input": "3\n..##\n#.##\n#...\n4\n",
      "expectedOutput": "No\n"
    },
    {
      "input": "4\n....\n....\n....\n....\n6\n",
      "expectedOutput": "Yes\n"
    },
    {
      "input": "4\n....\n....\n....\n....\n5\n",
      "expectedOutput": "No\n"
    },
    {
      "input": "5\n.....\n.....\n.....\n.....\n.....\n8\n",
      "expectedOutput": "Yes\n"
    },
    {
      "input": "5\n.....\n.....\n.....\n.....\n.....\n7\n",
      "expectedOutput": "No\n"
    }
  ],
  "hints": [
    "Use Breadth-First Search (BFS) to find the shortest path from (0, 0) to (n-1, m-1).",
    "Maintain a queue to store the cells to be visited.",
    "Keep track of the time taken to reach each cell.",
    "If the airport is reached within k seconds, return 'Yes'; otherwise, return 'No'."
  ],
  "tags": ["Breadth-First Search", "Graph", "Matrix"]
},
{
  "problemId": 27,
  "courseId": "goldmansachs",
  "title": "TV Channel Navigation",
  "difficulty": "Medium",
  "description": "Sahil wants to watch a list of channels on TV. Given the lowest channel, highest channel, blocked channels, and the list of channels to view, find the minimum number of clicks required to navigate through all the channels.",
  "examples": [
    {
      "input": "1\n20\n2\n18\n19\n5\n15\n14\n17\n1\n17\n",
      "output": "7\n",
      "explanation": "Start at channel 1, press 'Up Channel' 13 times to reach 14, press 'Up Channel' to reach 15, press 'Up Channel' twice to reach 17, and then press 'Number 1' and 'Number 7' to reach 17. Total clicks: 13+1+2+2 = 18. However the optimal one is: press 'Up Channel' 13 times to reach 14, press 'Up Channel' to reach 15, press 'Up Channel' twice to reach 17, and then stay. It takes 13+1+2+0=16 clicks. But the optimal one is to type 15,14,17,1 and 17. Which takes 2+2+2+1+2=9. The optimal clicks are 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). total is 2+1+13+1+2=19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). total is 2+1+13+1+2=19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). total is 2+1+13+1+2=19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). total is 2+1+13+1+2=19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). total is 2+1+13+1+2=19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). total is 2+1+13+1+2=19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). total is 2+1+13+1+2=19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). total is 2+1+13+1+2=19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). total is 2+1+13+1+2=19. Optimal: 1 -> 17 (2 clicks), 17 -> 1 (1 click), 1 -> 14 (13 clicks), 14 -> 15 (1 click), 15 -> 17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19. Optimal is 1->17 (2 clicks), 17->1 (1 click), 1->14 (13 clicks), 14->15 (1 click), 15->17 (2 clicks). Total clicks: 2+1+13+1+2 = 19."
    }
  ],
  "constraints": [
    "1 <= lowestChannel <= 10000",
    "lowestChannel <= highestChannel <= 10000",
    "0 <= blockedChannels.length <= 40",
    "1 <= channelsToView.length <= 50"
  ],
  "testCases": [
    {
      "input": "1\n20\n2\n18\n19\n5\n15\n14\n17\n1\n17\n",
      "expectedOutput": "7\n"
    },
    {
      "input": "1\n10\n0\n3\n1\n5\n10\n",
      "expectedOutput": "9\n"
    },
    {
      "input": "1\n10\n1\n5\n3\n1\n5\n10\n",
      "expectedOutput": "9\n"
    },
    {
      "input": "1\n10\n2\n5\n6\n3\n1\n5\n10\n",
      "expectedOutput": "9\n"
    },
    {
      "input": "1\n10\n3\n5\n6\n7\n3\n1\n5\n10\n",
      "expectedOutput": "9\n"
    },
    {
      "input": "1\n10\n0\n1\n1\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "1\n10\n0\n2\n1\n10\n",
      "expectedOutput": "9\n"
    }
  ],
  "hints": [
    "Simulate the TV remote's behavior.",
    "Keep track of the current channel.",
    "For each channel to view, calculate the minimum number of clicks required to reach it from the current channel.",
    "Consider the 'Up Channel', 'Down Channel', and number buttons.",
    "Update the current channel and the total number of clicks.",
    "Return the total number of clicks."
  ],
  "tags": ["Simulation", "Greedy"]
},
{
  "problemId": 28,
  "courseId": "goldmansachs",
  "title": "Minimum Moves to Equal Array Elements",
  "difficulty": "Easy",
  "description": "Given an array of integers, determine the minimum number of moves to make all elements equal. Each move consists of choosing all but 1 element and incrementing their values by 1.",
  "examples": [
    {
      "input": "5\n3\n4\n6\n6\n3\n",
      "output": "7\n",
      "explanation": "It takes 7 moves to make all elements equal."
    },
    {
      "input": "4\n4\n3\n4\n2\n",
      "output": "2\n"
    }
  ],
  "constraints": [
    "1 <= n <= 10^5",
    "1 <= numbers[i] <= 10^6"
  ],
  "testCases": [
    {
      "input": "5\n3\n4\n6\n6\n3\n",
      "expectedOutput": "7\n"
    },
    {
      "input": "4\n4\n3\n4\n2\n",
      "expectedOutput": "2\n"
    },
    {
      "input": "1\n10\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "3\n1\n2\n3\n",
      "expectedOutput": "3\n"
    },
    {
      "input": "6\n1\n2\n3\n4\n5\n6\n",
      "expectedOutput": "15\n"
    },
    {
      "input": "2\n100\n100\n",
      "expectedOutput": "0\n"
    },
    {
      "input": "7\n1\n1\n1\n2\n2\n2\n3\n",
      "expectedOutput": "6\n"
    }
  ],
  "hints": [
    "The number of moves is equal to the sum of the differences between each element and the minimum element in the array.",
    "Find the minimum element in the array.",
    "Calculate the sum of the differences between each element and the minimum element.",
    "Return the sum."
  ],
  "tags": ["Array", "Math"]
},
{
  "problemId": 29,
  "courseId": "goldmansachs",
  "title": "Largest Repackaged Packet",
  "difficulty": "Medium",
  "description": "Given a stream of n data packets, repackage them into the largest possible 2^n units and find the size of the largest repackaged packet.",
  "examples": [
    {
      "input": "5\n12\n25\n10\n7\n8\n",
      "output": "16\n",
      "explanation": "The largest repackaged packet size is 16."
    }
  ],
  "constraints": [
    "1 <= n <= 10^5",
    "1 <= arrivingPackets[i] <= 10^9"
  ],
  "testCases": [
    {
      "input": "5\n12\n25\n10\n7\n8\n",
      "expectedOutput": "16\n"
    },
    {
      "input": "3\n1\n2\n3\n",
      "expectedOutput": "2\n"
    },
    {
      "input": "4\n100\n1000\n10000\n100000\n",
      "expectedOutput": "65536\n"
    },
    {
      "input": "6\n1\n1\n1\n1\n1\n1\n",
      "expectedOutput": "1\n"
    },
    {
      "input": "2\n1000000000\n1\n",
      "expectedOutput": "536870912\n"
    },
    {
      "input": "1\n1000000000\n",
      "expectedOutput": "536870912\n"
    },
    {
      "input": "7\n1\n2\n4\n8\n16\n32\n64\n",
      "expectedOutput": "64\n"
    }
  ],
  "hints": [
    "Iterate through the arriving packets.",
    "For each packet, calculate the largest 2^n that is less than or equal to the packet size.",
    "Keep track of the maximum repackaged packet size.",
    "Add the remaining portion of the packet to the next arriving packet.",
    "Return the maximum repackaged packet size."
  ],
  "tags": ["Array", "Math"]
},
{
  "problemId": 30,
  "courseId": "goldmansachs",
  "title": "Trapezium Pattern",
  "difficulty": "Easy",
  "description": "Given an integer N, print a trapezium pattern using stars and dots as shown in the example.",
  "examples": [
    {
      "input": "3\n",
      "output": "**.**\n*...*\n.....\n*...*\n**.**\n"
    }
  ],
  "constraints": [
    "1 <= N <= 100"
  ],
  "testCases": [
    {
      "input": "3\n",
      "expectedOutput": "**.**\n*...*\n.....\n*...*\n**.**\n"
    },
    {
      "input": "1\n",
      "expectedOutput": "**\n..\n**\n"
    },
    {
      "input": "2\n",
      "expectedOutput": "**.*\n....\n*..*\n**.*\n"
    },
    {
      "input": "4\n",
      "expectedOutput": "**.***\n*.....*\n.......\n*.....*\n**.***\n"
    },
    {
      "input": "5\n",
      "expectedOutput": "**.****\n*......*\n........\n*......*\n**.****\n"
    },
    {
      "input": "6\n",
      "expectedOutput": "**.*****\n*.......*\n.........\n*.......*\n**.*****\n"
    },
    {
      "input": "7\n",
      "expectedOutput": "**.******\n*........*\n..........\n*........*\n**.******\n"
    }
  ],
  "hints": [
    "The pattern has 2*N - 1 rows.",
    "The first and last rows have N stars and N-1 dots in between.",
    "The second and second last rows have 1 star, 2*N - 3 dots, and 1 star.",
    "The middle row has 2*N - 1 dots.",
    "Use nested loops to print the pattern."
  ],
  "tags": ["Pattern", "Loops"]
}
]


