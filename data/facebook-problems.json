[
{
    "problemId": 1,
    "courseId": "facebook",
    "title": "Remove Invalid Parentheses",
    "difficulty": "Hard",
    "description": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\nReturn a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.",
    "examples": [
      {
        "input": "s = \"()())()\"\n",
        "output": "[\"(())()\",\"()()()\"]\n"
      },
      {
        "input": "s = \"(a)())()\"\n",
        "output": "[\"(a())()\",\"(a)()()\"]\n"
      },
      {
        "input": "s = \")(\"\n",
        "output": "[\"\"]\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 25",
      "s consists of lowercase English letters and parentheses '(' and ')'.",
      "There will be at most 20 parentheses in s."
    ],
    "testCases": [
      {
        "input": "s = \"()())()\"\n",
        "expectedOutput": "[\"(())()\",\"()()()\"]\n"
      },
      {
        "input": "s = \"(a)())()\"\n",
        "expectedOutput": "[\"(a())()\",\"(a)()()\"]\n"
      },
      {
        "input": "s = \")(\"\n",
        "expectedOutput": "[\"\"]\n"
      },
      {
        "input": "s = \"(()\"\n",
        "expectedOutput": "[\"()\"]\n",
        "isHidden": true
      },
      {
        "input": "s = \"(r(()())(f)\"\n",
        "expectedOutput": "[\"(r()())(f)\",\"(r(())()f)\",\"(r()()f)\"]\n",
        "isHidden": true
      },
      {
        "input": "s = \"()(((((()\"\n",
        "expectedOutput": "[\"()\"]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Since we do not know which brackets can be removed, we try all the options! We can use recursion.",
      "In the recursion, for each bracket, we can either use it or remove it.",
      "Recursion will generate all the valid parentheses strings but we want the ones with the least number of parentheses deleted.",
      "We can count the number of invalid brackets to be deleted and only generate the valid strings in the recusrion."
    ],
    "tags": ["String", "Backtracking", "Breadth-First Search"]
  },
  {
    "problemId": 2,
    "courseId": "facebook",
    "title": "Verifying an Alien Dictionary",
    "difficulty": "Easy",
    "description": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.",
    "examples": [
      {
        "input": "words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\n",
        "output": "true\n",
        "explanation": "As 'h' comes before 'l' in this language, then the sequence is sorted.\n"
      },
      {
        "input": "words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\n",
        "output": "false\n",
        "explanation": "As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.\n"
      },
      {
        "input": "words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\n",
        "output": "false\n",
        "explanation": "The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (More info).\n"
      }
    ],
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 20",
      "order.length == 26",
      "All characters in words[i] and order are English lowercase letters."
    ],
    "testCases": [
      {
        "input": "words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "words = [\"kuvp\",\"q\"], order = \"ngxlkthsjuoqcpavbfdermiywz\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "words = [\"fxlam\",\"xegd\",\"khm\"], order = \"ybxaekqcjdmtnfszwvuhpiglor\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "words = [\"z\",\"x\",\"z\"], order = \"zyxwvutsrqponmlkjihgfedcba\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Create a mapping from characters to their order in the alien alphabet.",
      "Compare each pair of words lexicographically based on the alien order."
    ],
    "tags": ["Array", "Hash Table", "String"]
  },
  {
    "problemId": 3,
    "courseId": "facebook",
    "title": "Regular Expression Matching",
    "difficulty": "Hard",
    "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '' where:\n'.' Matches any single character.\n'' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).",
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"\n",
        "output": "false\n",
        "explanation": "\"a\" does not match the entire string \"aa\".\n"
      },
      {
        "input": "s = \"aa\", p = \"a*\"\n",
        "output": "true\n",
        "explanation": "'*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n"
      },
      {
        "input": "s = \"ab\", p = \".*\"\n",
        "output": "true\n",
        "explanation": "\".\" means \"zero or more () of any character (.)\".\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 20",
      "s contains only lowercase English letters.",
      "p contains only lowercase English letters, '.', and '*'.",
      "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
    ],
    "testCases": [
      {
        "input": "s = \"aa\", p = \"a\"\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "s = \"aa\", p = \"a*\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "s = \"ab\", p = \".*\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "s = \"aab\", p = \"c*a*b\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "s = \"mississippi\", p = \"mis*is*p*.\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "s = \"aaa\", p = \"a*a\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use dynamic programming or recursion to solve this problem.",
      "Create a 2D table dp where dp[i][j] represents whether the first i characters of s match the first j characters of p.",
      "Handle the base cases: dp[0][0] = true, dp[i][0] = false, dp[0][j] depends on p[j-1] being '*'.",
      "For other cells, consider the cases when p[j-1] is '.', a lowercase letter, or '*'.",
      "When p[j-1] is '*', consider the cases when the preceding element matches zero or more times."
    ],
    "tags": ["String", "Dynamic Programming", "Recursion"]
  },
  {
    "problemId": 4,
    "courseId": "facebook",
    "title": "Product of Array Except Self",
    "difficulty": "Medium",
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\n\nFollow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)",
    "examples": [
      {
        "input": "nums = [1,2,3,4]\n",
        "output": "[24,12,8,6]\n"
      },
      {
        "input": "nums = [-1,1,0,-3,3]\n",
        "output": "[0,0,9,0,0]\n"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 105",
      "-30 <= nums[i] <= 30",
      "The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer."
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3,4]\n",
        "expectedOutput": "[24,12,8,6]\n"
      },
      {
        "input": "nums = [-1,1,0,-3,3]\n",
        "expectedOutput": "[0,0,9,0,0]\n"
      },
      {
        "input": "nums = [0,0]\n",
        "expectedOutput": "[0,0]\n",
        "isHidden": true
      },
      {
        "input": "nums = [1,0]\n",
        "expectedOutput": "[0,1]\n",
        "isHidden": true
      },
      {
        "input": "nums = [1,2]\n",
        "expectedOutput": "[2,1]\n",
        "isHidden": true
      },
      {
        "input": "nums = [1,2,3,4,5]\n",
        "expectedOutput": "[120,60,40,30,24]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Think how you can efficiently utilize prefix and suffix products to calculate the product of all elements except self for each index. Can you pre-compute the prefix and suffix products in linear time to avoid redundant calculations?",
      "Can you minimize additional space usage by reusing memory or modifying the input array to store intermediate results?"
    ],
    "tags": ["Array", "Prefix Sum"]
  },
  {
    "problemId": 5,
    "courseId": "facebook",
    "title": "Valid Palindrome II",
    "difficulty": "Easy",
    "description": "Given a string s, return true if the s can be palindrome after deleting at most one character from it.",
    "examples": [
      {
        "input": "s = \"aba\"\n",
        "output": "true\n"
      },
      {
        "input": "s = \"abca\"\n",
        "output": "true\n",
        "explanation": "You could delete the character 'c'.\n"
      },
      {
        "input": "s = \"abc\"\n",
        "output": "false\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 105",
      "s consists of lowercase English letters."
    ],
    "testCases": [
      {
        "input": "s = \"aba\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "s = \"abca\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "s = \"abc\"\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "s = \"deeee\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "s = \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "s = \"ebcbbececabbacecbbcbe\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use two pointers to scan from two ends to the middle.",
      "If the characters at the two pointers are the same, move the two pointers to the next characters.",
      "If the characters at the two pointers are different, you have two choices: try to skip the left character or skip the right character.",
      "Check if the remaining substring is a palindrome."
    ],
    "tags": ["Two Pointers", "String", "Greedy"]
  },
  {
    "problemId": 6,
    "courseId": "facebook",
    "title": "3Sum",
    "difficulty": "Medium",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]\n",
        "output": "[[-1,-1,2],[-1,0,1]]\n",
        "explanation": "nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n"
      },
      {
        "input": "nums = [0,1,1]\n",
        "output": "[]\n",
        "explanation": "The only possible triplet does not sum up to 0.\n"
      },
      {
        "input": "nums = [0,0,0]\n",
        "output": "[[0,0,0]]\n",
        "explanation": "The only possible triplet sums up to 0.\n"
      }
    ],
    "constraints": [
      "3 <= nums.length <= 3000",
      "-105 <= nums[i] <= 105"
    ],
    "testCases": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]\n",
        "expectedOutput": "[[-1,-1,2],[-1,0,1]]\n"
      },
      {
        "input": "nums = [0,1,1]\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "nums = [0,0,0]\n",
        "expectedOutput": "[[0,0,0]]\n"
      },
      {
        "input": "nums = [0,0,0,0]\n",
        "expectedOutput": "[[0,0,0]]\n",
        "isHidden": true
      },
      {
        "input": "nums = [-2,0,1,1,2]\n",
        "expectedOutput": "[[-2,0,2],[-2,1,1]]\n",
        "isHidden": true
      },
      {
        "input": "nums = [-1,0,1,2,-1,-4,-2,-3,3,0,4]\n",
        "expectedOutput": "[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!",
      "For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
      "The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
    ],
    "tags": ["Array", "Two Pointers", "Sorting"]
  },
  {
    "problemId": 7,
    "courseId": "facebook",
    "title": "Subarray Sum Equals K",
    "difficulty": "Medium",
    "description": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\nA subarray is a contiguous non-empty sequence of elements within an array.",
    "examples": [
      {
        "input": "nums = [1,1,1], k = 2\n",
        "output": "2\n"
      },
      {
        "input": "nums = [1,2,3], k = 3\n",
        "output": "2\n"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 2 * 104",
      "-1000 <= nums[i] <= 1000",
      "-107 <= k <= 107"
    ],
    "testCases": [
      {
        "input": "nums = [1,1,1], k = 2\n",
        "expectedOutput": "2\n"
      },
      {
        "input": "nums = [1,2,3], k = 3\n",
        "expectedOutput": "2\n"
      },
      {
        "input": "nums = [1], k = 1\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "nums = [1,2,3,4], k = 6\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "nums = [-1,-1,1], k = 0\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "nums = [1,-1,0], k = 0\n",
        "expectedOutput": "3\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Will Brute force work here? Try to optimize it.",
      "Can we optimize it by using some extra space?",
      "What about storing sum frequencies in a hash table? Will it be useful?",
      "sum(i,j)=sum(0,j)-sum(0,i), where sum(i,j) represents the sum of all the elements from index i to j-1. Can we use this property to optimize it."
    ],
    "tags": ["Array", "Hash Table", "Prefix Sum"]
  },
  {
    "problemId": 8,
    "courseId": "facebook",
    "title": "First Bad Version",
    "difficulty": "Easy",
    "description": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.",
    "examples": [
      {
        "input": "n = 5, bad = 4\n",
        "output": "4\n",
        "explanation": "call isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\n"
      },
      {
        "input": "n = 1, bad = 1\n",
        "output": "1\n"
      }
    ],
    "constraints": [
      "1 <= bad <= n <= 231 - 1"
    ],
    "testCases": [
      {
        "input": "n = 5, bad = 4\n",
        "expectedOutput": "4\n"
      },
      {
        "input": "n = 1, bad = 1\n",
        "expectedOutput": "1\n"
      },
      {
        "input": "n = 2, bad = 1\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "n = 2, bad = 2\n",
        "expectedOutput": "2\n",
        "isHidden": true
      },
      {
        "input": "n = 10, bad = 6\n",
        "expectedOutput": "6\n",
        "isHidden": true
      },
      {
        "input": "n = 2147483647, bad = 1702766719\n",
        "expectedOutput": "1702766719\n",
        "isHidden": true
      }
    ],
    "hints": [
      "You are looking for the first bad version, which means all the versions after it are also bad.",
      "So we can use a binary search to find the first bad version.",
      "We can start with the middle version and check if it is bad. If it is bad, then the first bad version must be in the left half. If it is not bad, then the first bad version must be in the right half."
    ],
    "tags": ["Binary Search", "Interactive"]
  },
  {
    "problemId": 9,
    "courseId": "facebook",
    "title": "Minimum Window Substring",
    "difficulty": "Hard",
    "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\nThe testcases will be generated such that the answer is unique.\n\nFollow up: Could you find an algorithm that runs in O(m + n) time?",
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"\n",
        "output": "\"BANC\"\n",
        "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n"
      },
      {
        "input": "s = \"a\", t = \"a\"\n",
        "output": "\"a\"\n",
        "explanation": "The entire string s is the minimum window.\n"
      },
      {
        "input": "s = \"a\", t = \"aa\"\n",
        "output": "\"\"\n",
        "explanation": "Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n"
      }
    ],
    "constraints": [
      "m == s.length",
      "n == t.length",
      "1 <= m, n <= 105",
      "s and t consist of uppercase and lowercase English letters."
    ],
    "testCases": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"\n",
        "expectedOutput": "\"BANC\"\n"
      },
      {
        "input": "s = \"a\", t = \"a\"\n",
        "expectedOutput": "\"a\"\n"
      },
      {
        "input": "s = \"a\", t = \"aa\"\n",
        "expectedOutput": "\"\"\n"
      },
      {
        "input": "s = \"aa\", t = \"aa\"\n",
        "expectedOutput": "\"aa\"\n",
        "isHidden": true
      },
      {
        "input": "s = \"bba\", t = \"ab\"\n",
        "expectedOutput": "\"ba\"\n",
        "isHidden": true
      },
      {
        "input": "s = \"abcabdebac\", t = \"cba\"\n",
        "expectedOutput": "\"cba\"\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use two pointers to create a window of letters in s, which would have all the characters from t.",
      "Expand the right pointer until all the characters of t are covered.",
      "Once all the characters are covered, move the left pointer and ensure that all the characters are still covered to minimize the subarray size.",
      "Continue expanding the right and left pointers until you reach the end of s."
    ],
    "tags": ["Hash Table", "String", "Sliding Window"]
  },
  {
    "problemId": 10,
    "courseId": "facebook",
    "title": "K Closest Points to Origin",
    "difficulty": "Medium",
    "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).",
    "examples": [
      {
        "input": "points = [[1,3],[-2,2]], k = 1\n",
        "output": "[[-2,2]]\n",
        "explanation": "The distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n"
      },
      {
        "input": "points = [[3,3],[5,-1],[-2,4]], k = 2\n",
        "output": "[[3,3],[-2,4]]\n",
        "explanation": "The answer [[-2,4],[3,3]] would also be accepted.\n"
      }
    ],
    "constraints": [
      "1 <= k <= points.length <= 104",
      "-104 <= xi, yi <= 104"
    ],
    "testCases": [
      {
        "input": "points = [[1,3],[-2,2]], k = 1\n",
        "expectedOutput": "[[-2,2]]\n"
      },
      {
        "input": "points = [[3,3],[5,-1],[-2,4]], k = 2\n",
        "expectedOutput": "[[3,3],[-2,4]]\n"
      },
      {
        "input": "points = [[0,1],[1,0]], k = 2\n",
        "expectedOutput": "[[0,1],[1,0]]\n",
        "isHidden": true
      },
      {
        "input": "points = [[1,0],[0,1]], k = 1\n",
        "expectedOutput": "[[1,0]]\n",
        "isHidden": true
      },
      {
        "input": "points = [[-2,1],[1,1]], k = 2\n",
        "expectedOutput": "[[-2,1],[1,1]]\n",
        "isHidden": true
      },
      {
        "input": "points = [[1,3],[-2,2],[2,-2]], k = 2\n",
        "expectedOutput": "[[-2,2],[2,-2]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Calculate the Euclidean distance for each point from the origin.",
      "Use a data structure like a min-heap (priority queue) to keep track of the k closest points.",
      "Alternatively, you can sort the points based on their distance from the origin and return the first k points.",
      "Quickselect is also a viable option and can provide an average time complexity of O(n)."
    ],
    "tags": ["Array", "Math", "Divide and Conquer", "Geometry", "Sorting", "Heap (Priority Queue)", "Quickselect"]
  },
  {
    "problemId": 11,
    "courseId": "facebook",
    "title": "Add Binary",
    "difficulty": "Easy",
    "description": "Given two binary strings a and b, return their sum as a binary string.",
    "examples": [
      {
        "input": "a = \"11\", b = \"1\"\n",
        "output": "\"100\"\n"
      },
      {
        "input": "a = \"1010\", b = \"1011\"\n",
        "output": "\"10101\"\n"
      }
    ],
    "constraints": [
      "1 <= a.length, b.length <= 104",
      "a and b consist only of '0' or '1' characters.",
      "Each string does not contain leading zeros except for the zero itself."
    ],
    "testCases": [
      {
        "input": "a = \"11\", b = \"1\"\n",
        "expectedOutput": "\"100\"\n"
      },
      {
        "input": "a = \"1010\", b = \"1011\"\n",
        "expectedOutput": "\"10101\"\n"
      },
      {
        "input": "a = \"0\", b = \"0\"\n",
        "expectedOutput": "\"0\"\n",
        "isHidden": true
      },
      {
        "input": "a = \"1\", b = \"1\"\n",
        "expectedOutput": "\"10\"\n",
        "isHidden": true
      },
      {
        "input": "a = \"10\", b = \"11\"\n",
        "expectedOutput": "\"101\"\n",
        "isHidden": true
      },
      {
        "input": "a = \"1111\", b = \"1111\"\n",
        "expectedOutput": "\"11110\"\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Start from the least significant bits of both strings.",
      "Perform binary addition bit by bit, keeping track of the carry.",
      "Append the result to a string builder or a list.",
      "Reverse the result to get the final binary string."
    ],
    "tags": ["Math", "String", "Bit Manipulation", "Simulation"]
  },
  {
    "problemId": 12,
    "courseId": "facebook",
    "title": "Move Zeroes",
    "difficulty": "Easy",
    "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\n\nFollow up: Could you minimize the total number of operations done?",
    "examples": [
      {
        "input": "nums = [0,1,0,3,12]\n",
        "output": "[1,3,12,0,0]\n"
      },
      {
        "input": "nums = [0]\n",
        "output": "[0]\n"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 104",
      "-231 <= nums[i] <= 231 - 1"
    ],
    "testCases": [
      {
        "input": "nums = [0,1,0,3,12]\n",
        "expectedOutput": "[1,3,12,0,0]\n"
      },
      {
        "input": "nums = [0]\n",
        "expectedOutput": "[0]\n"
      },
      {
        "input": "nums = [1,0,1]\n",
        "expectedOutput": "[1,1,0]\n",
        "isHidden": true
      },
      {
        "input": "nums = [0,0,1]\n",
        "expectedOutput": "[1,0,0]\n",
        "isHidden": true
      },
      {
        "input": "nums = [1,2,3,4,5]\n",
        "expectedOutput": "[1,2,3,4,5]\n",
        "isHidden": true
      },
      {
        "input": "nums = [0,0,0,0,0]\n",
        "expectedOutput": "[0,0,0,0,0]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "In-place means we should not be allocating any space for extra array. But we are allowed to modify the existing array. However, as a first step, try coming up with a solution that makes use of additional space. For this problem as well, first apply the idea discussed using an additional array and the in-place solution will pop up eventually.",
      "A two-pointer approach could be helpful here. The idea would be to have one pointer for iterating the array and another pointer that just works on the non-zero elements of the array."
    ],
    "tags": ["Array", "Two Pointers"]
  },
  {
    "problemId": 13,
    "courseId": "facebook",
    "title": "Minimum Remove to Make Valid Parentheses",
    "difficulty": "Medium",
    "description": "Given a string s of '(' , ')' and lowercase English characters.\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\nFormally, a parentheses string is valid if and only if:\nIt is the empty string, contains only lowercase characters, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.",
    "examples": [
      {
        "input": "s = \"lee(t(c)o)de)\"\n",
        "output": "\"lee(t(c)o)de\"\n",
        "explanation": "\"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n"
      },
      {
        "input": "s = \"a)b(c)d\"\n",
        "output": "\"ab(c)d\"\n"
      },
      {
        "input": "s = \"))((\"\n",
        "output": "\"\"\n",
        "explanation": "An empty string is also valid.\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 105",
      "s[i] is either '(' , ')', or lowercase English letter."
    ],
    "testCases": [
      {
        "input": "s = \"lee(t(c)o)de)\"\n",
        "expectedOutput": "\"lee(t(c)o)de\"\n"
      },
      {
        "input": "s = \"a)b(c)d\"\n",
        "expectedOutput": "\"ab(c)d\"\n"
      },
      {
        "input": "s = \"))((\"\n",
        "expectedOutput": "\"\"\n"
      },
      {
        "input": "s = \"(a(b(c)d)\"\n",
        "expectedOutput": "\"(a(bc)d)\"\n",
        "isHidden": true
      },
      {
        "input": "s = \")ab(c)d\"\n",
        "expectedOutput": "\"ab(c)d\"\n",
        "isHidden": true
      },
      {
        "input": "s = \"(a)b(c)d)\"\n",
        "expectedOutput": "\"(a)b(c)d\"\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Each prefix of a balanced parentheses has a number of open parentheses greater or equal than closed parentheses, similar idea with each suffix.",
      "Check the array from left to right, remove characters that do not meet the property mentioned above, same idea in backward way"
    ],
    "tags": ["String", "Stack"]
  },
  {
    "problemId": 14,
    "courseId": "facebook",
    "title": "Divide Two Integers",
    "difficulty": "Medium",
    "description": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.",
    "examples": [
      {
        "input": "dividend = 10, divisor = 3\n",
        "output": "3\n",
        "explanation": "10/3 = 3.33333.. which is truncated to 3.\n"
      },
      {
        "input": "dividend = 7, divisor = -3\n",
        "output": "-2\n",
        "explanation": "7/-3 = -2.33333.. which is truncated to -2.\n"
      }
    ],
    "constraints": [
      "-231 <= dividend, divisor <= 231 - 1",
      "divisor != 0"
    ],
    "testCases": [
      {
        "input": "dividend = 10, divisor = 3\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "dividend = 7, divisor = -3\n",
        "expectedOutput": "-2\n"
      },
      {
        "input": "dividend = -10, divisor = 3\n",
        "expectedOutput": "-3\n",
        "isHidden": true
      },
      {
        "input": "dividend = -7, divisor = -3\n",
        "expectedOutput": "2\n",
        "isHidden": true
      },
      {
        "input": "dividend = 2147483647, divisor = 1\n",
        "expectedOutput": "2147483647\n",
        "isHidden": true
      },
      {
        "input": "dividend = -2147483648, divisor = -1\n",
        "expectedOutput": "2147483647\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Handle edge cases such as division by zero and integer overflow.",
      "Convert dividend and divisor to positive values and track the sign of the result.",
      "Use bit manipulation to perform repeated subtraction and find the quotient.",
      "Shift the divisor left until it's greater than the dividend, then subtract and shift back."
    ],
    "tags": ["Math", "Bit Manipulation"]
  },
  {
    "problemId": 15,
    "courseId": "facebook",
    "title": "Next Permutation",
    "difficulty": "Medium",
    "description": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\nFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.",
    "examples": [
      {
        "input": "nums = [1,2,3]\n",
        "output": "[1,3,2]\n"
      },
      {
        "input": "nums = [3,2,1]\n",
        "output": "[1,2,3]\n"
      },
      {
        "input": "nums = [1,1,5]\n",
        "output": "[1,5,1]\n"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3]\n",
        "expectedOutput": "[1,3,2]\n"
      },
      {
        "input": "nums = [3,2,1]\n",
        "expectedOutput": "[1,2,3]\n"
      },
      {
        "input": "nums = [1,1,5]\n",
        "expectedOutput": "[1,5,1]\n"
      },
      {
        "input": "nums = [1,3,2]\n",
        "expectedOutput": "[2,1,3]\n",
        "isHidden": true
      },
      {
        "input": "nums = [2,3,1]\n",
        "expectedOutput": "[3,1,2]\n",
        "isHidden": true
      },
      {
        "input": "nums = [5,1,1]\n",
        "expectedOutput": "[1,1,5]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, the permutation is already the largest permutation.",
      "Find the largest index l > k such that nums[l] > nums[k].",
      "Swap nums[k] and nums[l].",
      "Reverse the sub-array nums[k + 1:]."
    ],
    "tags": ["Array", "Two Pointers"]
  },
   {
    "problemId": 16,
    "courseId": "facebook",
    "title": "Binary Search Tree Iterator",
    "difficulty": "Medium",
    "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\n\nFollow up:\nCould you implement next() and hasNext() to run in average O(1) time and use O(h) memory, where h is the height of the tree?",
    "examples": [
      {
        "input": "[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n",
        "output": "[null, 3, 7, true, 9, true, 15, true, 20, false]\n",
        "explanation": "BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 105].",
      "0 <= Node.val <= 106",
      "At most 105 calls will be made to hasNext, and next."
    ],
    "testCases": [
      {
        "input": "[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n",
        "expectedOutput": "[null, 3, 7, true, 9, true, 15, true, 20, false]\n"
      },
      {
        "input": "[\"BSTIterator\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[1]], [], [], [], [], [], []]\n",
        "expectedOutput": "[null, 1, false, null, false, null, false]\n",
        "isHidden": true
      },
      {
        "input": "[\"BSTIterator\", \"next\", \"next\", \"hasNext\"]\n[[[1,null,2]], [], [], []]\n",
        "expectedOutput": "[null, 1, 2, false]\n",
        "isHidden": true
      },
      {
        "input": "[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[4,2,6,1,3,5,7]], [], [], [], [], [], [], [], [], [], [], []]\n",
        "expectedOutput": "[null, 1, 2, true, 3, true, 4, true, 5, true, 6, true]\n",
        "isHidden": true
      },
      {
        "input": "[\"BSTIterator\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[20,10,30,5,15,25,35]], [], [], [], [], [], [], [], [], [], [], [], []]\n",
        "expectedOutput": "[null, 5, true, 10, true, 15, true, 20, true, 25, true, 30, true]\n",
        "isHidden": true
      },
      {
        "input": "[\"BSTIterator\", \"next\"]\n[[[1, null, 2]] , []]\n",
        "expectedOutput": "[null, 1]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a stack to simulate the in-order traversal.",
      "Push all the left children of the current node into the stack.",
      "When next() is called, pop the top element from the stack, and push all the left children of its right child into the stack.",
      "hasNext() simply checks if the stack is empty."
    ],
    "tags": ["Stack", "Tree", "Design", "Binary Search Tree", "Binary Tree", "Iterator"]
  },
  {
    "problemId": 17,
    "courseId": "facebook",
    "title": "Expression Add Operators",
    "difficulty": "Hard",
    "description": "Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.\nNote that operands in the returned expressions should not contain leading zeros.",
    "examples": [
      {
        "input": "num = \"123\", target = 6\n",
        "output": "[\"1*2*3\",\"1+2+3\"]\n",
        "explanation": "Both \"1*2*3\" and \"1+2+3\" evaluate to 6.\n"
      },
      {
        "input": "num = \"232\", target = 8\n",
        "output": "[\"2*3+2\",\"2+3*2\"]\n",
        "explanation": "Both \"2*3+2\" and \"2+3*2\" evaluate to 8.\n"
      },
      {
        "input": "num = \"3456237490\", target = 9191\n",
        "output": "[]\n",
        "explanation": "There are no expressions that can be created from \"3456237490\" to evaluate to 9191.\n"
      }
    ],
    "constraints": [
      "1 <= num.length <= 10",
      "num consists of only digits.",
      "-231 <= target <= 231 - 1"
    ],
    "testCases": [
      {
        "input": "num = \"123\", target = 6\n",
        "expectedOutput": "[\"1*2*3\",\"1+2+3\"]\n"
      },
      {
        "input": "num = \"232\", target = 8\n",
        "expectedOutput": "[\"2*3+2\",\"2+3*2\"]\n"
      },
      {
        "input": "num = \"3456237490\", target = 9191\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "num = \"105\", target = 5\n",
        "expectedOutput": "[\"1*0+5\",\"10-5\"]\n",
        "isHidden": true
      },
      {
        "input": "num = \"00\", target = 0\n",
        "expectedOutput": "[\"0*0\",\"0+0\",\"0-0\"]\n",
        "isHidden": true
      },
      {
        "input": "num = \"2147483647\", target = 2147483647\n",
        "expectedOutput": "[\"2147483647\"]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Note that a number can contain multiple digits.",
      "Since the question asks us to find all of the valid expressions, we need a way to iterate over all of them. (Hint: Recursion!)",
      "We can keep track of the expression string and evaluate it at the very end. But that would take a lot of time. Can we keep track of the expression's value as well so as to avoid the evaluation at the very end of recursion?",
      "Think carefully about the multiply operator. It has a higher precedence than the addition and subtraction operators.\n1 + 2 = 3\n1 + 2 - 4 --> 3 - 4 --> -1\n1 + 2 - 4 * 12 --> -1 * 12 --> -12 (WRONG!)\n1 + 2 - 4 * 12 --> -1 - (-4) + (-4 * 12) --> 3 + (-48) --> -45 (CORRECT!)",
      "We simply need to keep track of the last operand in our expression and reverse it's effect on the expression's value while considering the multiply operator."
    ],
    "tags": ["Math", "String", "Backtracking"]
  },
  {
    "problemId": 18,
    "courseId": "facebook",
    "title": "Design Add and Search Words Data Structure",
    "difficulty": "Medium",
    "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\nImplement the WordDictionary class:\nWordDictionary() Initializes the object.\nvoid addWord(word) Adds word to the data structure, it can be matched later.\nbool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.",
    "examples": [
      {
        "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[“.ad”]\n",
        "output": "[null,null,null,null,false,true,true,true]\n",
        "explanation": "WordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True\n"
      }
    ],
    "constraints": [
      "1 <= word.length <= 25",
      "word in addWord consists of lowercase English letters.",
      "word in search consist of '.' or lowercase English letters.",
      "There will be at most 2 dots in word for search queries.",
      "At most 104 calls will be made to addWord and search."
    ],
    "testCases": [
      {
        "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[“.ad”]\n",
        "expectedOutput": "[null,null,null,null,false,true,true,true]\n"
      },
      {
        "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"a\"],[\"a\"],[\"aa\"],[\"aaa\"],[\"a\"],[\".a\"],[\"a.\"],[\"a..\"],[\"aa\"]]\n",
        "expectedOutput": "[null,null,null,null,null,true,false,false,false,true]\n",
        "isHidden": true
      },
      {
        "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".ad\"],[\"b.\"],[\"a.d\"]]\n",
        "expectedOutput": "[null,null,null,null,null,false,false,false,true,false,true]\n",
        "isHidden": true
      },
      {
        "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[“.ad”],[\"b..\"]]\n",
        "expectedOutput": "[null,null,null,null,false,true,true,true]\n",
        "isHidden": true
      },
      {
        "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"a\"],[\"a\"],[\"a\"],[\"a\"],[\"a\"],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"],[\"aa\"],[\"a\"],[\".a\"]]\n",
        "expectedOutput": "[null,null,null,null,null,null,null,null,true,true,false,true,false,false,false,true,false]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first."
    ],
    "tags": ["String", "Depth-First Search", "Design", "Trie"]
  },
  {
    "problemId": 19,
    "courseId": "facebook",
    "title": "Valid Number",
    "difficulty": "Hard",
    "description": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numbers: “2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”, while the following are not valid numbers: “abc”, “1a”, “1e”, “e3”, “99e2.5”, “--6”, “-+3”, “95a54e53”.\nFormally, a valid number is defined using one of the following definitions:\nAn integer number followed by an optional exponent.\nA decimal number followed by an optional exponent.\nAn integer number is defined with an optional sign '-' or '+' followed by digits.\nA decimal number is defined with an optional sign '-' or '+' followed by one of the following definitions:\nDigits followed by a dot '.'.\nDigits followed by a dot '.' followed by digits.\nA dot '.' followed by digits.\nAn exponent is defined with an exponent notation 'e' or 'E' followed by an integer number.\nThe digits are defined as one or more digits.",
    "examples": [
      {
        "input": "s = \"0\"\n",
        "output": "true\n"
      },
      {
        "input": "s = \"e\"\n",
        "output": "false\n"
      },
      {
        "input": "s = \".\"\n",
        "output": "false\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 20",
      "s consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'."
    ],
    "testCases": [
      {
        "input": "s = \"0\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "s = \"e\"\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "s = \".\"\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "s = \"2e10\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "s = \"-90E3\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "s = \"1e\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "s = \"abc\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "s = \"1a\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "s = \"99e2.5\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "s = \"--6\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "s = \"-+3\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "s = \"95a54e53\"\n",
        "expectedOutput": "false\n",
        "isHidden": true
      },
      {
        "input": "s = \".1\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "s = \"46.e3\"\n",
        "expectedOutput": "true\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Consider all possible cases for a valid number: integer, decimal, and exponent.",
      "Use finite state machine (FSM) or regular expressions to validate the number format.",
      "Handle edge cases such as leading/trailing spaces, multiple signs, and invalid exponent forms."
    ],
    "tags": ["String"]
  },
  {
    "problemId": 20,
    "courseId": "facebook",
    "title": "Binary Tree Maximum Path Sum",
    "difficulty": "Hard",
    "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.",
    "examples": [
      {
        "input": "root = [1,2,3]\n",
        "output": "6\n",
        "explanation": "The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n"
      },
      {
        "input": "root = [-10,9,20,null,null,15,7]\n",
        "output": "42\n",
        "explanation": "The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 3 * 104].",
      "-1000 <= Node.val <= 1000"
    ],
    "testCases": [
      {
        "input": "root = [1,2,3]\n",
        "expectedOutput": "6\n"
      },
      {
        "input": "root = [-10,9,20,null,null,15,7]\n",
        "expectedOutput": "42\n"
      },
      {
        "input": "root = [1]\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "root = [-3]\n",
        "expectedOutput": "-3\n",
        "isHidden": true
      },
      {
        "input": "root = [-2,1]\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "root = [2,-1,-2]\n",
        "expectedOutput": "2\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a recursive approach to traverse the tree.",
      "For each node, calculate the maximum path sum that includes the node as the root of the path.",
      "Keep track of the maximum path sum found so far.",
      "Consider the cases where the maximum path sum includes the node, its left child, and its right child."
    ],
    "tags": ["Dynamic Programming", "Tree", "Depth-First Search", "Binary Tree"]
  },
  {
    "problemId": 21,
    "courseId": "facebook",
    "title": "Clone Graph",
    "difficulty": "Medium",
    "description": "Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\nTest case format:\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.",
    "examples": [
      {
        "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]\n",
        "output": "[[2,4],[1,3],[2,4],[1,3]]\n",
        "explanation": "There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n"
      },
      {
        "input": "adjList = [[]]\n",
        "output": "[[]]\n",
        "explanation": "Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n"
      },
      {
        "input": "adjList = []\n",
        "output": "[]\n",
        "explanation": "This an empty graph, it does not have any nodes.\n"
      }
    ],
    "constraints": [
      "The number of nodes in the graph is in the range [0, 100].",
      "1 <= Node.val <= 100",
      "Node.val is unique for each node.",
      "There are no repeated edges and no self-loops in the graph.",
      "The Graph is connected and all nodes can be visited starting from the given node."
    ],
    "testCases": [
      {
        "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]\n",
        "expectedOutput": "[[2,4],[1,3],[2,4],[1,3]]\n"
      },
      {
        "input": "adjList = [[]]\n",
        "expectedOutput": "[[]]\n"
      },
      {
        "input": "adjList = []\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "adjList = [[2],[1]]\n",
        "expectedOutput": "[[2],[1]]\n",
        "isHidden": true
      },
      {
        "input": "adjList = [[2,3],[1,4],[1,4],[2,3]]\n",
        "expectedOutput": "[[2,3],[1,4],[1,4],[2,3]]\n",
        "isHidden": true
      },
      {
        "input": "adjList = [[2,3,4],[1,5],[1,6],[1],[2],[3]]\n",
        "expectedOutput": "[[2,3,4],[1,5],[1,6],[1],[2],[3]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a hash table to store the mapping between the original nodes and the cloned nodes.",
      "Traverse the graph using depth-first search (DFS) or breadth-first search (BFS).",
      "For each node, create a clone node and add it to the hash table.",
      "For each neighbor of the node, recursively clone the neighbor and add it to the clone node's neighbors list."
    ],
    "tags": ["Hash Table", "Depth-First Search", "Breadth-First Search", "Graph"]
  },
  {
    "problemId": 22,
    "courseId": "facebook",
    "title": "Find All Anagrams in a String",
    "difficulty": "Medium",
    "description": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.",
    "examples": [
      {
        "input": "s = \"cbaebabacd\", p = \"abc\"\n",
        "output": "[0,6]\n",
        "explanation": "The substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\n"
      },
      {
        "input": "s = \"abab\", p = \"ab\"\n",
        "output": "[0,1,2]\n",
        "explanation": "The substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\n"
      }
    ],
    "constraints": [
      "1 <= s.length, p.length <= 3 * 104",
      "s and p consist of lowercase English letters."
    ],
    "testCases": [
      {
        "input": "s = \"cbaebabacd\", p = \"abc\"\n",
        "expectedOutput": "[0,6]\n"
      },
      {
        "input": "s = \"abab\", p = \"ab\"\n",
        "expectedOutput": "[0,1,2]\n"
      },
      {
        "input": "s = \"\", p = \"abc\"\n",
        "expectedOutput": "[]\n",
        "isHidden": true
      },
      {
        "input": "s = \"abc\", p = \"\"\n",
        "expectedOutput": "[]\n",
        "isHidden": true
      },
      {
        "input": "s = \"aaaaaaaaaa\", p = \"aaaaaaa\"\n",
        "expectedOutput": "[0,1,2,3]\n",
        "isHidden": true
      },
      {
        "input": "s = \"baa\", p = \"aa\"\n",
        "expectedOutput": "[1]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a sliding window approach.",
      "Maintain a hashmap of the characters in p and their frequencies.",
      "Maintain a sliding window of the same size as p in s.",
      "Check if the characters in the sliding window form an anagram of p by comparing the hashmaps.",
      "If the characters form an anagram, add the start index of the sliding window to the result."
    ],
    "tags": ["Hash Table", "String", "Sliding Window"]
  },
  {
    "problemId": 23,
    "courseId": "facebook",
    "title": "Add Strings",
    "difficulty": "Easy",
    "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
    "examples": [
      {
        "input": "num1 = \"11\", num2 = \"123\"\n",
        "output": "\"134\"\n"
      },
      {
        "input": "num1 = \"456\", num2 = \"77\"\n",
        "output": "\"533\"\n"
      },
      {
        "input": "num1 = \"0\", num2 = \"0\"\n",
        "output": "\"0\"\n"
      }
    ],
    "constraints": [
      "1 <= num1.length, num2.length <= 104",
      "num1 and num2 consist of only digits.",
      "num1 and num2 don't have any leading zeros except for the zero itself."
    ],
    "testCases": [
      {
        "input": "num1 = \"11\", num2 = \"123\"\n",
        "expectedOutput": "\"134\"\n"
      },
      {
        "input": "num1 = \"456\", num2 = \"77\"\n",
        "expectedOutput": "\"533\"\n"
      },
      {
        "input": "num1 = \"0\", num2 = \"0\"\n",
        "expectedOutput": "\"0\"\n"
      },
      {
        "input": "num1 = \"1\", num2 = \"9\"\n",
        "expectedOutput": "\"10\"\n",
        "isHidden": true
      },
      {
        "input": "num1 = \"99\", num2 = \"1\"\n",
        "expectedOutput": "\"100\"\n",
        "isHidden": true
      },
      {
        "input": "num1 = \"123456789\", num2 = \"987654321\"\n",
        "expectedOutput": "\"1111111110\"\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Simulate the addition process digit by digit, starting from the least significant digit.",
      "Keep track of the carry-over from each digit addition.",
      "Append the result digits to a string in reverse order, and then reverse the string to get the final result."
    ],
    "tags": ["Math", "String", "Simulation"]
  },
  {
    "problemId": 24,
    "courseId": "facebook",
    "title": "Palindrome Pairs",
    "difficulty": "Hard",
    "description": "You are given a 0-indexed array of unique strings words.\nA palindrome pair is a pair of integers (i, j) such that:\n0 <= i, j < words.length,\ni != j, and\nwords[i] + words[j] (the concatenation of the two strings) is a palindrome.\nReturn an array of all the palindrome pairs of words.\nYou must write an algorithm with O(sum of words[i].length) runtime complexity.",
    "examples": [
      {
        "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n",
        "output": "[[0,1],[1,0],[3,2],[2,4]]\n",
        "explanation": "The palindromes are [\"abcddcba\",\"dcbaabcd\",\"slls\",\"llssssll\"]\n"
      },
      {
        "input": "words = [\"bat\",\"tab\",\"cat\"]\n",
        "output": "[[0,1],[1,0]]\n",
        "explanation": "The palindromes are [\"battab\",\"tabbat\"]\n"
      },
      {
        "input": "words = [\"a\",\"\"]\n",
        "output": "[[0,1],[1,0]]\n",
        "explanation": "The palindromes are [\"a\",\"a\"]\n"
      }
    ],
    "constraints": [
      "1 <= words.length <= 5000",
      "0 <= words[i].length <= 300",
      "words[i] consists of lowercase English letters."
    ],
    "testCases": [
      {
        "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n",
        "expectedOutput": "[[0,1],[1,0],[3,2],[2,4]]\n"
      },
      {
        "input": "words = [\"bat\",\"tab\",\"cat\"]\n",
        "expectedOutput": "[[0,1],[1,0]]\n"
      },
      {
        "input": "words = [\"a\",\"\"]\n",
        "expectedOutput": "[[0,1],[1,0]]\n"
      },
      {
        "input": "words = [\"a\",\"b\",\"ba\",\"ab\",\"aba\"]\n",
        "expectedOutput": "[[0,4],[1,3],[2,3],[3,2]]\n",
        "isHidden": true
      },
      {
        "input": "words = [\"\",\"c\",\"a\",\"aa\"]\n",
        "expectedOutput": "[[0,2],[2,0],[0,3],[3,0]]\n",
        "isHidden": true
      },
      {
        "input": "words = [\"a\",\"abc\",\"aba\",\"\"]\n",
        "expectedOutput": "[[0,3],[3,0],[2,3],[3,2]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Checking every two pairs will exceed the time limit. It will be O(n^2 * k). We need a faster way.",
      "If we hash every string in the array, how can we check if two pairs form a palindrome after the concatenation?",
      "We can check every string in words and consider it as words[j] (i.e., the suffix of the target palindrome). We can check if there is a hash of string that can be the prefix to make it a palindrome"
    ],
    "tags": ["Array", "Hash Table", "String", "Trie"]
  },
  {
    "problemId": 25,
    "courseId": "facebook",
    "title": "Diameter of Binary Tree",
    "difficulty": "Easy",
    "description": "Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them.",
    "examples": [
      {
        "input": "root = [1,2,3,4,5]\n",
        "output": "3\n",
        "explanation": "3 is the length of the path [4,2,1,3] or [5,2,1,3].\n"
      },
      {
        "input": "root = [1,2]\n",
        "output": "1\n"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 104].",
      "-100 <= Node.val <= 100"
    ],
    "testCases": [
      {
        "input": "root = [1,2,3,4,5]\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "root = [1,2]\n",
        "expectedOutput": "1\n"
      },
      {
        "input": "root = [1]\n",
        "expectedOutput": "0\n",
        "isHidden": true
      },
      {
        "input": "root = [1,2,3]\n",
        "expectedOutput": "2\n",
        "isHidden": true
      },
      {
        "input": "root = [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,null,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\n",
        "expectedOutput": "8\n",
        "isHidden": true
      },
      {
        "input": "root = [1,2,3,4,5,6,7]\n",
        "expectedOutput": "4\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a recursive depth-first search (DFS) approach.",
      "For each node, calculate the height of its left and right subtrees.",
      "The diameter passing through the node is the sum of the left and right subtree heights.",
      "Keep track of the maximum diameter encountered during the traversal."
    ],
    "tags": ["Tree", "Depth-First Search", "Binary Tree"]
  },
  {
    "problemId": 26,
    "courseId": "facebook",
    "title": "Binary Tree Paths",
    "difficulty": "Easy",
    "description": "Given the root of a binary tree, return all root-to-leaf paths in any order.\nA leaf is a node with no children.",
    "examples": [
      {
        "input": "root = [1,2,3,null,5]\n",
        "output": "[\"1->2->5\",\"1->3\"]\n"
      },
      {
        "input": "root = [1]\n",
        "output": "[\"1\"]\n"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 100].",
      "-100 <= Node.val <= 100"
    ],
    "testCases": [
      {
        "input": "root = [1,2,3,null,5]\n",
        "expectedOutput": "[\"1->2->5\",\"1->3\"]\n"
      },
      {
        "input": "root = [1]\n",
        "expectedOutput": "[\"1\"]\n"
      },
      {
        "input": "root = []\n",
        "expectedOutput": "[]\n",
        "isHidden": true
      },
      {
        "input": "root = [1,2]\n",
        "expectedOutput": "[\"1->2\"]\n",
        "isHidden": true
      },
      {
        "input": "root = [1,2,3,4,5]\n",
        "expectedOutput": "[\"1->2->4\",\"1->2->5\",\"1->3\"]\n",
        "isHidden": true
      },
      {
        "input": "root = [1,2,3,null,5,6]\n",
        "expectedOutput": "[\"1->2->5\",\"1->3->6\"]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a depth-first search (DFS) approach to traverse the tree.",
      "Maintain a path string during the traversal.",
      "When a leaf node is reached, add the path string to the result.",
      "Backtrack and remove the last node from the path string as you move up the tree."
    ],
    "tags": ["String", "Backtracking", "Tree", "Depth-First Search", "Binary Tree"]
  },
  {
    "problemId": 27,
    "courseId": "facebook",
    "title": "Kth Largest Element in an Array",
    "difficulty": "Medium",
    "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
    "examples": [
      {
        "input": "nums = [3,2,1,5,6,4], k = 2\n",
        "output": "5\n"
      },
      {
        "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4\n",
        "output": "4\n"
      }
    ],
    "constraints": [
      "1 <= k <= nums.length <= 105",
      "-104 <= nums[i] <= 104"
    ],
    "testCases": [
      {
        "input": "nums = [3,2,1,5,6,4], k = 2\n",
        "expectedOutput": "5\n"
      },
      {
        "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4\n",
        "expectedOutput": "4\n"
      },
      {
        "input": "nums = [1], k = 1\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "nums = [2,1], k = 1\n",
        "expectedOutput": "2\n",
        "isHidden": true
      },
      {
        "input": "nums = [2,1], k = 2\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "nums = [3,3,3,3,3,3,3,3,3], k = 1\n",
        "expectedOutput": "3\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a min-heap (priority queue) to keep track of the k largest elements.",
      "Iterate through the array and add each element to the min-heap.",
      "If the size of the min-heap exceeds k, remove the smallest element from the min-heap.",
      "The root of the min-heap will be the kth largest element.",
      "Alternatively, you can use quickselect to find the kth largest element in O(n) average time complexity."
    ],
    "tags": ["Array", "Divide and Conquer", "Sorting", "Heap (Priority Queue)", "Quickselect"]
  },
  {
    "problemId": 28,
    "courseId": "facebook",
    "title": "Continuous Subarray Sum",
    "difficulty": "Medium",
    "description": "Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\nA good subarray is a subarray where:\nits length is at least two, and\nthe sum of the elements of the subarray is a multiple of k.\nNote that:\nA subarray is a contiguous part of the array.\nAn integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.",
    "examples": [
      {
        "input": "nums = [23,2,4,6,7], k = 6\n",
        "output": "true\n",
        "explanation": "[2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n"
      },
      {
        "input": "nums = [23,2,6,4,7], k = 6\n",
        "output": "true\n",
        "explanation": "[23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n"
      },
      {
        "input": "nums = [23,2,6,4,7], k = 13\n",
        "output": "false\n"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 105",
      "0 <= nums[i] <= 109",
      "0 <= sum(nums[i]) <= 231 - 1",
      "1 <= k <= 231 - 1"
    ],
    "testCases": [
      {
        "input": "nums = [23,2,4,6,7], k = 6\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "nums = [23,2,6,4,7], k = 6\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "nums = [23,2,6,4,7], k = 13\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "nums = [0,0], k = 1\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "nums = [5,0,0,0], k = 3\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "nums = [1,0,1,0,1], k = 4\n",
        "expectedOutput": "false\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a hash table to store the remainders of the prefix sums modulo k.",
      "If a remainder repeats, it means the sum of the subarray between the two occurrences is a multiple of k.",
      "Be careful to handle the case where the subarray length is less than 2.",
      "Consider the case where the remainder is 0."
    ],
    "tags": ["Array", "Hash Table", "Math", "Prefix Sum"]
  },
  {
    "problemId": 29,
    "courseId": "facebook",
    "title": "Task Scheduler",
    "difficulty": "Medium",
    "description": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label.\nReturn the minimum number of CPU intervals required to complete all tasks.",
    "examples": [
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n",
        "output": "8\n",
        "explanation": "A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.\nAfter completing task A, you must wait two intervals before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th interval, you can do A again as 2 intervals have passed.\n"
      },
      {
        "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1\n",
        "output": "6\n",
        "explanation": "A possible sequence is: A -> B -> C -> D -> A -> B.\nWith a cooling interval of 1, you can repeat a task after just one other task.\n"
      },
      {
        "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3\n",
        "output": "10\n",
        "explanation": "A possible sequence is: A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B.\nThere are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.\n"
      }
    ],
    "constraints": [
      "1 <= tasks.length <= 104",
      "tasks[i] is an uppercase English letter.",
      "0 <= n <= 100"
    ],
    "testCases": [
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n",
        "expectedOutput": "8\n"
      },
      {
        "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1\n",
        "expectedOutput": "6\n"
      },
      {
        "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3\n",
        "expectedOutput": "10\n"
      },
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\n",
        "expectedOutput": "16\n",
        "isHidden": true
      },
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\n",
        "expectedOutput": "6\n",
        "isHidden": true
      },
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 0\n",
        "expectedOutput": "12\n",
        "isHidden": true
      }
    ],
    "hints": [
      "There are many different solutions for this problem, including a greedy algorithm.",
      "For every cycle, find the most frequent letter that can be placed in this cycle. After placing, decrease the frequency of that letter by one.",
      "Use Priority Queue."
    ],
    "tags": ["Array", "Hash Table", "Greedy", "Sorting", "Heap (Priority Queue)", "Counting"]
  },
  {
    "problemId": 30,
    "courseId": "facebook",
    "title": "Multiply Strings",
    "difficulty": "Medium",
    "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.",
    "examples": [
      {
        "input": "num1 = \"2\", num2 = \"3\"\n",
        "output": "\"6\"\n"
      },
      {
        "input": "num1 = \"123\", num2 = \"456\"\n",
        "output": "\"56088\"\n"
      }
    ],
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only.",
      "Both num1 and num2 do not contain any leading zero, except the number 0 itself."
    ],
    "testCases": [
      {
        "input": "num1 = \"2\", num2 = \"3\"\n",
        "expectedOutput": "\"6\"\n"
      },
      {
        "input": "num1 = \"123\", num2 = \"456\"\n",
        "expectedOutput": "\"56088\"\n"
      },
      {
        "input": "num1 = \"0\", num2 = \"0\"\n",
        "expectedOutput": "\"0\"\n",
        "isHidden": true
      },
      {
        "input": "num1 = \"1\", num2 = \"999\"\n",
        "expectedOutput": "\"999\"\n",
        "isHidden": true
      },
      {
        "input": "num1 = \"999\", num2 = \"1\"\n",
        "expectedOutput": "\"999\"\n",
        "isHidden": true
      },
      {
        "input": "num1 = \"123456789\", num2 = \"987654321\"\n",
        "expectedOutput": "\"121932631112635269\"\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Simulate the multiplication process digit by digit, similar to how you would do it on paper.",
      "Multiply each digit of num1 by each digit of num2, and store the partial products in an array.",
      "Add the partial products together, taking care of carry-overs.",
      "Convert the final result from an array of digits to a string."
    ],
    "tags": ["Math", "String", "Simulation"]
  }
]