[
  {
    "problemId": 1,
    "courseId": "amazon",
    "title": "Reorder Data in Log Files",
    "difficulty": "Medium",
    "description": "You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier. There are two types of logs:\n1. Letter-logs: All words (except the identifier) consist of lowercase English letters.\n2. Digit-logs: All words (except the identifier) consist of digits.\n\nReorder these logs so that:\n1. The letter-logs come before all digit-logs.\n2. The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.\n3. The digit-logs maintain their relative ordering.\n\nReturn the final order of the logs.",
    "examples": [
      {
        "input": "[\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"]\n",
        "output": "[\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]\n",
        "explanation": "The letter-log contents are all different, so their ordering is \"art can\", \"art zero\", \"own kit dig\". The digit-logs have a relative order of \"dig1 8 1 5 1\", \"dig2 3 6\".\n"
      },
      {
        "input": "[\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"]\n",
        "output": "[\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"]\n",
        "explanation": "Letter-logs with same content (\"act car\" and \"act zoo\") are sorted by their identifiers (\"g1\" vs \"a8\").\n"
      }
    ],
    "constraints": [
      "1 <= logs.length <= 100",
      "3 <= logs[i].length <= 100",
      "All tokens of logs[i] are separated by a single space",
      "logs[i] is guaranteed to have an identifier and at least one word after the identifier"
    ],
    "testCases": [
      {
        "input": "[\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"]\n",
        "expectedOutput": "[\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]\n"
      },
      {
        "input": "[\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"]\n",
        "expectedOutput": "[\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"]\n"
      },
      {
        "input": "[\"a1 a a\",\"b1 b b\",\"c1 1 1\",\"d1 d d\",\"e1 2 2\"]\n",
        "expectedOutput": "[\"a1 a a\",\"b1 b b\",\"d1 d d\",\"c1 1 1\",\"e1 2 2\"]\n",
        "isHidden": true,
        "explanation": "Letter-logs sorted alphabetically by content, digit-logs maintain order"
      },
      {
        "input": "[\"x1 1\",\"y2 2\",\"z3 a\"]\n",
        "expectedOutput": "[\"z3 a\",\"x1 1\",\"y2 2\"]\n",
        "isHidden": true,
        "explanation": "Single-word logs with one letter-log coming before digit-logs"
      },
      {
        "input": "[\"a1 a b\",\"a2 a b\",\"a3 1 2\"]\n",
        "expectedOutput": "[\"a1 a b\",\"a2 a b\",\"a3 1 2\"]\n",
        "isHidden": true,
        "explanation": "Letter-logs with identical content sorted by identifier"
      }
    ],
    "hints": [
      "First separate the logs into two groups: letter-logs and digit-logs",
      "For letter-logs, the sorting key should be (content, identifier)",
      "For digit-logs, maintain their original order",
      "You can check if a log is a digit-log by examining the first character after the identifier",
      "Python's sort with custom key functions can be particularly useful for this problem"
    ],
    "tags": ["array", "string", "sorting"]
  
  },
  {
    "problemId": 2,
    "courseId": "amazon",
    "title": "Number of Islands",
    "difficulty": "Medium",
    "description": "Given an m x n 2D binary grid representing a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. All four edges of the grid are surrounded by water.",
    "examples": [
      {
        "input": "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]\n",
        "output": "1\n",
        "explanation": "There is one large connected island in the top-left corner of the grid.\n"
      },
      {
        "input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\n",
        "output": "3\n",
        "explanation": "There are three separate islands: two in the top-left and bottom-right corners, and one in the center.\n"
      }
    ],
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is either '0' or '1'"
    ],
    "testCases": [
      {
        "input": "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]\n",
        "expectedOutput": "1\n"
      },
      {
        "input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "[[\"1\",\"0\",\"1\"],[\"0\",\"1\",\"0\"],[\"1\",\"0\",\"1\"]]\n",
        "expectedOutput": "5\n",
        "isHidden": true,
        "explanation": "Diagonal lands don't count as connected, resulting in 5 single-cell islands"
      },
      {
        "input": "[[\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\"],[\"1\",\"1\",\"1\"]]\n",
        "expectedOutput": "1\n",
        "isHidden": true,
        "explanation": "Single island with a hole in the center"
      },
      {
        "input": "[[\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\"]]\n",
        "expectedOutput": "0\n",
        "isHidden": true,
        "explanation": "No land cells means no islands"
      }
    ],
    "hints": [
      "Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore connected land cells",
      "When you find a '1', increment your island count and mark all connected '1's as visited",
      "You can mark visited cells by changing their value to '0' to avoid revisiting",
      "Consider each cell as a node in a graph where edges connect to adjacent land cells",
      "The solution should traverse the entire grid, checking each cell exactly once"
    ],
    "tags": ["array", "depth-first-search", "breadth-first-search", "union-find", "matrix"]
  },
  {
    "problemId": 3,
    "courseId": "amazon",
    "title": "Critical Connections in a Network",
    "difficulty": "Hard",
    "description": "There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network. A critical connection is a connection that, if removed, will make some servers unable to reach some other server. Return all critical connections in the network in any order.",
    "examples": [
      {
        "input": "4\n[[0,1],[1,2],[2,0],[1,3]]\n",
        "output": "[[1,3]]\n",
        "explanation": "The connection [1,3] is critical because its removal would isolate server 3 from the network.\n"
      },
      {
        "input": "2\n[[0,1]]\n",
        "output": "[[0,1]]\n",
        "explanation": "In a two-server network, the single connection is always critical.\n"
      }
    ],
    "constraints": [
      "2 <= n <= 10^5",
      "n-1 <= connections.length <= 10^5",
      "0 <= ai, bi <= n-1",
      "ai != bi",
      "No repeated connections"
    ],
    "testCases": [
      {
        "input": "4\n[[0,1],[1,2],[2,0],[1,3]]\n",
        "expectedOutput": "[[1,3]]\n"
      },
      {
        "input": "2\n[[0,1]]\n",
        "expectedOutput": "[[0,1]]\n"
      },
      {
        "input": "5\n[[0,1],[1,2],[2,0],[1,3],[3,4]]\n",
        "expectedOutput": "[[1,3],[3,4]]\n",
        "isHidden": true,
        "explanation": "Two critical connections form a bridge between two cycles"
      },
      {
        "input": "6\n[[0,1],[1,2],[2,0],[1,3],[3,4],[4,5],[5,3]]\n",
        "expectedOutput": "[[1,3]]\n",
        "isHidden": true,
        "explanation": "Only one critical connection despite multiple cycles"
      },
      {
        "input": "3\n[[0,1],[1,2],[2,0]]\n",
        "expectedOutput": "[]\n",
        "isHidden": true,
        "explanation": "No critical connections in a fully cyclic network"
      }
    ],
    "hints": [
      "Use Tarjan's algorithm for finding bridges in a graph",
      "Track discovery time and low values for each node during DFS",
      "A connection is critical if the low value of the child node is greater than the discovery time of the parent node",
      "Optimize the algorithm to handle large input sizes (up to 10^5 nodes)",
      "Remember the graph is undirected, so avoid revisiting the parent node"
    ],
    "tags": ["depth-first-search", "graph", "biconnected-component", "tarjan-algorithm"]
  },
  {
    "problemId": 4,
    "courseId": "amazon",
    "title": "Two Sum",
    "difficulty": "Easy",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume each input has exactly one solution, and you may not use the same element twice. The answer can be returned in any order.",
    "examples": [
      {
        "input": "[2,7,11,15]\n9\n",
        "output": "[0,1]\n",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9\n"
      },
      {
        "input": "[3,2,4]\n6\n",
        "output": "[1,2]\n",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6\n"
      },
      {
        "input": "[3,3]\n6\n",
        "output": "[0,1]\n",
        "explanation": "nums[0] + nums[1] = 3 + 3 = 6\n"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "testCases": [
      {
        "input": "[2,7,11,15]\n9\n",
        "expectedOutput": "[0,1]\n"
      },
      {
        "input": "[3,2,4]\n6\n",
        "expectedOutput": "[1,2]\n"
      },
      {
        "input": "[3,3]\n6\n",
        "expectedOutput": "[0,1]\n"
      },
      {
        "input": "[-1,-2,-3,-4,-5]\n-8\n",
        "expectedOutput": "[2,4]\n",
        "isHidden": true,
        "explanation": "Negative numbers can also sum to target"
      },
      {
        "input": "[0,4,3,0]\n0\n",
        "expectedOutput": "[0,3]\n",
        "isHidden": true,
        "explanation": "Zero values can be part of the solution"
      },
      {
        "input": "[1,2,3,4,5,6,7,8,9,10]\n19\n",
        "expectedOutput": "[8,9]\n",
        "isHidden": true,
        "explanation": "Large array test case"
      }
    ],
    "hints": [
      "Brute force approach would check all possible pairs (O(n^2) time)",
      "Consider using a hash map to store seen values for O(1) lookups",
      "For each number, check if (target - current number) exists in the map",
      "This approach reduces time complexity to O(n) with O(n) space",
      "Handle duplicate values carefully as you need their indices"
    ],
    "tags": ["array", "hash-table"],
    "followUp": "Can you come up with an algorithm that is less than O(n^2) time complexity?"
  },
  {
    "problemId": 5,
    "courseId": "amazon",
    "title": "LRU Cache",
    "difficulty": "Medium",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with these methods:\n- LRUCache(int capacity): Initialize the cache with positive size capacity\n- int get(int key): Return the value of the key if exists, otherwise -1\n- void put(int key, int value): Update or add the key-value pair, evicting the least recently used key if capacity is exceeded\n\nBoth get and put operations must run in O(1) average time complexity.",
    "examples": [
      {
        "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n",
        "output": "[null, null, null, 1, null, -1, null, -1, 3, 4]\n",
        "explanation": "Cache operations with capacity 2 demonstrate LRU eviction policy when capacity is exceeded.\n"
      }
    ],
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key <= 10^4",
      "0 <= value <= 10^5",
      "At most 2 * 10^5 calls total to get and put"
    ],
    "testCases": [
      {
        "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n",
        "expectedOutput": "[null, null, null, 1, null, -1, null, -1, 3, 4]\n"
      },
      {
        "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\"]\n[[1], [1, 1], [2, 2], [1], [3, 3], [2], [3]]\n",
        "expectedOutput": "[null, null, null, -1, null, -1, 3]\n",
        "isHidden": true,
        "explanation": "Single capacity cache showing immediate eviction of previous entries"
      },
      {
        "input": "[\"LRUCache\", \"put\", \"get\", \"put\", \"get\", \"get\"]\n[[2], [1, 1], [1], [2, 2], [1], [2]]\n",
        "expectedOutput": "[null, null, 1, null, 1, 2]\n",
        "isHidden": true,
        "explanation": "Basic operations without evictions"
      },
      {
        "input": "[\"LRUCache\", \"put\", \"put\", \"put\", \"get\", \"get\", \"get\"]\n[[3], [1, 1], [2, 2], [3, 3], [1], [2], [3]]\n",
        "expectedOutput": "[null, null, null, null, 1, 2, 3]\n",
        "isHidden": true,
        "explanation": "Full capacity usage without evictions"
      }
    ],
    "hints": [
      "Use a combination of hash map and doubly-linked list for O(1) operations",
      "The hash map stores key to node mappings",
      "The doubly-linked list maintains the usage order (recent at head, LRU at tail)",
      "On get operations: move accessed node to head",
      "On put operations: update if exists (move to head), else add new node (evict tail if full)"
    ],
    "tags": ["hash-table", "linked-list", "design", "doubly-linked-list"]
  },
  {
    "problemId": 6,
    "courseId": "amazon",
    "title": "K Closest Points to Origin",
    "difficulty": "Medium",
    "description": "Given an array of points on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance is calculated using Euclidean distance, and the answer can be in any order.",
    "examples": [
      {
        "input": "[[1,3],[-2,2]]\n1\n",
        "output": "[[-2,2]]\n",
        "explanation": "(-2,2) is closer to origin (distance sqrt(8)) than (1,3) (distance sqrt(10))\n"
      },
      {
        "input": "[[3,3],[5,-1],[-2,4]]\n2\n",
        "output": "[[3,3],[-2,4]]\n",
        "explanation": "Both points are closer to origin than [5,-1], order doesn't matter\n"
      }
    ],
    "constraints": [
      "1 <= k <= points.length <= 10^4",
      "-10^4 <= xi, yi <= 10^4",
      "Answer is guaranteed to be unique (order aside)"
    ],
    "testCases": [
      {
        "input": "[[1,3],[-2,2]]\n1\n",
        "expectedOutput": "[[-2,2]]\n"
      },
      {
        "input": "[[3,3],[5,-1],[-2,4]]\n2\n",
        "expectedOutput": "[[3,3],[-2,4]]\n"
      },
      {
        "input": "[[0,1],[1,0]]\n2\n",
        "expectedOutput": "[[0,1],[1,0]]\n",
        "isHidden": true,
        "explanation": "All points equally distant when k equals array length"
      },
      {
        "input": "[[10000,10000],[-10000,-10000],[1,1]]\n1\n",
        "expectedOutput": "[[1,1]]\n",
        "isHidden": true,
        "explanation": "Extreme coordinate values with obvious closest point"
      },
      {
        "input": "[[1,1],[2,2],[3,3],[4,4],[5,5]]\n3\n",
        "expectedOutput": "[[1,1],[2,2],[3,3]]\n",
        "isHidden": true,
        "explanation": "Simple ordered case with k < n"
      }
    ],
    "hints": [
      "Calculate squared distances to avoid expensive sqrt operations",
      "Consider using a max-heap of size k to track closest points efficiently",
      "Alternative approach: sort all points by distance (O(n log n))",
      "For optimal O(n) average case, consider Quickselect algorithm",
      "Remember you can compare squared distances directly (sqrt monotonic)"
    ],
    "tags": ["array", "math", "divide-and-conquer", "geometry", "sorting", "heap", "priority-queue", "quickselect"]
  },
  {
    "problemId": 7,
    "courseId": "amazon",
    "title": "Most Common Word",
    "difficulty": "Easy",
    "description": "Given a string paragraph and a list of banned words, return the most frequent word that is not banned. Words are case-insensitive, punctuation should be ignored, and the answer should be in lowercase. The answer is guaranteed to be unique.",
    "examples": [
      {
        "input": "\"Bob hit a ball, the hit BALL flew far after it was hit.\"\n[\"hit\"]\n",
        "output": "\"ball\"\n",
        "explanation": "\"hit\" occurs 3 times but is banned. \"ball\" occurs twice and is the most frequent non-banned word.\n"
      },
      {
        "input": "\"a.\"\n[]\n",
        "output": "\"a\"\n",
        "explanation": "Single word case with no banned words.\n"
      }
    ],
    "constraints": [
      "1 <= paragraph.length <= 1000",
      "paragraph contains English letters, spaces, or \"!?',;.\"",
      "0 <= banned.length <= 100",
      "banned words are lowercase and 1-10 characters long",
      "At least one non-banned word exists",
      "Answer is unique"
    ],
    "testCases": [
      {
        "input": "\"Bob hit a ball, the hit BALL flew far after it was hit.\"\n[\"hit\"]\n",
        "expectedOutput": "\"ball\"\n"
      },
      {
        "input": "\"a.\"\n[]\n",
        "expectedOutput": "\"a\"\n"
      },
      {
        "input": "\"Test, test, test! test? test\"\n[\"test\"]\n",
        "expectedOutput": "\"\"\n",
        "isHidden": true,
        "explanation": "All instances of the only word are banned"
      },
      {
        "input": "\"a.a.a.b.b.b.c\"\n[\"a\", \"b\"]\n",
        "expectedOutput": "\"c\"\n",
        "isHidden": true,
        "explanation": "Multiple banned words with single non-banned word"
      },
      {
        "input": "\"Bob. hIt, baLl, bob, ball, bAll, hit\"\n[\"bob\", \"hit\"]\n",
        "expectedOutput": "\"ball\"\n",
        "isHidden": true,
        "explanation": "Case insensitivity and punctuation test"
      }
    ],
    "hints": [
      "Convert paragraph to lowercase and remove punctuation",
      "Use regular expressions or character-by-character processing to extract words",
      "Count word frequencies while ignoring banned words",
      "Track the maximum frequency non-banned word",
      "Consider using collections.Counter in Python for efficient counting"
    ],
    "tags": ["array", "hash-table", "string", "counting"]
  },
  {
    "problemId": 8,
    "courseId": "amazon",
    "title": "Copy List with Random Pointer",
    "difficulty": "Medium",
    "description": "Construct a deep copy of a linked list where each node contains an additional random pointer that may point to any node in the list or null. The copy should consist of entirely new nodes with identical structure but no references to the original list.",
    "examples": [
      {
        "input": "[[7,null],[13,0],[11,4],[10,2],[1,0]]\n",
        "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]\n",
        "explanation": "The copied list maintains the same value and random pointer relationships as the original.\n"
      },
      {
        "input": "[[1,1],[2,1]]\n",
        "output": "[[1,1],[2,1]]\n",
        "explanation": "Both nodes' random pointers point to the second node in both original and copied lists.\n"
      },
      {
        "input": "[[3,null],[3,0],[3,null]]\n",
        "output": "[[3,null],[3,0],[3,null]]\n",
        "explanation": "Multiple nodes with same value but different random pointer relationships.\n"
      }
    ],
    "constraints": [
      "0 <= n <= 1000",
      "-10^4 <= Node.val <= 10^4",
      "Node.random is null or points to a node in the linked list"
    ],
    "testCases": [
      {
        "input": "[[7,null],[13,0],[11,4],[10,2],[1,0]]\n",
        "expectedOutput": "[[7,null],[13,0],[11,4],[10,2],[1,0]]\n"
      },
      {
        "input": "[[1,1],[2,1]]\n",
        "expectedOutput": "[[1,1],[2,1]]\n"
      },
      {
        "input": "[[3,null],[3,0],[3,null]]\n",
        "expectedOutput": "[[3,null],[3,0],[3,null]]\n"
      },
      {
        "input": "[]\n",
        "expectedOutput": "[]\n",
        "isHidden": true,
        "explanation": "Empty list case"
      },
      {
        "input": "[[0,null]]\n",
        "expectedOutput": "[[0,null]]\n",
        "isHidden": true,
        "explanation": "Single node with null random pointer"
      },
      {
        "input": "[[1,1],[2,0],[3,1],[4,2]]\n",
        "expectedOutput": "[[1,1],[2,0],[3,1],[4,2]]\n",
        "isHidden": true,
        "explanation": "Circular random pointer references"
      }
    ],
    "hints": [
      "Use a hash map to maintain original node to copy node mappings",
      "First pass: create copies of nodes without setting random pointers",
      "Second pass: use the hash map to set random pointers in the copied list",
      "Alternative approach: interweave original and copied nodes to avoid extra space",
      "For interweaving method, remember to separate the lists after setting random pointers"
    ],
    "tags": ["hash-table", "linked-list"]
  },
  {
    "problemId": 9,
    "courseId": "amazon",
    "title": "Longest Palindromic Substring",
    "difficulty": "Medium",
    "description": "Given a string s, return the longest substring that is a palindrome. A palindrome reads the same backward as forward. If there are multiple valid answers, return any one of them.",
    "examples": [
      {
        "input": "\"babad\"\n",
        "output": "\"bab\"\n",
        "explanation": "\"bab\" and \"aba\" are both valid palindromic substrings.\n"
      },
      {
        "input": "\"cbbd\"\n",
        "output": "\"bb\"\n",
        "explanation": "The longest palindromic substring is \"bb\".\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of only digits and English letters"
    ],
    "testCases": [
      {
        "input": "\"babad\"\n",
        "expectedOutput": "\"bab\"\n"
      },
      {
        "input": "\"cbbd\"\n",
        "expectedOutput": "\"bb\"\n"
      },
      {
        "input": "\"a\"\n",
        "expectedOutput": "\"a\"\n",
        "isHidden": true,
        "explanation": "Single character string is trivially a palindrome"
      },
      {
        "input": "\"racecar\"\n",
        "expectedOutput": "\"racecar\"\n",
        "isHidden": true,
        "explanation": "Entire string is a palindrome"
      },
      {
        "input": "\"abacdfgdcaba\"\n",
        "expectedOutput": "\"aba\"\n",
        "isHidden": true,
        "explanation": "Longest palindrome is at beginning/end, not in center"
      },
      {
        "input": "\"aaabaaaa\"\n",
        "expectedOutput": "\"aaabaaa\"\n",
        "isHidden": true,
        "explanation": "Asymmetric palindrome with longer left side"
      }
    ],
    "hints": [
      "Consider both odd-length and even-length palindromes",
      "Expand around center - check all possible centers (O(n^2) time with O(1) space)",
      "Dynamic programming approach can store palindrome information in a table",
      "Manacher's algorithm provides O(n) solution but is more complex",
      "For DP: P(i,j) = (P(i+1,j-1) AND (S_i == S_j)"
    ],
    "tags": ["two-pointers", "string", "dynamic-programming"]
  },
  {
    "problemId": 10,
    "courseId": "amazon",
    "title": "Rotting Oranges",
    "difficulty": "Medium",
    "description": "Given an m x n grid representing oranges (0=empty, 1=fresh, 2=rotten), return the minimum minutes until no fresh oranges remain. Each minute, fresh oranges adjacent (4-directionally) to rotten oranges become rotten. Return -1 if all oranges cannot rot.",
    "examples": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,1]]\n",
        "output": "4\n",
        "explanation": "Sequence of rotting takes 4 minutes to affect all oranges.\n"
      },
      {
        "input": "[[2,1,1],[0,1,1],[1,0,1]]\n",
        "output": "-1\n",
        "explanation": "Bottom-left orange can never rot due to positioning.\n"
      },
      {
        "input": "[[0,2]]\n",
        "output": "0\n",
        "explanation": "No fresh oranges to rot at minute 0.\n"
      }
    ],
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 10",
      "grid[i][j] ∈ {0, 1, 2}"
    ],
    "testCases": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,1]]\n",
        "expectedOutput": "4\n"
      },
      {
        "input": "[[2,1,1],[0,1,1],[1,0,1]]\n",
        "expectedOutput": "-1\n"
      },
      {
        "input": "[[0,2]]\n",
        "expectedOutput": "0\n"
      },
      {
        "input": "[[2,1,1],[1,1,1],[1,1,2]]\n",
        "expectedOutput": "2\n",
        "isHidden": true,
        "explanation": "Rotten oranges at both ends meeting in middle"
      },
      {
        "input": "[[1],[2],[1],[1],[1],[1],[1],[2],[1],[1]]\n",
        "expectedOutput": "5\n",
        "isHidden": true,
        "explanation": "Vertical grid with alternating fresh/rotten"
      },
      {
        "input": "[[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n",
        "expectedOutput": "4\n",
        "isHidden": true,
        "explanation": "Large grid with single rotten center"
      }
    ],
    "hints": [
      "Use BFS to simulate the rotting process minute by minute",
      "Initialize queue with all initially rotten oranges (time = 0)",
      "Track visited/fresh oranges to avoid reprocessing",
      "Count fresh oranges at start - if >0 after BFS, return -1",
      "Process all current rotten oranges before incrementing time"
    ],
    "tags": ["array", "breadth-first-search", "matrix"]
  },
  {
    "problemId": 11,
    "courseId": "amazon",
    "title": "Trapping Rain Water",
    "difficulty": "Hard",
    "description": "Given n non-negative integers representing an elevation map where each bar has width 1, compute how much water can be trapped between the bars after raining.",
    "examples": [
      {
        "input": "[0,1,0,2,1,0,1,3,2,1,2,1]\n",
        "output": "6\n",
        "explanation": "The elevation map traps 6 units of water between the bars.\n"
      },
      {
        "input": "[4,2,0,3,2,5]\n",
        "output": "9\n",
        "explanation": "The elevation map traps 9 units of water between the bars.\n"
      }
    ],
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "testCases": [
      {
        "input": "[0,1,0,2,1,0,1,3,2,1,2,1]\n",
        "expectedOutput": "6\n"
      },
      {
        "input": "[4,2,0,3,2,5]\n",
        "expectedOutput": "9\n"
      },
      {
        "input": "[3,0,2,0,4]\n",
        "expectedOutput": "7\n",
        "isHidden": true,
        "explanation": "Water trapped on both sides of the tallest bar"
      },
      {
        "input": "[2,0,2]\n",
        "expectedOutput": "2\n",
        "isHidden": true,
        "explanation": "Simple case with symmetric bars"
      },
      {
        "input": "[5,4,3,2,1]\n",
        "expectedOutput": "0\n",
        "isHidden": true,
        "explanation": "Descending heights trap no water"
      },
      {
        "input": "[1,2,3,4,5]\n",
        "expectedOutput": "0\n",
        "isHidden": true,
        "explanation": "Ascending heights trap no water"
      }
    ],
    "hints": [
      "Use two pointers to track the maximum heights from left and right",
      "The water trapped at any point depends on the minimum of the left and right maxima",
      "Dynamic programming approach can precompute left and right maxima arrays",
      "Stack-based approach can also solve this by tracking bars in decreasing order",
      "Visualize the water being trapped between 'walls' on either side"
    ],
    "tags": ["array", "two-pointers", "dynamic-programming", "stack", "monotonic-stack"]
  },
  {
    "problemId": 12,
    "courseId": "amazon",
    "title": "Merge k Sorted Lists",
    "difficulty": "Hard",
    "description": "Given an array of k sorted linked lists, merge all the linked-lists into one sorted linked-list and return it.",
    "examples": [
      {
        "input": "[[1,4,5],[1,3,4],[2,6]]\n",
        "output": "[1,1,2,3,4,4,5,6]\n",
        "explanation": "The merged sorted list combines all elements from the three input lists in order.\n"
      },
      {
        "input": "[]\n",
        "output": "[]\n",
        "explanation": "Empty input returns empty output.\n"
      },
      {
        "input": "[[]]\n",
        "output": "[]\n",
        "explanation": "Single empty list returns empty output.\n"
      }
    ],
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i][j] <= 10^4",
      "Each lists[i] is sorted in ascending order",
      "Total nodes across all lists <= 10^4"
    ],
    "testCases": [
      {
        "input": "[[1,4,5],[1,3,4],[2,6]]\n",
        "expectedOutput": "[1,1,2,3,4,4,5,6]\n"
      },
      {
        "input": "[]\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "[[]]\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "[[1,2,3],[4,5,6],[7,8,9]]\n",
        "expectedOutput": "[1,2,3,4,5,6,7,8,9]\n",
        "isHidden": true,
        "explanation": "Lists with non-overlapping ranges"
      },
      {
        "input": "[[1],[1]]\n",
        "expectedOutput": "[1,1]\n",
        "isHidden": true,
        "explanation": "Multiple lists with duplicate values"
      },
      {
        "input": "[[-5,-3,0],[1,2,4],[-4,-2,-1]]\n",
        "expectedOutput": "[-5,-4,-3,-2,-1,0,1,2,4]\n",
        "isHidden": true,
        "explanation": "Lists with negative and positive values"
      }
    ],
    "hints": [
      "Use a min-heap (priority queue) to efficiently get the next smallest element",
      "Initialize the heap with the first node of each non-empty list",
      "While the heap is not empty, extract the min node and add it to the result",
      "After extracting, add the next node from the same list to the heap",
      "Alternative approach: merge lists pairwise using merge-two-lists approach"
    ],
    "tags": ["linked-list", "divide-and-conquer", "heap", "priority-queue", "merge-sort"]
  },
  {
    "problemId": 13,
    "courseId": "amazon",
    "title": "Partition Labels",
    "difficulty": "Medium",
    "description": "Given a string s, partition it into as many parts as possible so that each letter appears in only one part. Return a list of integers representing the sizes of these partitions.",
    "examples": [
      {
        "input": "\"ababcbacadefegdehijhklij\"\n",
        "output": "[9,7,8]\n",
        "explanation": "The partitions are \"ababcbaca\", \"defegde\", and \"hijhklij\" where each letter appears in only one part.\n"
      },
      {
        "input": "\"eccbbbbdec\"\n",
        "output": "[10]\n",
        "explanation": "The entire string must be one partition as all letters are interconnected.\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 500",
      "s consists of lowercase English letters"
    ],
    "testCases": [
      {
        "input": "\"ababcbacadefegdehijhklij\"\n",
        "expectedOutput": "[9,7,8]\n"
      },
      {
        "input": "\"eccbbbbdec\"\n",
        "expectedOutput": "[10]\n"
      },
      {
        "input": "\"a\"\n",
        "expectedOutput": "[1]\n",
        "isHidden": true,
        "explanation": "Single character string forms a single partition"
      },
      {
        "input": "\"abcde\"\n",
        "expectedOutput": "[1,1,1,1,1]\n",
        "isHidden": true,
        "explanation": "All unique characters form individual partitions"
      },
      {
        "input": "\"aaaaa\"\n",
        "expectedOutput": "[5]\n",
        "isHidden": true,
        "explanation": "Single repeating character forms one partition"
      },
      {
        "input": "\"abacdc\"\n",
        "expectedOutput": "[4,2]\n",
        "isHidden": true,
        "explanation": "The 'a's and 'b's are interconnected but 'c's and 'd's form separate partitions"
      }
    ],
    "hints": [
      "First record the last occurrence index of each character",
      "Use two pointers to track the start and end of the current partition",
      "Expand the end pointer when you find characters with later last occurrences",
      "When the current index reaches the end pointer, you've found a partition",
      "The greedy approach of taking the maximum possible partition at each step works"
    ],
    "tags": ["hash-table", "two-pointers", "string", "greedy"]
  },
  {
    "problemId": 14,
    "courseId": "amazon",
    "title": "Add Two Numbers",
    "difficulty": "Medium",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each node contains a single digit. Add the two numbers and return the sum as a linked list (also in reverse order).",
    "examples": [
      {
        "input": "[2,4,3]\n[5,6,4]\n",
        "output": "[7,0,8]\n",
        "explanation": "342 + 465 = 807, which is represented as [7,0,8] in reverse order.\n"
      },
      {
        "input": "[0]\n[0]\n",
        "output": "[0]\n",
        "explanation": "0 + 0 = 0\n"
      },
      {
        "input": "[9,9,9,9,9,9,9]\n[9,9,9,9]\n",
        "output": "[8,9,9,9,0,0,0,1]\n",
        "explanation": "9999999 + 9999 = 10009998, represented in reverse order.\n"
      }
    ],
    "constraints": [
      "Number of nodes in each linked list: [1, 100]",
      "0 <= Node.val <= 9",
      "Lists represent numbers without leading zeros (except 0 itself)"
    ],
    "testCases": [
      {
        "input": "[2,4,3]\n[5,6,4]\n",
        "expectedOutput": "[7,0,8]\n"
      },
      {
        "input": "[0]\n[0]\n",
        "expectedOutput": "[0]\n"
      },
      {
        "input": "[9,9,9,9,9,9,9]\n[9,9,9,9]\n",
        "expectedOutput": "[8,9,9,9,0,0,0,1]\n"
      },
      {
        "input": "[1]\n[9,9,9]\n",
        "expectedOutput": "[0,0,0,1]\n",
        "isHidden": true,
        "explanation": "1 + 999 = 1000, with carry propagating through all digits"
      },
      {
        "input": "[5]\n[5]\n",
        "expectedOutput": "[0,1]\n",
        "isHidden": true,
        "explanation": "5 + 5 = 10, requiring a new digit for the carry"
      },
      {
        "input": "[1,2,3]\n[4,5,6]\n",
        "expectedOutput": "[5,7,9]\n",
        "isHidden": true,
        "explanation": "321 + 654 = 975, no carry operations needed"
      }
    ],
    "hints": [
      "Initialize a dummy head for the result linked list",
      "Traverse both lists simultaneously, adding corresponding digits",
      "Maintain a carry variable for sums >= 10",
      "Continue until both lists are exhausted and carry is 0",
      "Create new nodes for each digit of the sum"
    ],
    "tags": ["linked-list", "math", "recursion"]
  },
  {
    "problemId": 15,
    "courseId": "amazon",
    "title": "Valid Parentheses",
    "difficulty": "Easy",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. The string is valid if all brackets are properly closed in the correct order.",
    "examples": [
      {
        "input": "\"()\"\n",
        "output": "true\n",
        "explanation": "Simple pair of parentheses is valid.\n"
      },
      {
        "input": "\"()[]{}\"\n",
        "output": "true\n",
        "explanation": "Multiple types of brackets in correct order are valid.\n"
      },
      {
        "input": "\"(]\"\n",
        "output": "false\n",
        "explanation": "Mismatched bracket types are invalid.\n"
      },
      {
        "input": "\"([)]\"\n",
        "output": "false\n",
        "explanation": "Incorrect nesting order makes this invalid.\n"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists only of '()[]{}'"
    ],
    "testCases": [
      {
        "input": "\"()\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "\"()[]{}\"\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "\"(]\"\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "\"([)]\"\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "\"{[]}\"\n",
        "expectedOutput": "true\n",
        "isHidden": true,
        "explanation": "Properly nested different bracket types are valid"
      },
      {
        "input": "\"((()))\"\n",
        "expectedOutput": "false\n",
        "isHidden": true,
        "explanation": "Unbalanced number of opening/closing parentheses"
      },
      {
        "input": "\"\"\n",
        "expectedOutput": "true\n",
        "isHidden": true,
        "explanation": "Empty string is considered valid"
      }
    ],
    "hints": [
      "Use a stack data structure to track opening brackets",
      "When encountering a closing bracket, check if it matches the top of the stack",
      "The string is invalid if the stack isn't empty after processing all characters",
      "Immediately return false if a closing bracket doesn't match the stack's top",
      "Consider edge cases like empty string and single-character strings"
    ],
    "tags": ["string", "stack"]
  },
  {
    "problemId": 16,
    "courseId": "amazon",
    "title": "Merge Two Sorted Lists",
    "difficulty": "Easy",
    "description": "Given the heads of two sorted linked lists, merge them into one sorted list by splicing together the nodes. Return the head of the merged linked list.",
    "examples": [
      {
        "input": "[1,2,4]\n[1,3,4]\n",
        "output": "[1,1,2,3,4,4]\n",
        "explanation": "The lists are merged by interleaving nodes in sorted order.\n"
      },
      {
        "input": "[]\n[]\n",
        "output": "[]\n",
        "explanation": "Two empty lists merge into an empty list.\n"
      },
      {
        "input": "[]\n[0]\n",
        "output": "[0]\n",
        "explanation": "Merging empty list with non-empty list returns the non-empty list.\n"
      }
    ],
    "constraints": [
      "Number of nodes in both lists: [0, 50]",
      "-100 <= Node.val <= 100",
      "Both lists are sorted in non-decreasing order"
    ],
    "testCases": [
      {
        "input": "[1,2,4]\n[1,3,4]\n",
        "expectedOutput": "[1,1,2,3,4,4]\n"
      },
      {
        "input": "[]\n[]\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "[]\n[0]\n",
        "expectedOutput": "[0]\n"
      },
      {
        "input": "[5]\n[1,2,3,4,6]\n",
        "expectedOutput": "[1,2,3,4,5,6]\n",
        "isHidden": true,
        "explanation": "Single-node list merged into longer list"
      },
      {
        "input": "[1,3,5]\n[2,4,6]\n",
        "expectedOutput": "[1,2,3,4,5,6]\n",
        "isHidden": true,
        "explanation": "Perfectly interleaved lists"
      },
      {
        "input": "[-5,0,5]\n[-10,10]\n",
        "expectedOutput": "[-10,-5,0,5,10]\n",
        "isHidden": true,
        "explanation": "Lists with negative and positive values"
      }
    ],
    "hints": [
      "Use a dummy node to simplify handling the merged list's head",
      "Compare nodes from both lists and attach the smaller one",
      "When one list is exhausted, attach the remainder of the other list",
      "Can be solved iteratively or recursively",
      "No need to create new nodes - just rearrange pointers"
    ],
    "tags": ["linked-list", "recursion"]
  },
  {
    "problemId": 17,
    "courseId": "amazon",
    "title": "Word Ladder",
    "difficulty": "Hard",
    "description": "Given a beginWord, endWord, and a dictionary wordList, find the length of the shortest transformation sequence from beginWord to endWord where each adjacent word differs by exactly one character and all intermediate words are in wordList. Return 0 if no such sequence exists.",
    "examples": [
      {
        "input": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n",
        "output": "5\n",
        "explanation": "Shortest path: \"hit\" → \"hot\" → \"dot\" → \"dog\" → \"cog\" (5 words)\n"
      },
      {
        "input": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n",
        "output": "0\n",
        "explanation": "No valid path since \"cog\" is missing from wordList\n"
      }
    ],
    "constraints": [
      "1 <= beginWord.length <= 10",
      "endWord.length == beginWord.length",
      "1 <= wordList.length <= 5000",
      "All words are of same length",
      "All words consist of lowercase English letters",
      "beginWord != endWord",
      "All words in wordList are unique"
    ],
    "testCases": [
      {
        "input": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n",
        "expectedOutput": "5\n"
      },
      {
        "input": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n",
        "expectedOutput": "0\n"
      },
      {
        "input": "\"hot\"\n\"dog\"\n[\"hot\",\"dog\"]\n",
        "expectedOutput": "0\n",
        "isHidden": true,
        "explanation": "No possible single-step transformation"
      },
      {
        "input": "\"a\"\n\"c\"\n[\"a\",\"b\",\"c\"]\n",
        "expectedOutput": "2\n",
        "isHidden": true,
        "explanation": "Single character transformation path"
      },
      {
        "input": "\"red\"\n\"tax\"\n[\"ted\",\"tex\",\"tad\",\"tax\"]\n",
        "expectedOutput": "4\n",
        "isHidden": true,
        "explanation": "Multiple possible paths with same minimum length"
      }
    ],
    "hints": [
      "Model this as a graph problem where words are nodes and edges exist between words that differ by one character",
      "Use BFS to find the shortest path from beginWord to endWord",
      "Preprocess wordList to create a map of generic patterns to actual words",
      "For each word, generate all possible patterns by replacing each character with '*'",
      "Track visited words to avoid cycles and redundant processing"
    ],
    "tags": ["hash-table", "string", "breadth-first-search"]
  },
  {
    "problemId": 18,
    "courseId": "amazon",
    "title": "Find Median from Data Stream",
    "difficulty": "Hard",
    "description": "Implement a data structure that supports adding numbers from a stream and finding the median of all numbers added so far. The median is the middle value in an ordered list, or the average of two middle values for even-length lists.",
    "examples": [
      {
        "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]",
        "output": "[null, null, null, 1.5, null, 2.0]",
        "explanation": "After adding 1 and 2, median is (1+2)/2 = 1.5. After adding 3, median is 2 (middle value)."
      }
    ],
    "constraints": [
      "-10^5 <= num <= 10^5",
      "At least one element exists before calling findMedian",
      "At most 5 * 10^4 total calls to addNum and findMedian"
    ],
    "testCases": [
      {
        "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]",
        "expectedOutput": "[null, null, null, 1.5, null, 2.0]"
      },
      {
        "input": "[\"MedianFinder\", \"addNum\", \"findMedian\"]\n[[], [5], []]",
        "expectedOutput": "[null, null, 5.0]",
        "isHidden": true,
        "explanation": "Single element median"
      },
      {
        "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"addNum\", \"addNum\", \"findMedian\"]\n[[], [-1], [-2], [-3], [-4], []]",
        "expectedOutput": "[null, null, null, null, null, -2.5]",
        "isHidden": true,
        "explanation": "Negative numbers and even count median"
      },
      {
        "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], [], [4], []]",
        "expectedOutput": "[null, null, null, 1.5, null, 2.0, null, 2.5]",
        "isHidden": true,
        "explanation": "Growing sequence with changing median"
      }
    ],
    "hints": [
      "Use two heaps: a max-heap for the lower half and min-heap for the upper half of numbers",
      "Maintain balance between heaps so their sizes differ by at most 1",
      "The median is either the top of the larger heap or the average of both tops",
      "For addNum: compare with heap tops to decide where to insert, then rebalance",
      "For follow-up: consider counting sort if numbers have limited range"
    ],
    "tags": ["two-pointers", "design", "sorting", "heap", "priority-queue", "data-stream"],
    "followUp": [
      "If all numbers are in [0,100], how would you optimize?",
      "If 99% of numbers are in [0,100], how would you optimize?"
    ]
  },
  {
    "problemId": 19,
    "courseId": "amazon",
    "title": "Serialize and Deserialize Binary Tree",
    "difficulty": "Hard",
    "description": "Design an algorithm to serialize and deserialize a binary tree. Serialization is converting a tree into a string representation, and deserialization is reconstructing the tree from that string.",
    "examples": [
      {
        "input": "[1,2,3,null,null,4,5]",
        "output": "[1,2,3,null,null,4,5]",
        "explanation": "The tree should be serialized to a string and then correctly reconstructed."
      },
      {
        "input": "[]",
        "output": "[]",
        "explanation": "Empty tree should serialize to empty string and deserialize back to empty tree."
      }
    ],
    "constraints": [
      "Number of nodes in the tree: [0, 10^4]",
      "Node values: [-1000, 1000]"
    ],
    "testCases": [
      {
        "input": "[1,2,3,null,null,4,5]",
        "expectedOutput": "[1,2,3,null,null,4,5]"
      },
      {
        "input": "[]",
        "expectedOutput": "[]"
      },
      {
        "input": "[1,null,2,null,3,null,4]",
        "expectedOutput": "[1,null,2,null,3,null,4]",
        "isHidden": true,
        "explanation": "Right-skewed tree should serialize/deserialize correctly"
      },
      {
        "input": "[1,2,null,3,null,4,null,5]",
        "expectedOutput": "[1,2,null,3,null,4,null,5]",
        "isHidden": true,
        "explanation": "Left-skewed tree should serialize/deserialize correctly"
      },
      {
        "input": "[5,3,6,2,4,null,null,1]",
        "expectedOutput": "[5,3,6,2,4,null,null,1]",
        "isHidden": true,
        "explanation": "Complex tree structure should be preserved"
      }
    ],
    "hints": [
      "Consider using pre-order traversal with markers for null nodes",
      "You can use DFS (pre-order) or BFS for serialization",
      "For deserialization, rebuild the tree using the same traversal order used for serialization",
      "String splitting and queue/stack can help with parsing during deserialization",
      "Remember to handle edge cases like empty tree and single node tree"
    ],
    "tags": ["string", "tree", "depth-first-search", "breadth-first-search", "design", "binary-tree"]
  },
  {
    "problemId": 20,
    "courseId": "amazon",
    "title": "Top K Frequent Words",
    "difficulty": "Medium",
    "description": "Given an array of strings words and an integer k, return the k most frequent strings. The answer should be sorted by frequency (highest first) and words with the same frequency should be sorted lexicographically.",
    "examples": [
      {
        "input": "[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"]\n2\n",
        "output": "[\"i\",\"love\"]\n",
        "explanation": "\"i\" and \"love\" are the two most frequent words. \"i\" comes before \"love\" alphabetically.\n"
      },
      {
        "input": "[\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"]\n4\n",
        "output": "[\"the\",\"is\",\"sunny\",\"day\"]\n",
        "explanation": "\"the\" (4), \"is\" (3), \"sunny\" (2), and \"day\" (1) are the four most frequent words.\n"
      }
    ],
    "constraints": [
      "1 <= words.length <= 500",
      "1 <= words[i].length <= 10",
      "words[i] consists of lowercase English letters",
      "1 <= k <= number of unique words"
    ],
    "testCases": [
      {
        "input": "[\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"]\n2\n",
        "expectedOutput": "[\"i\",\"love\"]\n"
      },
      {
        "input": "[\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"]\n4\n",
        "expectedOutput": "[\"the\",\"is\",\"sunny\",\"day\"]\n"
      },
      {
        "input": "[\"a\",\"aa\",\"aaa\",\"aaaa\"]\n1\n",
        "expectedOutput": "[\"a\"]\n",
        "isHidden": true,
        "explanation": "All words are unique, so the shortest one comes first alphabetically.\n"
      },
      {
        "input": "[\"python\",\"java\",\"python\",\"java\",\"python\",\"c++\"]\n2\n",
        "expectedOutput": "[\"python\",\"java\"]\n",
        "isHidden": true,
        "explanation": "Both have same frequency, sorted alphabetically.\n"
      },
      {
        "input": "[\"single\"]\n1\n",
        "expectedOutput": "[\"single\"]\n",
        "isHidden": true,
        "explanation": "Single word case.\n"
      }
    ],
    "hints": [
      "First count word frequencies using a hash map",
      "Use a priority queue (min-heap) of size k to track top k elements",
      "Custom comparator should sort by frequency (descending) then lexicographical order (ascending)",
      "For the follow-up: heap operations take O(log k) time, giving O(n log k) total",
      "Alternative approach: bucket sort by frequency then sort each bucket alphabetically"
    ],
    "tags": ["array", "hash-table", "string", "trie", "sorting", "heap", "priority-queue", "bucket-sort", "counting"],
    "followUp": "Could you solve it in O(n log(k)) time and O(n) extra space?"
  },
  {
    "problemId": 21,
    "courseId": "amazon",
    "title": "Subtree of Another Tree",
    "difficulty": "Easy",
    "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\n\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.",
    "examples": [
      {
        "input": "root = [3,4,5,1,2], subRoot = [4,1,2]\n",
        "output": "true\n",
        "explanation": "The subtree [4,1,2] is present in the main tree.\n"
      },
      {
        "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n",
        "output": "false\n",
        "explanation": "Although the values match, the structure of the subtree [4,1,2] is not present in the main tree.\n"
      }
    ],
    "constraints": [
      "The number of nodes in the root tree is in the range [1, 2000].",
      "The number of nodes in the subRoot tree is in the range [1, 1000].",
      "-104 <= root.val <= 104",
      "-104 <= subRoot.val <= 104"
    ],
    "testCases": [
      {
        "input": "root = [3,4,5,1,2], subRoot = [4,1,2]\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "root = [1,1], subRoot = [1]\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "root = [1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,2], subRoot = [1,null,1,null,1,null,1,null,1,null,1,2]\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "root = [1,2,3], subRoot = [4]\n",
        "expectedOutput": "false\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Which approach is better here- recursive or iterative?",
      "If recursive approach is better, can you write recursive function with its parameters?",
      "Two trees s and t are said to be identical if their root values are same and their left and right subtrees are identical. Can you write this in form of recursive formulae?",
      "Recursive formulae can be: isIdentical(s,t)= s.val==t.val AND isIdentical(s.left,t.left) AND isIdentical(s.right,t.right)"
    ],
    "tags": ["Tree", "Depth-First Search", "String Matching", "Binary Tree", "Hash Function"]
  },
  {
    "problemId": 22,
    "courseId": "amazon",
    "title": "Search a 2D Matrix II",
    "difficulty": "Medium",
    "description": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\nIntegers in each row are sorted in ascending from left to right.\nIntegers in each column are sorted in ascending from top to bottom.",
    "examples": [
      {
        "input": "matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n",
        "output": "true\n",
        "explanation": "The target value 5 exists in the matrix.\n"
      },
      {
        "input": "matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n",
        "output": "false\n",
        "explanation": "The target value 20 does not exist in the matrix.\n"
      }
    ],
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= n, m <= 300",
      "-109 <= matrix[i][j] <= 109",
      "All the integers in each row are sorted in ascending order.",
      "All the integers in each column are sorted in ascending order.",
      "-109 <= target <= 109"
    ],
    "testCases": [
      {
        "input": "matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n",
        "expectedOutput": "true\n"
      },
      {
        "input": "matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n",
        "expectedOutput": "false\n"
      },
      {
        "input": "matrix = [[-1,3]], target = 3\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "matrix = [[-5]], target = -5\n",
        "expectedOutput": "true\n",
        "isHidden": true
      },
      {
        "input": "matrix = [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]], target = 15\n",
        "expectedOutput": "true\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Consider the properties of the matrix.",
      "Can you eliminate a row or column in each iteration?",
      "Start searching from the top-right corner of the matrix."
    ],
    "tags": ["Array", "Binary Search", "Divide and Conquer", "Matrix"]
  },
  {
    "problemId": 23,
    "courseId": "amazon",
    "title": "Word Ladder II",
    "difficulty": "Hard",
    "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].",
    "examples": [
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n",
        "output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\n",
        "explanation": "There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\n"
      },
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n",
        "output": "[]\n",
        "explanation": "The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n"
      }
    ],
    "constraints": [
      "1 <= beginWord.length <= 5",
      "endWord.length == beginWord.length",
      "1 <= wordList.length <= 500",
      "wordList[i].length == beginWord.length",
      "beginWord, endWord, and wordList[i] consist of lowercase English letters.",
      "beginWord != endWord",
      "All the words in wordList are unique.",
      "The sum of all shortest transformation sequences does not exceed 105."
    ],
    "testCases": [
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n",
        "expectedOutput": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\n"
      },
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "beginWord = \"a\", endWord = \"c\", wordList = [\"a\",\"b\",\"c\"]\n",
        "expectedOutput": "[[\"a\",\"c\"]]\n",
        "isHidden": true
      },
      {
        "input": "beginWord = \"red\", endWord = \"tax\", wordList = [\"ted\",\"tex\",\"red\",\"tax\",\"tad\",\"den\",\"rex\",\"pee\"]\n",
        "expectedOutput": "[[\"red\",\"ted\",\"tex\",\"tax\"]]\n",
        "isHidden": true
      },
      {
        "input": "beginWord = \"qa\", endWord = \"sq\", wordList = [\"si\",\"go\",\"se\",\"cm\",\"so\",\"ph\",\"mt\",\"db\",\"mb\",\"sb\",\"kr\",\"ln\",\"tm\",\"le\",\"av\",\"sm\",\"ar\",\"ca\",\"sr\",\"pc\",\"uk\",\"er\",\"md\",\"bi\",\"te\",\"lc\",\"br\",\"pr\",\"tm\",\"rs\",\"rf\",\"ud\",\"lp\",\"wg\",\"fm\",\"io\",\"hm\",\"py\",\"la\",\"lb\",\"ac\",\"dm\",\"ls\",\"pt\",\"um\",\"sq\",\"mc\",\"pb\",\"rg\",\"to\",\"bb\"]\n",
        "expectedOutput": "[[\"qa\",\"si\",\"so\",\"sq\"]]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use Breadth-First Search (BFS) to find the shortest paths.",
      "Keep track of the paths that lead to the endWord.",
      "Use a dictionary to store the predecessors of each word in the shortest paths."
    ],
    "tags": ["Hash Table", "String", "Backtracking", "Breadth-First Search"]
  },
  {
    "problemId": 24,
    "courseId": "amazon",
    "title": "Concatenated Words",
    "difficulty": "Hard",
    "description": "Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.",
    "examples": [
      {
        "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n",
        "output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n",
        "explanation": "\"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n"
      },
      {
        "input": "words = [\"cat\",\"dog\",\"catdog\"]\n",
        "output": "[\"catdog\"]\n",
        "explanation": "catdog is a concatenation of cat and dog\n"
      }
    ],
    "constraints": [
      "1 <= words.length <= 104",
      "1 <= words[i].length <= 30",
      "words[i] consists of only lowercase English letters.",
      "All the strings of words are unique.",
      "1 <= sum(words[i].length) <= 105"
    ],
    "testCases": [
      {
        "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n",
        "expectedOutput": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n"
      },
      {
        "input": "words = [\"cat\",\"dog\",\"catdog\"]\n",
        "expectedOutput": "[\"catdog\"]\n"
      },
      {
        "input": "words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n",
        "expectedOutput": "[\"aa\",\"aaa\",\"aaaa\"]\n",
        "isHidden": true
      },
      {
        "input": "words = [\"abcd\",\"ab\",\"cd\",\"abc\",\"d\"]\n",
        "expectedOutput": "[\"abcd\"]\n",
        "isHidden": true
      }
  
    ],
    "hints": [
      "Sort the words by their length.",
      "Use dynamic programming to check if a word can be formed by concatenating other words.",
      "Use a set to store the words that have already been seen."
    ],
    "tags": ["Array", "String", "Dynamic Programming", "Depth-First Search", "Trie"]
  },
  {
    "problemId": 25,
    "courseId": "amazon",
    "title": "Prison Cells After N Days",
    "difficulty": "Medium",
    "description": "There are 8 prison cells in a row and each cell is either occupied or vacant.\nEach day, whether the cell is occupied or vacant changes according to the following rules:\nIf a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.\nOtherwise, it becomes vacant.\nNote that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.\nYou are given an integer array cells where cells[i] == 1 if the ith cell is occupied and cells[i] == 0 if the ith cell is vacant, and you are given an integer n.\nReturn the state of the prison after n days (i.e., n such changes described above).",
    "examples": [
      {
        "input": "cells = [0,1,0,1,1,0,0,1], n = 7\n",
        "output": "[0,0,1,1,0,0,0,0]\n",
        "explanation": "The following table summarizes the state of the prison on each day:\nDay 0: [0, 1, 0, 1, 1, 0, 0, 1]\nDay 1: [0, 1, 1, 0, 0, 0, 0, 0]\nDay 2: [0, 0, 0, 0, 1, 1, 1, 0]\nDay 3: [0, 1, 1, 0, 0, 1, 0, 0]\nDay 4: [0, 0, 0, 0, 0, 1, 0, 0]\nDay 5: [0, 1, 1, 1, 0, 1, 0, 0]\nDay 6: [0, 0, 1, 0, 1, 1, 0, 0]\nDay 7: [0, 0, 1, 1, 0, 0, 0, 0]\n"
      },
      {
        "input": "cells = [1,0,0,1,0,0,1,0], n = 1000000000\n",
        "output": "[0,0,1,1,1,1,1,0]\n",
        "explanation": "After a large number of days, the pattern repeats.\n"
      }
    ],
    "constraints": [
      "cells.length == 8",
      "cells[i] is either 0 or 1.",
      "1 <= n <= 109"
    ],
    "testCases": [
      {
        "input": "cells = [0,1,0,1,1,0,0,1], n = 7\n",
        "expectedOutput": "[0,0,1,1,0,0,0,0]\n"
      },
      {
        "input": "cells = [1,0,0,1,0,0,1,0], n = 1000000000\n",
        "expectedOutput": "[0,0,1,1,1,1,1,0]\n"
      },
      {
        "input": "cells = [0,0,0,1,1,0,1,0], n = 1\n",
        "expectedOutput": "[0,1,0,0,0,1,0,0]\n",
        "isHidden": true
      },
      {
        "input": "cells = [0,1,1,1,0,0,0,1], n = 100\n",
        "expectedOutput": "[0,1,1,1,1,0,1,0]\n",
        "isHidden": true
      },
      {
        "input": "cells = [1,1,0,0,1,0,1,0], n = 1000000\n",
        "expectedOutput": "[0,0,1,1,1,0,0,0]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Simulate the changes for each day.",
      "Notice that the pattern repeats after a certain number of days.",
      "Use a hash table to store the states of the cells and detect the cycle."
    ],
    "tags": ["Array", "Hash Table", "Math", "Bit Manipulation"]
  },
  {
    "problemId": 26,
    "courseId": "amazon",
    "title": "Integer to English Words",
    "difficulty": "Hard",
    "description": "Convert a non-negative integer num to its English words representation.",
    "examples": [
      {
        "input": "num = 123\n",
        "output": "One Hundred Twenty Three\n",
        "explanation": "123 is converted into \"One Hundred Twenty Three\".\n"
      },
      {
        "input": "num = 12345\n",
        "output": "Twelve Thousand Three Hundred Forty Five\n",
        "explanation": "12345 is converted into \"Twelve Thousand Three Hundred Forty Five\".\n"
      },
      {
        "input": "num = 1234567\n",
        "output": "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\n",
        "explanation": "1234567 is converted into \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\".\n"
      }
    ],
    "constraints": [
      "0 <= num <= 231 - 1"
    ],
    "testCases": [
      {
        "input": "num = 123\n",
        "expectedOutput": "One Hundred Twenty Three\n"
      },
      {
        "input": "num = 12345\n",
        "expectedOutput": "Twelve Thousand Three Hundred Forty Five\n"
      },
      {
        "input": "num = 1234567\n",
        "expectedOutput": "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\n"
      },
      {
        "input": "num = 0\n",
        "expectedOutput": "Zero\n",
        "isHidden": true
      },
      {
        "input": "num = 1000010\n",
        "expectedOutput": "One Million Ten\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000.",
      "Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words.",
      "There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out)"
    ],
    "tags": ["Math", "String", "Recursion"]
  },
  {
    "problemId": 27,
    "courseId": "amazon",
    "title": "Median of Two Sorted Arrays",
    "difficulty": "Hard",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
    "examples": [
      {
        "input": "nums1 = [1,3], nums2 = [2]\n",
        "output": "2.00000\n",
        "explanation": "merged array = [1,2,3] and median is 2.\n"
      },
      {
        "input": "nums1 = [1,2], nums2 = [3,4]\n",
        "output": "2.50000\n",
        "explanation": "merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n"
      }
    ],
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-106 <= nums1[i], nums2[i] <= 106"
    ],
    "testCases": [
      {
        "input": "nums1 = [1,3], nums2 = [2]\n",
        "expectedOutput": "2.00000\n"
      },
      {
        "input": "nums1 = [1,2], nums2 = [3,4]\n",
        "expectedOutput": "2.50000\n"
      },
      {
        "input": "nums1 = [0,0], nums2 = [0,0]\n",
        "expectedOutput": "0.00000\n",
        "isHidden": true
      },
      {
        "input": "nums1 = [], nums2 = [1]\n",
        "expectedOutput": "1.00000\n",
        "isHidden": true
      },
      {
        "input": "nums1 = [2], nums2 = []\n",
        "expectedOutput": "2.00000\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Can you solve it in linear time? O(m + n)?",
      "Remember the median definition.",
      "Try to cut the half of one array.",
      "Can you merge two arrays in a sorted way?",
      "Try binary search. Divide and Conquer."
    ],
    "tags": ["Array", "Binary Search", "Divide and Conquer"]
  },
  {
    "problemId": 28,
    "courseId": "amazon",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "description": "Given a string s, find the length of the longest substring without duplicate characters.",
    "examples": [
      {
        "input": "s = \"abcabcbb\"\n",
        "output": "3\n",
        "explanation": "The answer is \"abc\", with the length of 3.\n"
      },
      {
        "input": "s = \"bbbbb\"\n",
        "output": "1\n",
        "explanation": "The answer is \"b\", with the length of 1.\n"
      },
      {
        "input": "s = \"pwwkew\"\n",
        "output": "3\n",
        "explanation": "The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n"
      }
    ],
    "constraints": [
      "0 <= s.length <= 5 * 104",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "testCases": [
      {
        "input": "s = \"abcabcbb\"\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "s = \"bbbbb\"\n",
        "expectedOutput": "1\n"
      },
      {
        "input": "s = \"pwwkew\"\n",
        "expectedOutput": "3\n"
      },
      {
        "input": "s = \" \"\n",
        "expectedOutput": "1\n",
        "isHidden": true
      },
      {
        "input": "s = \"au\"\n",
        "expectedOutput": "2\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly."
    ],
    "tags": ["Hash Table", "String", "Sliding Window"]
  },
  {
    "problemId": 29,
    "courseId": "amazon",
    "title": "Letter Combinations of a Phone Number",
    "difficulty": "Medium",
    "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
    "examples": [
      {
        "input": "digits = \"23\"\n",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n",
        "explanation": "2 maps to \"abc\", 3 maps to \"def\". All combinations are returned.\n"
      },
      {
        "input": "digits = \"\"\n",
        "output": "[]\n",
        "explanation": "No digits, no combinations.\n"
      },
      {
        "input": "digits = \"2\"\n",
        "output": "[\"a\",\"b\",\"c\"]\n",
        "explanation": "2 maps to \"abc\".\n"
      }
    ],
    "constraints": [
      "0 <= digits.length <= 4",
      "digits[i] is a digit in the range ['2', '9']."
    ],
    "testCases": [
      {
        "input": "digits = \"23\"\n",
        "expectedOutput": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n"
      },
      {
        "input": "digits = \"\"\n",
        "expectedOutput": "[]\n"
      },
      {
        "input": "digits = \"2\"\n",
        "expectedOutput": "[\"a\",\"b\",\"c\"]\n"
      },
      {
        "input": "digits = \"78\"\n",
        "expectedOutput": "[\"pt\",\"pu\",\"pv\",\"qt\",\"qu\",\"qv\",\"rt\",\"ru\",\"rv\",\"st\",\"su\",\"sv\"]\n",
        "isHidden": true
      },
      {
        "input": "digits = \"9\"\n",
        "expectedOutput": "[\"w\",\"x\",\"y\",\"z\"]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Use a hash table to map digits to letters.",
      "Use backtracking to generate all possible combinations."
    ],
    "tags": ["Hash Table", "String", "Backtracking"]
  },
  {
    "problemId": 30,
    "courseId": "amazon",
    "title": "Product of Array Except Self",
    "difficulty": "Medium",
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
    "examples": [
      {
        "input": "nums = [1,2,3,4]\n",
        "output": "[24,12,8,6]\n",
        "explanation": "answer[0] = 2 * 3 * 4 = 24, answer[1] = 1 * 3 * 4 = 12, answer[2] = 1 * 2 * 4 = 8, answer[3] = 1 * 2 * 3 = 6.\n"
      },
      {
        "input": "nums = [-1,1,0,-3,3]\n",
        "output": "[0,0,9,0,0]\n",
        "explanation": "answer[0] = 1 * 0 * -3 * 3 = 0, answer[1] = -1 * 0 * -3 * 3 = 0, answer[2] = -1 * 1 * -3 * 3 = 9, answer[3] = -1 * 1 * 0 * 3 = 0, answer[4] = -1 * 1 * 0 * -3 = 0.\n"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 105",
      "-30 <= nums[i] <= 30",
      "The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer."
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3,4]\n",
        "expectedOutput": "[24,12,8,6]\n"
      },
      {
        "input": "nums = [-1,1,0,-3,3]\n",
        "expectedOutput": "[0,0,9,0,0]\n"
      },
      {
        "input": "nums = [0,4,0]\n",
        "expectedOutput": "[0,0,0]\n",
        "isHidden": true
      },
      {
        "input": "nums = [1,0]\n",
        "expectedOutput": "[0,1]\n",
        "isHidden": true
      },
      {
        "input": "nums = [-1,1]\n",
        "expectedOutput": "[1,-1]\n",
        "isHidden": true
      }
    ],
    "hints": [
      "Think how you can efficiently utilize prefix and suffix products to calculate the product of all elements except self for each index. Can you pre-compute the prefix and suffix products in linear time to avoid redundant calculations?",
      "Can you minimize additional space usage by reusing memory or modifying the input array to store intermediate results?"
    ],
    "tags": ["Array", "Prefix Sum"]
  }
] 