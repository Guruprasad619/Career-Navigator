[
     {
        "problemId": 1,
        "courseId": "google",
        "title": "Longest Absolute File Path",
        "difficulty": "Medium",
        "description": "Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:\n\nHere, we have dir as the only directory in the root. dir contains two subdirectories, subdir1 and subdir2. subdir1 contains a file file1.ext and subdirectory subsubdir1. subdir2 contains a subdirectory subsubdir2, which contains a file file2.ext.\n\nIn text form, it looks like this (with ⟶ representing the tab character):\ndir\n⟶ subdir1\n⟶ ⟶ file1.ext\n⟶ ⟶ subsubdir1\n⟶ subdir2\n⟶ ⟶ subsubdir2\n⟶ ⟶ ⟶ file2.ext\n\nIf we were to write this representation in code, it will look like this: \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\". Note that the '\\n' and '\\t' are the new-line and tab characters.\n\nEvery file and directory has a unique absolute path in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by '/'s. Using the above example, the absolute path to file2.ext is \"dir/subdir2/subsubdir2/file2.ext\". Each directory name consists of letters, digits, and/or spaces. Each file name is of the form name.extension, where name and extension consist of letters, digits, and/or spaces.\n\nGiven a string input representing the file system in the explained format, return the length of the longest absolute path to a file in the abstracted file system. If there is no file in the system, return 0.\n\nNote that the testcases are generated such that the file system is valid and no file or directory name has length 0.",
        "examples": [
          {
            "input": "input = \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"",
            "output": "20",
            "explanation": "We have only one file, and the absolute path is \"dir/subdir2/file.ext\" of length 20."
          },
          {
            "input": "input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"",
            "output": "32",
            "explanation": "We have two files:\n\"dir/subdir1/file1.ext\" of length 21\n\"dir/subdir2/subsubdir2/file2.ext\" of length 32.\nWe return 32 since it is the longest absolute path to a file."
          },
          {
            "input": "input = \"a\"",
            "output": "0",
            "explanation": "We do not have any files, just a single directory named \"a\"."
          }
        ],
        "constraints": [
          "1 <= input.length <= 10^4",
          "input may contain lowercase or uppercase English letters, a new line character '\\n', a tab character '\\t', a dot '.', a space ' ', and digits.",
          "All file and directory names have positive length."
        ],
        "testCases": [
          {
            "input": "input = \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"",
            "expectedOutput": "20"
          },
          {
            "input": "input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"",
            "expectedOutput": "32"
          },
          {
            "input": "input = \"a\"",
            "expectedOutput": "0"
          },
          {
            "input": "input = \"dir\\n\\tfile.txt\"",
            "expectedOutput": "12"
          },
          {
            "input": "input = \"file.txt\"",
            "expectedOutput": "8"
          },
          {
            "input": "input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\tsubdir2\\n\\t\\tfile2.ext\\n\\t\\tsubdir3\\n\\t\\t\\tfile3.ext\"",
            "expectedOutput": "32"
          }
        ],
        "hints": [
          "Split the input string by newline characters.",
          "Use a stack to keep track of the current path length.",
          "For each line, determine the level of indentation by counting the number of tab characters.",
          "If the line represents a file, calculate the absolute path length and update the maximum length if necessary.",
          "If the line represents a directory, update the stack with the current directory name length."
        ],
        "tags": ["String", "Stack", "Depth-First Search"]
      },
      {
        "problemId": 2,
        "courseId": "google",
        "title": "Unique Email Addresses",
        "difficulty": "Easy",
        "description": "Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.\n\nFor example, in \"alice@leetcode.com\", \"alice\" is the local name, and \"leetcode.com\" is the domain name.\n\nIf you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\n\nFor example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\n\nIf you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\n\nFor example, \"m.y+name@email.com\" will be forwarded to \"my@email.com\".\n\nIt is possible to use both of these rules at the same time.\n\nGiven an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.",
        "examples": [
          {
            "input": "emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]",
            "output": "2",
            "explanation": "\"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails."
          },
          {
            "input": "emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]",
            "output": "3"
          }
        ],
        "constraints": [
          "1 <= emails.length <= 100",
          "1 <= emails[i].length <= 100",
          "emails[i] consist of lowercase English letters, '+', '.' and '@'.",
          "Each emails[i] contains exactly one '@' character.",
          "All local and domain names are non-empty.",
          "Local names do not start with a '+' character.",
          "Domain names end with the \".com\" suffix.",
          "Domain names must contain at least one character before \".com\" suffix."
        ],
        "testCases": [
          {
            "input": "emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]",
            "expectedOutput": "2"
          },
          {
            "input": "emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]",
            "expectedOutput": "3"
          },
          {
            "input": "emails = [\"test.email@leetcode.com\",\"testemail@leetcode.com\"]",
            "expectedOutput": "1"
          },
          {
              "input": "emails = [\"test.email+alex@leetcode.com\",\"testemail@leetcode.com\"]",
              "expectedOutput": "1"
          },
          {
              "input": "emails = [\"test.email.a@leetcode.com\",\"testemaila@leetcode.com\"]",
              "expectedOutput": "1"
          },
          {
              "input": "emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\"]",
              "expectedOutput": "1"
          }
        ],
        "hints": [
          "Split each email address into local name and domain name.",
          "Process the local name by removing periods and ignoring characters after the first plus sign.",
          "Combine the processed local name and domain name to form the canonical email address.",
          "Use a set to store the unique canonical email addresses.",
          "Return the size of the set."
        ],
        "tags": ["Array", "Hash Table", "String"]
      },
       {
        "problemId": 3,
        "courseId": "google",
        "title": "Fruit Into Baskets",
        "difficulty": "Medium",
        "description": "You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.\n\nYou want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\n\nYou only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.\nStarting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\nOnce you reach a tree with fruit that cannot fit in your baskets, you must stop.\nGiven the integer array fruits, return the maximum number of fruits you can pick.",
        "examples": [
          {
            "input": "fruits = [1, 2, 1]",
            "output": "3",
            "explanation": "We can pick from all 3 trees."
          },
          {
            "input": "fruits = [0, 1, 2, 2]",
            "output": "3",
            "explanation": "We can pick from trees [1, 2, 2].\nIf we had started at the first tree, we would only pick from trees [0, 1]."
          },
          {
            "input": "fruits = [1, 2, 3, 2, 2]",
            "output": "4",
            "explanation": "We can pick from trees [2, 3, 2, 2].\nIf we had started at the first tree, we would only pick from trees [1, 2]."
          }
        ],
        "constraints": [
          "1 <= fruits.length <= 10^5",
          "0 <= fruits[i] < fruits.length"
        ],
        "testCases": [
          {
            "input": "fruits = [1, 2, 1]",
            "expectedOutput": "3"
          },
          {
            "input": "fruits = [0, 1, 2, 2]",
            "expectedOutput": "3"
          },
          {
            "input": "fruits = [1, 2, 3, 2, 2]",
            "expectedOutput": "4"
          },
          {
            "input": "fruits = [3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4]",
            "expectedOutput": "5"
          },
           {
            "input": "fruits = [0, 0, 1, 1]",
            "expectedOutput": "4"
          },
           {
            "input": "fruits = [1, 0, 1, 4, 1, 4, 1, 2, 3]",
            "expectedOutput": "5"
          }
        ],
        "hints": [
          "Use a sliding window approach.",
          "Maintain a hash map to keep track of the fruit types in the current window.",
          "Expand the window to the right until the number of fruit types exceeds 2.",
          "When the number of fruit types exceeds 2, shrink the window from the left until the number of fruit types is 2.",
          "Keep track of the maximum window size seen so far."
        ],
        "tags": ["Array", "Hash Table", "Sliding Window"]
      },
       {
        "problemId": 4,
        "courseId": "google",
        "title": "License Key Formatting",
        "difficulty": "Easy",
        "description": "You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.\n\nWe want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\n\nReturn the reformatted license key.",
        "examples": [
          {
            "input": "s = \"5F3Z-2e-9-w\", k = 4",
            "output": "\"5F3Z-2E9W\"",
            "explanation": "The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed."
          },
          {
            "input": "s = \"2-5g-3-J\", k = 2",
            "output": "\"2-5G-3J\"",
            "explanation": "The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above."
          }
        ],
        "constraints": [
          "1 <= s.length <= 10^5",
          "s consists of English letters, digits, and dashes '-'.",
          "1 <= k <= 10^4"
        ],
        "testCases": [
          {
            "input": "s = \"5F3Z-2e-9-w\", k = 4",
            "expectedOutput": "\"5F3Z-2E9W\""
          },
          {
            "input": "s = \"2-5g-3-J\", k = 2",
            "expectedOutput": "\"2-5G-3J\""
          },
          {
            "input": "s = \"--a-a-a-a--\", k = 2",
            "expectedOutput": "\"AA-AA\""
          },
          {
            "input": "s = \"a\", k = 1",
            "expectedOutput": "\"A\""
          },
          {
            "input": "s = \"a-b-c-d\", k = 3",
            "expectedOutput": "\"AB-CD\""
          },
          {
            "input": "s = \"abcdefgh\", k = 3",
            "expectedOutput": "\"AB-CDE-FGH\""
          }
        ],
        "hints": [
          "Remove all dashes from the input string.",
          "Convert all lowercase letters to uppercase.",
          "Iterate through the string from right to left.",
          "Build the reformatted string by adding characters in groups of k, separated by dashes.",
          "Handle the case where the first group has fewer than k characters."
        ],
        "tags": ["String"]
      },
       {
        "problemId": 5,
        "courseId": "google",
        "title": "Minimum Domino Rotations For Equal Row",
        "difficulty": "Medium",
        "description": "In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\n\nWe may rotate the ith domino, so that tops[i] and bottoms[i] swap values.\n\nReturn the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.\n\nIf it cannot be done, return -1.",
        "examples": [
          {
            "input": "tops = [2, 1, 2, 4, 2, 2], bottoms = [5, 2, 6, 2, 3, 2]",
            "output": "2",
            "explanation": "The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure."
          },
          {
            "input": "tops = [3, 5, 1, 2, 3], bottoms = [3, 6, 3, 3, 4]",
            "output": "-1",
            "explanation": "In this case, it is not possible to rotate the dominoes to make one row of values equal."
          }
        ],
        "constraints": [
          "2 <= tops.length <= 2 * 10^4",
          "bottoms.length == tops.length",
          "1 <= tops[i], bottoms[i] <= 6"
        ],
        "testCases": [
          {
            "input": "tops = [2, 1, 2, 4, 2, 2], bottoms = [5, 2, 6, 2, 3, 2]",
            "expectedOutput": "2"
          },
          {
            "input": "tops = [3, 5, 1, 2, 3], bottoms = [3, 6, 3, 3, 4]",
            "expectedOutput": "-1"
          },
          {
            "input": "tops = [1, 2, 1, 1, 1], bottoms = [1, 2, 2, 2, 2]",
            "expectedOutput": "1"
          },
          {
            "input": "tops = [1, 1, 1, 1, 1], bottoms = [1, 1, 1, 1, 1]",
            "expectedOutput": "0"
          },
          {
            "input": "tops = [1, 2, 3, 4, 5, 6], bottoms = [6, 5, 4, 3, 2, 1]",
            "expectedOutput": "6"
          },
          {
            "input": "tops = [1, 1, 1, 2, 2, 2], bottoms = [2, 2, 2, 1, 1, 1]",
            "expectedOutput": "3"
          }
        ],
        "hints": [
          "There are at most 6 possible target values (1 to 6).",
          "For each target value, check if it's possible to make either tops or bottoms all equal to that value.",
          "Count the number of rotations needed for each target value and return the minimum count.",
          "If no target value can make either tops or bottoms all equal, return -1."
        ],
        "tags": ["Array", "Greedy"]
      },
       {
        "problemId": 6,
        "courseId": "google",
        "title": "Guess the Word",
        "difficulty": "Hard",
        "description": "You are given an array of unique strings words where words[i] is six letters long. One word of words was chosen as a secret word.\n\nYou are also given the helper object Master. You may call Master.guess(word) where word is a six-letter-long string, and it must be from words. Master.guess(word) returns:\n\n-1 if word is not from words, or\nan integer representing the number of exact matches (value and position) of your guess to the secret word.\nThere is a parameter allowedGuesses for each test case where allowedGuesses is the maximum number of times you can call Master.guess(word).\n\nFor each test case, you should call Master.guess with the secret word without exceeding the maximum number of allowed guesses. You will get:\n\n\"Either you took too many guesses, or you did not find the secret word.\" if you called Master.guess more than allowedGuesses times or if you did not call Master.guess with the secret word, or\n\"You guessed the secret word correctly.\" if you called Master.guess with the secret word with the number of calls to Master.guess less than or equal to allowedGuesses.\n\nThe test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method).",
        "examples": [
          {
            "input": "secret = \"acckzz\", words = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"], allowedGuesses = 10",
            "output": "You guessed the secret word correctly.",
            "explanation": "master.guess(\"aaaaaa\") returns -1, because \"aaaaaa\" is not in wordlist.\nmaster.guess(\"acckzz\") returns 6, because \"acckzz\" is secret and has all 6 matches.\nmaster.guess(\"ccbazz\") returns 3, because \"ccbazz\" has 3 matches.\nmaster.guess(\"eiowzz\") returns 2, because \"eiowzz\" has 2 matches.\nmaster.guess(\"abcczz\") returns 4, because \"abcczz\" has 4 matches.\nWe made 5 calls to master.guess, and one of them was the secret, so we pass the test case."
          },
          {
            "input": "secret = \"hamada\", words = [\"hamada\",\"khaled\"], allowedGuesses = 10",
            "output": "You guessed the secret word correctly.",
            "explanation": "Since there are two words, you can guess both."
          }
        ],
        "constraints": [
          "1 <= words.length <= 100",
          "words[i].length == 6",
          "words[i] consist of lowercase English letters.",
          "All the strings of wordlist are unique.",
          "secret exists in words.",
          "10 <= allowedGuesses <= 30"
        ],
        "testCases": [
          {
            "input": "secret = \"acckzz\", words = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"], allowedGuesses = 10",
            "expectedOutput": "You guessed the secret word correctly."
          },
          {
            "input": "secret = \"hamada\", words = [\"hamada\",\"khaled\"], allowedGuesses = 10",
            "expectedOutput": "You guessed the secret word correctly."
          },
          {
            "input": "secret = \"abcdef\", words = [\"abcdef\", \"ghijkl\", \"mnopqr\", \"stuvwx\", \"yzabcd\", \"efghij\"], allowedGuesses = 10",
            "expectedOutput": "You guessed the secret word correctly."
          },
          {
            "input": "secret = \"hbacda\", words = [\"hbacda\", \"abcdef\", \"ghijkl\", \"mnopqr\", \"stuvwx\", \"yzabcd\", \"efghij\"], allowedGuesses = 10",
            "expectedOutput": "You guessed the secret word correctly."
          },
          {
            "input": "secret = \"aaaaaa\", words = [\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\"], allowedGuesses = 10",
            "expectedOutput": "You guessed the secret word correctly."
          },
          {
               "input": "secret = \"hbacda\", words = [\"hbacda\",\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\",\"abcdef\",\"ghijkl\",\"mnopqr\",\"stuvwx\",\"yzabcd\",\"efghij\"], allowedGuesses = 10",
               "expectedOutput": "You guessed the secret word correctly."
          }
        ],
        "hints": [
          "Use a minimax strategy to reduce the number of possible words.",
          "Choose a word that maximizes the minimum number of words eliminated.",
          "Use the guess function to get the number of matches.",
          "Filter the word list to keep only words with the same number of matches.",
          "Repeat until the secret word is found."
        ],
        "tags": ["Array", "Math", "String", "Interactive", "Game Theory"]
      },
       {
        "problemId": 7,
        "courseId": "google",
        "title": "Evaluate Division",
        "difficulty": "Medium",
        "description": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\n\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\n\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\n\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\nNote: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.",
        "examples": [
          {
            "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
            "output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
            "explanation": "Given: a / b = 2.0, b / c = 3.0\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined => -1.0"
          },
          {
            "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
            "output": "[3.75000,0.40000,5.00000,0.20000]"
          },
          {
            "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
            "output": "[0.50000,2.00000,-1.00000,-1.00000]"
          }
        ],
        "constraints": [
          "1 <= equations.length <= 20",
          "equations[i].length == 2",
          "1 <= Ai.length, Bi.length <= 5",
          "values.length == equations.length",
          "0.0 < values[i] <= 20.0",
          "1 <= queries.length <= 20",
          "queries[i].length == 2",
          "1 <= Cj.length, Dj.length <= 5",
          "Ai, Bi, Cj, Dj consist of lower case English letters and digits."
        ],
        "testCases": [
          {
            "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
            "expectedOutput": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
          },
          {
            "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
            "expectedOutput": "[3.75000,0.40000,5.00000,0.20000]"
          },
          {
            "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
            "expectedOutput": "[0.50000,2.00000,-1.00000,-1.00000]"
          },
          {
            "input": "equations = [[\"a\",\"b\"],[\"c\",\"d\"]], values = [1.0,1.0], queries = [[\"a\",\"c\"],[\"b\",\"d\"],[\"a\",\"d\"],[\"c\",\"b\"]]",
            "expectedOutput": "[-1.00000,-1.00000,-1.00000,-1.00000]"
          },
          {
            "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"c\",\"d\"],[\"d\",\"e\"]], values = [2.0,3.0,4.0,5.0], queries = [[\"a\",\"e\"],[\"e\",\"a\"]]",
            "expectedOutput": "[120.00000,0.00833]"
          },
          {
            "input": "equations = [[\"x1\",\"x2\"],[\"x2\",\"x3\"],[\"x3\",\"x4\"],[\"x4\",\"x5\"]], values = [3.0,4.0,5.0,6.0], queries = [[\"x1\",\"x5\"],[\"x5\",\"x1\"],[\"x2\",\"x4\"],[\"x4\",\"x2\"]]",
            "expectedOutput": "[360.00000,0.00278,20.00000,0.05000]"
          }
        ],
        "hints": [
          "Represent the equations as a graph where nodes are variables and edges are the quotients.",
          "Use depth-first search (DFS) or breadth-first search (BFS) to traverse the graph and find the path between the query variables.",
          "Multiply the edge weights along the path to get the result.",
          "Handle undefined variables by returning -1.0."
        ],
        "tags": ["Array", "String", "Depth-First Search", "Breadth-First Search", "Union Find", "Graph", "Shortest Path"]
      },
       {
        "problemId": 8,
        "courseId": "google",
        "title": "Odd Even Jump",
        "difficulty": "Hard",
        "description": "You are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.\n\nYou may jump forward from index i to index j (with i < j) in the following way:\n\nDuring odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index j such that arr[i] <= arr[j] and arr[j] is the smallest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\nDuring even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index j such that arr[i] >= arr[j] and arr[j] is the largest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\nIt may be the case that for some index i, there are no legal jumps.\n\nA starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once).\n\nReturn the number of good starting indices.",
        "examples": [
          {
            "input": "arr = [10, 13, 12, 14, 15]",
            "output": "2",
            "explanation": "From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.\nFrom starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\nFrom starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\nFrom starting index i = 4, we have reached the end already.\nIn total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of jumps."
          },
          {
            "input": "arr = [2, 3, 1, 1, 4]",
            "output": "3",
            "explanation": "From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\nDuring our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].\nDuring our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\nDuring our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some number of jumps."
          },
          {
            "input": "arr = [5, 1, 3, 4, 2]",
            "output": "3",
            "explanation": "We can reach the end from starting indices 1, 2, and 4."
          }
        ],
        "constraints": [
          "1 <= arr.length <= 2 * 10^4",
          "0 <= arr[i] < 10^5"
        ],
        "testCases": [
          {
            "input": "arr = [10, 13, 12, 14, 15]",
            "expectedOutput": "2"
          },
          {
            "input": "arr = [2, 3, 1, 1, 4]",
            "expectedOutput": "3"
          },
          {
            "input": "arr = [5, 1, 3, 4, 2]",
            "expectedOutput": "3"
          },
          {
            "input": "arr = [1, 1, 1, 1, 1]",
            "expectedOutput": "5"
          },
          {
            "input": "arr = [1, 2, 3, 2, 1]",
            "expectedOutput": "3"
          },
          {
              "input": "arr = [7,6,5,4,3,2,1]",
              "expectedOutput": "1"
          }
        ],
        "hints": [
          "Use dynamic programming to store whether an index can reach the end with an odd or even jump.",
          "Use a sorted map to efficiently find the next odd or even jump index.",
          "Iterate through the array from right to left to populate the dynamic programming arrays.",
          "Count the number of indices that can reach the end with an odd jump."
        ],
        "tags": ["Array", "Dynamic Programming", "Stack", "Monotonic Stack", "Ordered Set"]
      },
       {
        "problemId": 9,
        "courseId": "google",
        "title": "Repeated String Match",
        "difficulty": "Medium",
        "description": "Given two strings a and b, return the minimum number of times you should repeat string a so that string b is a substring of it. If it is impossible for b​​​​​​ to be a substring of a after repeating it, return -1.\n\nNotice: string \"abc\" repeated 0 times is \"\", repeated 1 time is \"abc\" and repeated 2 times is \"abcabc\".",
        "examples": [
          {
            "input": "a = \"abcd\", b = \"cdabcdab\"",
            "output": "3",
            "explanation": "We return 3 because by repeating a three times \"abcdabcdabcd\", b is a substring of it."
          },
          {
            "input": "a = \"a\", b = \"aa\"",
            "output": "2"
          }
        ],
        "constraints": [
          "1 <= a.length, b.length <= 10^4",
          "a and b consist of lowercase English letters."
        ],
        "testCases": [
          {
            "input": "a = \"abcd\", b = \"cdabcdab\"",
            "expectedOutput": "3"
          },
          {
            "input": "a = \"a\", b = \"aa\"",
            "expectedOutput": "2"
          },
          {
            "input": "a = \"a\", b = \"b\"",
            "expectedOutput": "-1"
          },
          {
            "input": "a = \"abc\", b = \"cabcabca\"",
            "expectedOutput": "4"
          },
          {
            "input": "a = \"abc\", b = \"abcabcabcabc\"",
            "expectedOutput": "4"
          },
          {
            "input": "a = \"ab\", b = \"ababababab\"",
            "expectedOutput": "5"
          }
        ],
        "hints": [
          "Repeatedly append string a to itself and check if b is a substring.",
          "The maximum number of repetitions needed is at most (b.length / a.length) + 2.",
          "If b is a substring, return the number of repetitions.",
          "If b is not a substring after the maximum repetitions, return -1."
        ],
        "tags": ["String", "String Matching"]
      },
       {
        "problemId": 10,
        "courseId": "google",
        "title": "Cracking the Safe",
        "difficulty": "Hard",
        "description": "There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1].\n\nThe safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit.\n\nFor example, the correct password is \"345\" and you enter in \"012345\":\nAfter typing 0, the most recent 3 digits is \"0\", which is incorrect.\nAfter typing 1, the most recent 3 digits is \"01\", which is incorrect.\nAfter typing 2, the most recent 3 digits is \"012\", which is incorrect.\nAfter typing 3, the most recent 3 digits is \"123\", which is incorrect.\nAfter typing 4, the most recent 3 digits is \"234\", which is incorrect.\nAfter typing 5, the most recent 3 digits is \"345\", which is correct and the safe unlocks.\nReturn any string of minimum length that will unlock the safe at some point of entering it.",
        "examples": [
          {
            "input": "n = 1, k = 2",
            "output": "\"10\"",
            "explanation": "The password is a single digit, so enter each digit. \"01\" would also unlock the safe."
          },
          {
            "input": "n = 2, k = 2",
            "output": "\"01100\"",
            "explanation": "For each possible password:\n- \"00\" is typed in starting from the 4th digit.\n- \"01\" is typed in starting from the 1st digit.\n- \"10\" is typed in starting from the 3rd digit.\n- \"11\" is typed in starting from the 2nd digit.\nThus \"01100\" will unlock the safe. \"10011\", and \"11001\" would also unlock the safe."
          }
        ],
        "constraints": [
          "1 <= n <= 4",
          "1 <= k <= 10",
          "1 <= k^n <= 4096"
        ],
        "testCases": [
          {
            "input": "n = 1, k = 2",
            "expectedOutput": "\"10\""
          },
          {
            "input": "n = 2, k = 2",
            "expectedOutput": "\"01100\""
          },
          {
            "input": "n = 1, k = 3",
            "expectedOutput": "\"210\""
          },
          {
            "input": "n = 3, k = 2",
            "expectedOutput": "\"001110100\""
          },
          {
            "input": "n = 2, k = 3",
            "expectedOutput": "\"0221201100\""
          },
          {
            "input": "n = 4, k = 2",
            "expectedOutput": "\"000111101100101000\""
          }
        ],
        "hints": [
          "Construct a de Bruijn sequence.",
          "Use depth-first search (DFS) to traverse the graph of possible passwords.",
          "Keep track of visited edges to avoid cycles.",
          "Append the last digit of each visited edge to the result string.",
          "The result string will contain all possible passwords as substrings."
        ],
        "tags": ["Depth-First Search", "Graph", "Eulerian Circuit"]
      },
       {
        "problemId": 11,
        "courseId": "google",
        "title": "UTF-8 Validation",
        "difficulty": "Medium",
        "description": "Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\n\nA character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n\nFor a 1-byte character, the first bit is a 0, followed by its Unicode code.\nFor an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.\nThis is how the UTF-8 encoding would work:\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\nx denotes a bit in the binary form of a byte that may be either 0 or 1.\n\nNote: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.",
        "examples": [
          {
            "input": "data = [197, 130, 1]",
            "output": "true",
            "explanation": "data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character."
          },
          {
            "input": "data = [235, 140, 4]",
            "output": "false",
            "explanation": "data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid."
          }
        ],
        "constraints": [
          "1 <= data.length <= 2 * 10^4",
          "0 <= data[i] <= 255"
        ],
        "testCases": [
          {
            "input": "data = [197, 130, 1]",
            "expectedOutput": "true"
          },
          {
            "input": "data = [235, 140, 4]",
            "expectedOutput": "false"
          },
          {
            "input": "data = [240, 162, 138, 147]",
            "expectedOutput": "true"
          },
          {
            "input": "data = [240, 162, 138, 147, 197, 130, 1]",
            "expectedOutput": "true"
          },
          {
            "input": "data = [240, 162, 138, 147, 235, 140, 4]",
            "expectedOutput": "false"
          },
          {
              "input": "data = [255]",
              "expectedOutput": "false"
          }
        ],
        "hints": [
          "Read the data integer by integer. When you read it, process the least significant 8 bits of it.",
          "Assume the next encoding is 1-byte data. If it is not 1-byte data, read the next integer and assume it is 2-bytes data.",
          "Similarly, if it is not 2-bytes data, try 3-bytes then 4-bytes. If you read four integers and it still does not match any pattern, return false."
        ],
        "tags": ["Array", "Bit Manipulation"]
      },
       {
        "problemId": 12,
        "courseId": "google",
        "title": "Backspace String Compare",
        "difficulty": "Easy",
        "description": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.",
        "examples": [
          {
            "input": "s = \"ab#c\", t = \"ad#c\"",
            "output": "true",
            "explanation": "Both s and t become \"ac\"."
          },
          {
            "input": "s = \"ab##\", t = \"c#d#\"",
            "output": "true",
            "explanation": "Both s and t become \"\"."
          },
          {
            "input": "s = \"a#c\", t = \"b\"",
            "output": "false",
            "explanation": "s becomes \"c\" while t becomes \"b\"."
          }
        ],
        "constraints": [
          "1 <= s.length, t.length <= 200",
          "s and t only contain lowercase letters and '#' characters."
        ],
        "testCases": [
          {
            "input": "s = \"ab#c\", t = \"ad#c\"",
            "expectedOutput": "true"
          },
          {
            "input": "s = \"ab##\", t = \"c#d#\"",
            "expectedOutput": "true"
          },
          {
            "input": "s = \"a#c\", t = \"b\"",
            "expectedOutput": "false"
          },
          {
            "input": "s = \"###a#b#c\", t = \"abc###\"",
            "expectedOutput": "true"
          },
          {
            "input": "s = \"xywrrmp\", t = \"xywrrmu#p\"",
            "expectedOutput": "true"
          },
          {
              "input": "s = \"bxj##tw\", t = \"bxo#j##tw\"",
              "expectedOutput": "true"
          }
        ],
        "hints": [
          "Use a stack to simulate the typing process.",
          "Iterate through the string and push characters onto the stack.",
          "When a '#' character is encountered, pop a character from the stack if it is not empty.",
          "Compare the resulting stacks for equality."
        ],
        "tags": ["Two Pointers", "String", "Stack", "Simulation"]
      },
       {
        "problemId": 13,
        "courseId": "google",
        "title": "Count Complete Tree Nodes",
        "difficulty": "Easy",
        "description": "Given the root of a complete binary tree, return the number of the nodes in the tree.\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\nDesign an algorithm that runs in less than O(n) time complexity.",
        "examples": [
          {
            "input": "root = [1, 2, 3, 4, 5, 6]",
            "output": "6"
          },
          {
            "input": "root = []",
            "output": "0"
          },
          {
            "input": "root = [1]",
            "output": "1"
          }
        ],
        "constraints": [
          "The number of nodes in the tree is in the range [0, 5 * 10^4].",
          "0 <= Node.val <= 5 * 10^4",
          "The tree is guaranteed to be complete."
        ],
        "testCases": [
          {
            "input": "root = [1, 2, 3, 4, 5, 6]",
            "expectedOutput": "6"
          },
          {
            "input": "root = []",
            "expectedOutput": "0"
          },
          {
            "input": "root = [1]",
            "expectedOutput": "1"
          },
          {
            "input": "root = [1, 2]",
            "expectedOutput": "2"
          },
          {
            "input": "root = [1, 2, 3, 4]",
            "expectedOutput": "4"
          },
          {
            "input": "root = [1, 2, 3, 4, 5, 6, 7, 8]",
            "expectedOutput": "8"
          }
        ],
        "hints": [
          "Use binary search to find the number of nodes in the last level.",
          "Calculate the height of the tree.",
          "The number of nodes in a complete binary tree is 2^h - 1 + number of nodes in the last level.",
          "Use bit manipulation to efficiently calculate 2^h."
        ],
        "tags": ["Binary Search", "Bit Manipulation", "Tree", "Binary Tree"]
      },
       {
        "problemId": 14,
        "courseId": "google",
        "title": "Most Stones Removed with Same Row or Column",
        "difficulty": "Medium",
        "description": "On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.\n\nA stone can be removed if it shares either the same row or the same column as another stone that has not been removed.\n\nGiven an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.",
        "examples": [
          {
            "input": "stones = [[0, 0], [0, 1], [1, 0], [1, 2], [2, 1], [2, 2]]",
            "output": "5",
            "explanation": "One way to remove 5 stones is as follows:\n1. Remove stone [2, 2] because it shares the same row as [2, 1].\n2. Remove stone [2, 1] because it shares the same column as [0, 1].\n3. Remove stone [1, 2] because it shares the same row as [1, 0].\n4. Remove stone [1, 0] because it shares the same column as [0, 0].\n5. Remove stone [0, 1] because it shares the same row as [0, 0].\nStone [0, 0] cannot be removed since it does not share a row/column with another stone still on the plane."
          },
          {
            "input": "stones = [[0, 0], [0, 2], [1, 1], [2, 0], [2, 2]]",
            "output": "3",
            "explanation": "One way to make 3 moves is as follows:\n1. Remove stone [2, 2] because it shares the same row as [2, 0].\n2. Remove stone [2, 0] because it shares the same column as [0, 0].\n3. Remove stone [0, 2] because it shares the same row as [0, 0].\nStones [0, 0] and [1, 1] cannot be removed since they do not share a row/column with another stone still on the plane."
          },
          {
            "input": "stones = [[0, 0]]",
            "output": "0",
            "explanation": "[0, 0] is the only stone on the plane, so you cannot remove it."
          }
        ],
        "constraints": [
          "1 <= stones.length <= 1000",
          "0 <= xi, yi <= 10^4",
          "No two stones are at the same coordinate point."
        ],
        "testCases": [
          {
            "input": "stones = [[0, 0], [0, 1], [1, 0], [1, 2], [2, 1], [2, 2]]",
            "expectedOutput": "5"
          },
          {
            "input": "stones = [[0, 0], [0, 2], [1, 1], [2, 0], [2, 2]]",
            "expectedOutput": "3"
          },
          {
            "input": "stones = [[0, 0]]",
            "expectedOutput": "0"
          },
          {
            "input": "stones = [[0, 0], [0, 1], [1, 0]]",
            "expectedOutput": "2"
          },
          {
            "input": "stones = [[0, 0], [1, 1], [2, 2], [3, 3]]",
            "expectedOutput": "3"
          },
          {
              "input": "stones = [[0,0],[0,1],[1,0],[2,2]]",
              "expectedOutput": "3"
          }
        ],
        "hints": [
          "Use a graph to represent the stones and their connections.",
          "Two stones are connected if they share the same row or column.",
          "The number of removable stones is equal to the total number of stones minus the number of connected components.",
          "Use depth-first search (DFS) or union-find to find the connected components."
        ],
        "tags": ["Hash Table", "Depth-First Search", "Union Find", "Graph"]
      },
       {
        "problemId": 15,
        "courseId": "google",
        "title": "Split Array Largest Sum",
        "difficulty": "Hard",
        "description": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\nReturn the minimized largest sum of the split.\nA subarray is a contiguous part of the array.",
        "examples": [
          {
            "input": "nums = [7, 2, 5, 10, 8], k = 2",
            "output": "18",
            "explanation": "There are four ways to split nums into two subarrays.\nThe best way is to split it into [7, 2, 5] and [10, 8], where the largest sum among the two subarrays is only 18."
          },
          {
            "input": "nums = [1, 2, 3, 4, 5], k = 2",
            "output": "9",
            "explanation": "There are four ways to split nums into two subarrays.\nThe best way is to split it into [1, 2, 3] and [4, 5], where the largest sum among the two subarrays is only 9."
          }
        ],
        "constraints": [
          "1 <= nums.length <= 1000",
          "0 <= nums[i] <= 10^6",
          "1 <= k <= min(50, nums.length)"
        ],
        "testCases": [
          {
            "input": "nums = [7, 2, 5, 10, 8], k = 2",
            "expectedOutput": "18"
          },
          {
            "input": "nums = [1, 2, 3, 4, 5], k = 2",
            "expectedOutput": "9"
          },
          {
            "input": "nums = [1, 4, 4], k = 3",
            "expectedOutput": "4"
          },
          {
            "input": "nums = [1, 2, 3, 4, 5], k = 1",
            "expectedOutput": "15"
          },
          {
            "input": "nums = [10, 5, 13, 4, 8, 4, 5, 11, 14, 9, 16, 10, 20, 8], k = 8",
            "expectedOutput": "20"
          },
          {
            "input": "nums = [2,3,1,2,4,3], k = 5",
            "expectedOutput": "4"
          }
        ],
        "hints": [
          "Use binary search to find the minimized largest sum.",
          "The left boundary of the search space is the maximum element in nums.",
          "The right boundary of the search space is the sum of all elements in nums.",
          "Use a helper function to check if a given sum is a valid largest sum for splitting the array into k subarrays.",
          "The helper function should greedily split the array into subarrays such that the sum of each subarray is less than or equal to the given sum."
        ],
        "tags": ["Array", "Binary Search", "Dynamic Programming", "Greedy", "Prefix Sum"]
      },
       {
        "problemId": 16,
        "courseId": "google",
        "title": "Minimum Cost to Hire K Workers",
        "difficulty": "Hard",
        "description": "There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.\n\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n\nEvery worker in the paid group must be paid at least their minimum wage expectation.\nIn the group, each worker's pay must be directly proportional to their quality. This means if a worker’s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
          {
            "input": "quality = [10, 20, 5], wage = [70, 50, 30], k = 2",
            "output": "105.00000",
            "explanation": "We pay 70 to 0th worker and 35 to 2nd worker."
          },
          {
            "input": "quality = [3, 1, 10, 10, 1], wage = [4, 8, 2, 2, 7], k = 3",
            "output": "30.66667",
            "explanation": "We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately."
          }
        ],
        "constraints": [
          "n == quality.length == wage.length",
          "1 <= k <= n <= 10^4",
          "1 <= quality[i], wage[i] <= 10^4"
        ],
        "testCases": [
          {
            "input": "quality = [10, 20, 5], wage = [70, 50, 30], k = 2",
            "expectedOutput": "105.00000"
          },
          {
            "input": "quality = [3, 1, 10, 10, 1], wage = [4, 8, 2, 2, 7], k = 3",
            "expectedOutput": "30.66667"
          },
          {
            "input": "quality = [2, 1, 3], wage = [10, 5, 20], k = 2",
            "expectedOutput": "30.00000"
          },
          {
            "input": "quality = [4, 2, 1], wage = [8, 4, 1], k = 3",
            "expectedOutput": "13.00000"
          },
          {
            "input": "quality = [1, 2, 3, 4, 5], wage = [5, 4, 3, 2, 1], k = 3",
            "expectedOutput": "9.00000"
          },
          {
            "input": "quality = [10, 10, 10, 10, 10], wage = [1, 2, 3, 4, 5], k = 3",
            "expectedOutput": "30.00000"
          }
        ],
        "hints": [
          "Calculate the ratio of wage to quality for each worker.",
          "Sort the workers by their wage-to-quality ratio.",
          "Iterate through the sorted workers and maintain a priority queue of the k workers with the highest quality.",
          "Calculate the total cost for each group of k workers and update the minimum cost.",
          "The total cost is the product of the current worker's wage-to-quality ratio and the sum of the qualities in the priority queue."
        ],
        "tags": ["Array", "Greedy", "Sorting", "Heap (Priority Queue)"]
      },
       {
        "problemId": 17,
        "courseId": "google",
        "title": "Minimum Area Rectangle",
        "difficulty": "Medium",
        "description": "You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\nReturn the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes. If there is not any such rectangle, return 0.",
        "examples": [
          {
            "input": "points = [[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]",
            "output": "4"
          },
          {
            "input": "points = [[1, 1], [1, 3], [3, 1], [3, 3], [4, 1], [4, 3]]",
            "output": "2"
          }
        ],
        "constraints": [
          "1 <= points.length <= 500",
          "points[i].length == 2",
          "0 <= xi, yi <= 4 * 10^4",
          "All the given points are unique."
        ],
        "testCases": [
          {
            "input": "points = [[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]",
            "expectedOutput": "4"
          },
          {
            "input": "points = [[1, 1], [1, 3], [3, 1], [3, 3], [4, 1], [4, 3]]",
            "expectedOutput": "2"
          },
          {
            "input": "points = [[1, 1], [1, 3], [3, 1]]",
            "expectedOutput": "0"
          },
          {
            "input": "points = [[1, 1], [1, 3], [3, 1], [3, 3]]",
            "expectedOutput": "4"
          },
          {
            "input": "points = [[0, 0], [0, 1], [1, 0], [1, 1]]",
            "expectedOutput": "1"
          },
          {
            "input": "points = [[3,2],[3,1],[4,4],[1,1],[4,3],[0,3],[0,2],[4,0]]",
            "expectedOutput": "1"
          }
        ],
        "hints": [
          "Iterate through all pairs of points and check if they can form the diagonal of a rectangle.",
          "Use a hash set to store the points for efficient lookup.",
          "For each pair of points, check if the other two points needed to form a rectangle exist in the hash set.",
          "Calculate the area of the rectangle and update the minimum area if necessary.",
          "If no rectangle is found, return 0."
        ],
        "tags": ["Array", "Hash Table", "Math", "Geometry", "Sorting"]
      },
       {
        "problemId": 18,
        "courseId": "google",
        "title": "The Skyline Problem",
        "difficulty": "Hard",
        "description": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\n\nThe geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:\nlefti is the x coordinate of the left edge of the ith building.\nrighti is the x coordinate of the right edge of the ith building.\nheighti is the height of the ith building.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nThe skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\nNote: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]",
        "examples": [
          {
            "input": "buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]",
            "output": "[[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]",
            "explanation": "Figure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list."
          },
          {
            "input": "buildings = [[0, 2, 3], [2, 5, 3]]",
            "output": "[[0, 3], [5, 0]]"
          }
        ],
        "constraints": [
          "1 <= buildings.length <= 10^4",
          "0 <= lefti < righti <= 2^31 - 1",
          "1 <= heighti <= 2^31 - 1",
          "buildings is sorted by lefti in non-decreasing order."
        ],
        "testCases": [
          {
            "input": "buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]",
            "expectedOutput": "[[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]"
          },
          {
            "input": "buildings = [[0, 2, 3], [2, 5, 3]]",
            "expectedOutput": "[[0, 3], [5, 0]]"
          },
          {
            "input": "buildings = [[0, 2, 3], [2, 5, 4]]",
            "expectedOutput": "[[0, 3], [2, 4], [5, 0]]"
          },
          {
            "input": "buildings = [[1, 2, 1], [1, 2, 2], [1, 2, 3]]",
            "expectedOutput": "[[1, 3], [2, 0]]"
          },
          {
            "input": "buildings = [[0, 5, 7], [2, 4, 12], [3, 9, 6]]",
            "expectedOutput": "[[0, 7], [2, 12], [4, 6], [9, 0]]"
          },
          {
            "input": "buildings = [[0,1,3],[0,2,3],[0,3,3],[0,4,3],[0,5,3],[0,6,3],[0,7,3],[0,8,3],[0,9,3],[0,10,3],[0,11,3],[0,12,3],[0,13,3],[0,14,3],[0,15,3],[0,16,3],[0,17,3],[0,18,3],[0,19,3],[0,20,3],[0,21,3],[0,22,3],[0,23,3],[0,24,3],[0,25,3],[0,26,3],[0,27,3],[0,28,3],[0,29,3],[0,30,3],[0,31,3],[0,32,3],[0,33,3],[0,34,3],[0,35,3],[0,36,3],[0,37,3],[0,38,3],[0,39,3],[0,40,3],[0,41,3],[0,42,3],[0,43,3],[0,44,3],[0,45,3],[0,46,3],[0,47,3],[0,48,3],[0,49,3],[0,50,3],[0,51,3],[0,52,3],[0,53,3],[0,54,3],[0,55,3],[0,56,3],[0,57,3],[0,58,3],[0,59,3],[0,60,3],[0,61,3],[0,62,3],[0,63,3],[0,64,3],[0,65,3],[0,66,3],[0,67,3],[0,68,3],[0,69,3],[0,70,3],[0,71,3],[0,72,3],[0,73,3],[0,74,3],[0,75,3],[0,76,3],[0,77,3],[0,78,3],[0,79,3],[0,80,3],[0,81,3],[0,82,3],[0,83,3],[0,84,3],[0,85,3],[0,86,3],[0,87,3],[0,88,3],[0,89,3],[0,90,3],[0,91,3],[0,92,3],[0,93,3],[0,94,3],[0,95,3],[0,96,3],[0,97,3],[0,98,3],[0,99,3]]",
            "expectedOutput": "[[0, 3], [100, 0]]"
          }
        ],
        "hints": [
          "Use a priority queue to keep track of the current heights of the buildings.",
          "Process the buildings in sorted order of their left and right edges.",
          "When a left edge is encountered, add the building's height to the priority queue.",
          "When a right edge is encountered, remove the building's height from the priority queue.",
          "Update the skyline when the maximum height in the priority queue changes."
        ],
        "tags": ["Array", "Divide and Conquer", "Binary Indexed Tree", "Segment Tree", "Line Sweep", "Heap (Priority Queue)", "Ordered Set"]
      },
      {
        "problemId": 19,
        "courseId": "google",
        "title": "Merge Intervals",
        "difficulty": "Medium",
        "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
        "examples": [
          {
            "input": "intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]",
            "output": "[[1, 6], [8, 10], [15, 18]]",
            "explanation": "Since intervals [1, 3] and [2, 6] overlap, merge them into [1, 6]."
          },
          {
            "input": "intervals = [[1, 4], [4, 5]]",
            "output": "[[1, 5]]",
            "explanation": "Intervals [1, 4] and [4, 5] are considered overlapping."
          }
        ],
        "constraints": [
          "1 <= intervals.length <= 10^4",
          "intervals[i].length == 2",
          "0 <= starti <= endi <= 10^4"
        ],
        "testCases": [
          {
            "input": "intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]",
            "expectedOutput": "[[1, 6], [8, 10], [15, 18]]"
          },
          {
            "input": "intervals = [[1, 4], [4, 5]]",
            "expectedOutput": "[[1, 5]]"
          },
          {
            "input": "intervals = [[1, 4], [0, 4]]",
            "expectedOutput": "[[0, 4]]"
          },
          {
            "input": "intervals = [[1, 4], [0, 1]]",
            "expectedOutput": "[[0, 4]]"
          },
          {
            "input": "intervals = [[1, 4], [2, 3]]",
            "expectedOutput": "[[1, 4]]"
          },
          {
            "input": "intervals = [[1, 4], [0, 0]]",
            "expectedOutput": "[[0, 0], [1, 4]]"
          }
        ],
        "hints": [
          "Sort the intervals by their start values.",
          "Iterate through the sorted intervals and merge overlapping intervals.",
          "Keep track of the merged intervals in a result list.",
          "If the current interval overlaps with the last merged interval, update the end of the last merged interval.",
          "Otherwise, add the current interval to the result list."
        ],
        "tags": ["Array", "Sorting"]
      },
       {
        "problemId": 20,
        "courseId": "google",
        "title": "Decode String",
        "difficulty": "Medium",
        "description": "Given an encoded string, return its decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].\nThe test cases are generated so that the length of the output will never exceed 10^5.",
        "examples": [
          {
            "input": "s = \"3[a]2[bc]\"",
            "output": "\"aaabcbc\""
          },
          {
            "input": "s = \"3[a2[c]]\"",
            "output": "\"accaccacc\""
          },
          {
            "input": "s = \"2[abc]3[cd]ef\"",
            "output": "\"abcabccdcdcdef\""
          }
        ],
        "constraints": [
          "1 <= s.length <= 30",
          "s consists of lowercase English letters, digits, and square brackets '[]'.",
          "s is guaranteed to be a valid input.",
          "All the integers in s are in the range [1, 300]."
        ],
        "testCases": [
          {
            "input": "s = \"3[a]2[bc]\"",
            "expectedOutput": "\"aaabcbc\""
          },
          {
            "input": "s = \"3[a2[c]]\"",
            "expectedOutput": "\"accaccacc\""
          },
          {
            "input": "s = \"2[abc]3[cd]ef\"",
            "expectedOutput": "\"abcabccdcdcdef\""
          },
          {
            "input": "s = \"10[leetcode]\"",
            "expectedOutput": "\"leetcodeleetcodeleetcodeleetcodeleetcodeleetcodeleetcodeleetcodeleetcodeleetcode\""
          },
          {
            "input": "s = \"abc\"",
            "expectedOutput": "\"abc\""
          },
          {
              "input": "s = \"1[a]1[b]\"",
              "expectedOutput": "\"ab\""
          }
        ],
        "hints": [
          "Use a stack to keep track of the repeated strings and their repetition counts.",
          "When a digit is encountered, parse the entire number and push it onto the stack.",
          "When an opening bracket '[' is encountered, push the current decoded string onto the stack and reset the decoded string.",
          "When a closing bracket ']' is encountered, pop the repetition count and the previous decoded string from the stack, and append the repeated string to the previous decoded string.",
          "When a letter is encountered, append it to the current decoded string."
        ],
        "tags": ["String", "Stack", "Recursion"]
      },
       {
        "problemId": 21,
        "courseId": "google",
        "title": "Plus One",
        "difficulty": "Easy",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
          {
            "input": "digits = [1, 2, 3]",
            "output": "[1, 2, 4]",
            "explanation": "The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1, 2, 4]."
          },
          {
            "input": "digits = [4, 3, 2, 1]",
            "output": "[4, 3, 2, 2]",
            "explanation": "The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4, 3, 2, 2]."
          },
          {
            "input": "digits = [9]",
            "output": "[1, 0]",
            "explanation": "The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1, 0]."
          }
        ],
        "constraints": [
          "1 <= digits.length <= 100",
          "0 <= digits[i] <= 9",
          "digits does not contain any leading 0's."
        ],
        "testCases": [
          {
            "input": "digits = [1, 2, 3]",
            "expectedOutput": "[1, 2, 4]"
          },
          {
            "input": "digits = [4, 3, 2, 1]",
            "expectedOutput": "[4, 3, 2, 2]"
          },
          {
            "input": "digits = [9]",
            "expectedOutput": "[1, 0]"
          },
          {
            "input": "digits = [9, 9]",
            "expectedOutput": "[1, 0, 0]"
          },
          {
            "input": "digits = [1, 9, 9]",
            "expectedOutput": "[2, 0, 0]"
          },
          {
            "input": "digits = [9, 8, 9]",
            "expectedOutput": "[9, 9, 0]"
          }
        ],
        "hints": [
          "Iterate through the digits array from right to left.",
          "Add 1 to the last digit and check if there is a carry.",
          "If there is a carry, add it to the next digit and repeat the process.",
          "If there is a carry after the first digit, add a new digit 1 at the beginning of the array."
        ],
        "tags": ["Array", "Math"]
      },
       {
        "problemId": 22,
        "courseId": "google",
        "title": "Expressive Words",
        "difficulty": "Medium",
        "description": "Sometimes people repeat letters to represent extra feeling. For example:\n\"hello\" -> \"heeellooo\"\n\"hi\" -> \"hiiii\"\nIn these strings like \"heeellooo\", we have groups of adjacent letters that are all the same: \"h\", \"eee\", \"ll\", \"ooo\".\nYou are given a string s and an array of query strings words. A query word is stretchy if it can be made to be equal to s by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is three or more.\nFor example, starting with \"hello\", we could do an extension on the group \"o\" to get \"hellooo\", but we cannot get \"helloo\" since the group \"oo\" has a size less than three. Also, we could do another extension like \"ll\" -> \"lllll\" to get \"helllllooo\". If s = \"helllllooo\", then the query word \"hello\" would be stretchy because of these two extension operations: query = \"hello\" -> \"hellooo\" -> \"helllllooo\" = s.\nReturn the number of query strings that are stretchy.",
        "examples": [
          {
            "input": "s = \"heeellooo\", words = [\"hello\", \"hi\", \"helo\"]",
            "output": "1",
            "explanation": "We can extend \"e\" and \"o\" in the word \"hello\" to get \"heeellooo\".\nWe can't extend \"helo\" to get \"heeellooo\" because the group \"ll\" is not size 3 or more."
          },
          {
            "input": "s = \"zzzzzyyyyy\", words = [\"zzyy\",\"zy\",\"zyy\"]",
            "output": "3"
          }
        ],
        "constraints": [
          "1 <= s.length, words.length <= 100",
          "1 <= words[i].length <= 100",
          "s and words[i] consist of lowercase letters."
        ],
        "testCases": [
          {
            "input": "s = \"heeellooo\", words = [\"hello\", \"hi\", \"helo\"]",
            "expectedOutput": "1"
          },
          {
            "input": "s = \"zzzzzyyyyy\", words = [\"zzyy\",\"zy\",\"zyy\"]",
            "expectedOutput": "3"
          },
          {
            "input": "s = \"abcd\", words = [\"abc\", \"abbcd\", \"abcd\"]",
            "expectedOutput": "1"
          },
          {
            "input": "s = \"aaa\", words = [\"a\", \"aa\", \"aaa\"]",
            "expectedOutput": "3"
          },
          {
            "input": "s = \"abbcccdddd\", words = [\"abccd\", \"abcdd\", \"abbccdd\"]",
            "expectedOutput": "3"
          },
          {
            "input": "s = \"aaaaaaaaaaa\", words = [\"aaaaaaa\"]",
            "expectedOutput": "1"
          }
        ],
        "hints": [
          "Group the characters in both s and the query words.",
          "Compare the groups character by character.",
          "A query word is stretchy if:",
          "1. The groups have the same characters in the same order.",
          "2. The length of each group in the query word is less than or equal to the length of the corresponding group in s.",
          "3. If the lengths are different, the length of the group in s must be at least 3."
        ],
        "tags": ["Array", "Two Pointers", "String"]
      },
       {
        "problemId": 23,
        "courseId": "google",
        "title": "24 Game",
        "difficulty": "Hard",
        "description": "You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.\n\nYou are restricted with the following rules:\n\nThe division operator '/' represents real division, not integer division.For example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.\nEvery operation done is between two numbers. In particular, we cannot use '-' as a unary operator.For example, if cards = [1, 1, 1, 1], the expression \"-1 - 1 - 1 - 1\" is not allowed.\nYou cannot concatenate numbers togetherFor example, if cards = [1, 2, 1, 2], the expression \"12 + 12\" is not valid.\nReturn true if you can get such expression that evaluates to 24, and false otherwise.",
        "examples": [
          {
            "input": "cards = [4, 1, 8, 7]",
            "output": "true",
            "explanation": "(8 - 4) * (7 - 1) = 24"
          },
          {
            "input": "cards = [1, 2, 1, 2]",
            "output": "false"
          }
        ],
        "constraints": [
          "cards.length == 4",
          "1 <= cards[i] <= 9"
        ],
        "testCases": [
          {
            "input": "cards = [4, 1, 8, 7]",
            "expectedOutput": "true"
          },
          {
            "input": "cards = [1, 2, 1, 2]",
            "expectedOutput": "false"
          },
          {
            "input": "cards = [3, 3, 8, 8]",
            "expectedOutput": "true"
          },
          {
            "input": "cards = [1, 5, 9, 1]",
            "expectedOutput": "true"
          },
          {
            "input": "cards = [1, 9, 1, 9]",
            "expectedOutput": "false"
          },
          {
            "input": "cards = [6, 7, 8, 9]",
            "expectedOutput": "true"
          }
        ],
        "hints": [
          "Use backtracking to try all possible combinations of numbers and operators.",
          "Generate all possible permutations of the input numbers.",
          "For each permutation, try all possible combinations of operators and parentheses.",
          "Evaluate each expression and check if the result is 24.",
          "Be careful with division to avoid division by zero."
        ],
        "tags": ["Array", "Math", "Backtracking"]
      },
       {
        "problemId": 24,
        "courseId": "google",
        "title": "Summary Ranges",
        "difficulty": "Easy",
        "description": "You are given a sorted unique integer array nums.\nA range [a,b] is the set of all integers from a to b (inclusive).\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\nEach range [a,b] in the list should be output as:\n\"a->b\" if a != b\n\"a\" if a == b",
        "examples": [
          {
            "input": "nums = [0, 1, 2, 4, 5, 7]",
            "output": "[\"0->2\", \"4->5\", \"7\"]",
            "explanation": "The ranges are:\n[0, 2] --> \"0->2\"\n[4, 5] --> \"4->5\"\n[7, 7] --> \"7\""
          },
          {
            "input": "nums = [0, 2, 3, 4, 6, 8, 9]",
            "output": "[\"0\", \"2->4\", \"6\", \"8->9\"]",
            "explanation": "The ranges are:\n[0, 0] --> \"0\"\n[2, 4] --> \"2->4\"\n[6, 6] --> \"6\"\n[8, 9] --> \"8->9\""
          }
        ],
        "constraints": [
          "0 <= nums.length <= 20",
          "-2^31 <= nums[i] <= 2^31 - 1",
          "All the values of nums are unique.",
          "nums is sorted in ascending order."
        ],
        "testCases": [
          {
            "input": "nums = [0, 1, 2, 4, 5, 7]",
            "expectedOutput": "[\"0->2\", \"4->5\", \"7\"]"
          },
          {
            "input": "nums = [0, 2, 3, 4, 6, 8, 9]",
            "expectedOutput": "[\"0\", \"2->4\", \"6\", \"8->9\"]"
          },
          {
            "input": "nums = []",
            "expectedOutput": "[]"
          },
          {
            "input": "nums = [0]",
            "expectedOutput": "[\"0\"]"
          },
          {
            "input": "nums = [-1]",
            "expectedOutput": "[\"-1\"]"
          },
          {
            "input": "nums = [-2147483648,-2147483647,2147483647]",
            "expectedOutput": "[\"-2147483648->-2147483647\",\"2147483647\"]"
          }
        ],
        "hints": [
          "Iterate through the sorted array.",
          "Keep track of the start and end of each range.",
          "If the current number is consecutive to the previous number, update the end of the range.",
          "Otherwise, add the current range to the result list and start a new range.",
          "Handle the edge case where the array is empty or contains only one element."
        ],
        "tags": ["Array"]
      },
       {
        "problemId": 25,
        "courseId": "google",
        "title": "Bulls and Cows",
        "difficulty": "Medium",
        "description": "You are playing the Bulls and Cows game with your friend.\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\nThe number of \"bulls\", which are digits in the guess that are in the correct position.\nThe number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\nGiven the secret number secret and your friend's guess guess, return the hint for your friend's guess.\nThe hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.",
        "examples": [
          {
            "input": "secret = \"1807\", guess = \"7810\"",
            "output": "\"1A3B\"",
            "explanation": "Bulls are connected with a '|' and cows are underlined:\n\"1807\"\n  |\n\"7810\""
          },
          {
            "input": "secret = \"1123\", guess = \"0111\"",
            "output": "\"1A1B\"",
            "explanation": "Bulls are connected with a '|' and cows are underlined:\n\"1123\"        \"1123\"\n  |      or     |\n\"0111\"        \"0111\"\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull."
          }
        ],
        "constraints": [
          "1 <= secret.length, guess.length <= 1000",
          "secret.length == guess.length",
          "secret and guess consist of digits only."
        ],
        "testCases": [
          {
            "input": "secret = \"1807\", guess = \"7810\"",
            "expectedOutput": "\"1A3B\""
          },
          {
            "input": "secret = \"1123\", guess = \"0111\"",
            "expectedOutput": "\"1A1B\""
          },
          {
            "input": "secret = \"1122\", guess = \"1221\"",
            "expectedOutput": "\"2A2B\""
          },
          {
            "input": "secret = \"1122\", guess = \"2211\"",
            "expectedOutput": "\"0A4B\""
          },
          {
            "input": "secret = \"1122\", guess = \"1111\"",
            "expectedOutput": "\"2A0B\""
          },
          {
            "input": "secret = \"1122\", guess = \"3333\"",
            "expectedOutput": "\"0A0B\""
          }
        ],
        "hints": [
          "Iterate through the secret and guess strings to count the number of bulls.",
          "Use a hash map to count the frequency of digits in the secret and guess strings.",
          "Iterate through the hash maps to count the number of cows.",
          "Subtract the number of bulls from the number of cows to get the final count of cows.",
          "Format the hint string as \"xAyB\", where x is the number of bulls and y is the number of cows."
        ],
        "tags": ["Hash Table", "String", "Counting"]
      },
      {
        "problemId": 26,
        "courseId": "google",
        "title": "Max Points on a Line",
        "difficulty": "Hard",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
          {
            "input": "points = [[1, 1], [2, 2], [3, 3]]",
            "output": "3"
          },
          {
            "input": "points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]",
            "output": "4"
          }
        ],
        "constraints": [
          "1 <= points.length <= 300",
          "points[i].length == 2",
          "-10^4 <= xi, yi <= 10^4",
          "All the points are unique."
        ],
        "testCases": [
          {
            "input": "points = [[1, 1], [2, 2], [3, 3]]",
            "expectedOutput": "3"
          },
          {
            "input": "points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]",
            "expectedOutput": "4"
          },
          {
            "input": "points = [[0, 0], [1, 1], [0, 0]]",
            "expectedOutput": "3"
          },
          {
            "input": "points = [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]",
            "expectedOutput": "6"
          },
          {
            "input": "points = [[0, 0], [1, 1], [1, -1]]",
            "expectedOutput": "3"
          },
          {
              "input": "points = [[1,1],[1,1],[1,1]]",
              "expectedOutput": "3"
          }
        ],
        "hints": [
          "Iterate through all pairs of points.",
          "For each pair of points, calculate the slope of the line they form.",
          "Use a hash map to store the slopes and the number of points on each line.",
          "Handle vertical lines and duplicate points separately.",
          "Keep track of the maximum number of points on a line."
        ],
        "tags": ["Array", "Hash Table", "Math", "Geometry"]
      },
       {
        "problemId": 27,
        "courseId": "google",
        "title": "Brace Expansion II",
        "difficulty": "Hard",
        "description": "Under the grammar given below, strings can represent a set of lowercase words. Let R(expr) denote the set of words the expression represents.\nThe grammar can best be understood through simple examples:\nSingle letters represent a singleton set containing that word.R(\"a\") = {\"a\"}\nR(\"w\") = {\"w\"}\nWhen we take a comma-delimited list of two or more expressions, we take the union of possibilities.R(\"{a,b,c}\") = {\"a\",\"b\",\"c\"}\nR(\"{{a,b},{b,c}}\") = {\"a\",\"b\",\"c\"} (notice the final set only contains each word at most once)\nWhen we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.R(\"{a,b}{c,d}\") = {\"ac\",\"ad\",\"bc\",\"bd\"}\nR(\"a{b,c}{d,e}f{g,h}\") = {\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"}\nFormally, the three rules for our grammar:\nFor every lowercase letter x, we have R(x) = {x}.\nFor expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) ∪ R(e2) ∪ ...\nFor expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) × R(e2)}, where + denotes concatenation, and × denotes the cartesian product.\nGiven an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.",
        "examples": [
          {
            "input": "expression = \"{a,b}{c,{d,e}}\"",
            "output": "[\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]"
          },
          {
            "input": "expression = \"{{a,z},a{b,c},{ab,z}}\"",
            "output": "[\"a\",\"ab\",\"ac\",\"z\"]",
            "explanation": "Each distinct word is written only once in the final answer."
          }
        ],
        "constraints": [
          "1 <= expression.length <= 60",
          "expression[i] consists of '{', '}', ',' or lowercase English letters.",
          "The given expression represents a set of words based on the grammar given in the description."
        ],
        "testCases": [
          {
            "input": "{a,b}{c,{d,e}}",
            "expectedOutput": "[\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]"
          },
          {
            "input": "{{a,z},a{b,c},{ab,z}}",
            "expectedOutput": "[\"a\",\"ab\",\"ac\",\"z\"]"
          },
          {
            "input": "a",
            "expectedOutput": "[\"a\"]"
          },
          {
            "input": "{a,b,c}",
            "expectedOutput": "[\"a\",\"b\",\"c\"]"
          },
          {
            "input": "a{b,c}",
            "expectedOutput": "[\"ab\",\"ac\"]"
          },
          {
            "input": "{a,b}c{d,e}f",
            "expectedOutput": "[\"acdf\",\"acef\",\"bcdf\",\"bcef\"]"
          }
        ],
        "hints": [
          "You can write helper methods to parse the next \"chunk\" of the expression. If you see eg. \"a\", the answer is just the set {a}. If you see \"{\", you parse until you complete the \"}\" (the number of { and } seen are equal) and that becomes a chunk that you find where the appropriate commas are, and parse each individual expression between the commas."
        ],
        "tags": ["String", "Backtracking", "Stack", "Breadth-First Search"]
      }, {
        "problemId": 28,
        "courseId": "google",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
          {
            "input": "nums1 = [1, 3], nums2 = [2]",
            "output": "2.00000",
            "explanation": "merged array = [1, 2, 3] and median is 2."
          },
          {
            "input": "nums1 = [1, 2], nums2 = [3, 4]",
            "output": "2.50000",
            "explanation": "merged array = [1, 2, 3, 4] and median is (2 + 3) / 2 = 2.5."
          }
        ],
        "constraints": [
          "nums1.length == m",
          "nums2.length == n",
          "0 <= m <= 1000",
          "0 <= n <= 1000",
          "1 <= m + n <= 2000",
          "-10^6 <= nums1[i], nums2[i] <= 10^6"
        ],
        "testCases": [
          {
            "input": "nums1 = [1, 3], nums2 = [2]",
            "expectedOutput": "2.00000"
          },
          {
            "input": "nums1 = [1, 2], nums2 = [3, 4]",
            "expectedOutput": "2.50000"
          },
          {
            "input": "nums1 = [0, 0], nums2 = [0, 0]",
            "expectedOutput": "0.00000"
          },
          {
            "input": "nums1 = [], nums2 = [1]",
            "expectedOutput": "1.00000"
          },
          {
            "input": "nums1 = [2], nums2 = []",
            "expectedOutput": "2.00000"
          },
          {
            "input": "nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]",
            "expectedOutput": "5.50000"
          }
        ],
        "hints": [
          "Use binary search to find the partition of the two arrays.",
          "The partition should divide the two arrays into two parts such that the number of elements in the left parts is equal to the number of elements in the right parts.",
          "The median is the average of the maximum element in the left parts and the minimum element in the right parts.",
          "Handle the edge cases where one of the arrays is empty or the number of elements in the merged array is odd."
        ],
        "tags": ["Array", "Binary Search", "Divide and Conquer"]
      },
       {
        "problemId": 29,
        "courseId": "google",
        "title": "Text Justification",
        "difficulty": "Hard",
        "description": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\nA word is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\nThe input array words contains at least one word.",
        "examples": [
          {
            "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
            "output": "[\"This    is    an\", \"example  of text\", \"justification.  \"]"
          },
          {
            "input": "words = [\"What\", \"must\", \"be\", \"acknowledgment\", \"shall\", \"be\"], maxWidth = 16",
            "output": "[\"What   must   be\", \"acknowledgment  \", \"shall be        \"]",
            "explanation": "Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word."
          },
          {
            "input": "words = [\"Science\", \"is\", \"what\", \"we\", \"understand\", \"well\", \"enough\", \"to\", \"explain\", \"to\", \"a\", \"computer.\", \"Art\", \"is\", \"everything\", \"else\", \"we\", \"do\"], maxWidth = 20",
            "output": "[\"Science  is  what we\", \"understand    well\", \"enough to explain to\", \"a  computer.  Art is\", \"everything else we\", \"do                  \"]"
          }
        ],
        "constraints": [
          "1 <= words.length <= 300",
          "1 <= words[i].length <= 20",
          "words[i] consists of only English letters and symbols.",
          "1 <= maxWidth <= 100",
          "words[i].length <= maxWidth"
        ],
        "testCases": [
          {
            "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
            "expectedOutput": "[\"This    is    an\", \"example  of text\", \"justification.  \"]"
          },
          {
            "input": "words = [\"What\", \"must\", \"be\", \"acknowledgment\", \"shall\", \"be\"], maxWidth = 16",
            "expectedOutput": "[\"What   must   be\", \"acknowledgment  \", \"shall be        \"]"
          },
          {
            "input": "words = [\"Science\", \"is\", \"what\", \"we\", \"understand\", \"well\", \"enough\", \"to\", \"explain\", \"to\", \"a\", \"computer.\", \"Art\", \"is\", \"everything\", \"else\", \"we\", \"do\"], maxWidth = 20",
            "expectedOutput": "[\"Science  is  what we\", \"understand    well\", \"enough to explain to\", \"a  computer.  Art is\", \"everything else we\", \"do                  \"]"
          },
          {
            "input": "words = [\"a\",\"b\",\"c\",\"d\",\"e\"], maxWidth = 3",
            "expectedOutput": "[\"a  \", \"b  \", \"c  \", \"d  \", \"e  \"]"
          },
          {
            "input": "words = [\"a\",\"b\",\"c\",\"d\"], maxWidth = 4",
            "expectedOutput": "[\"a  b\", \"c  d\"]"
          },
          {
            "input": "words = [\"Listen\",\"to\",\"many,\",\"speak\",\"to\",\"a\",\"few.\"], maxWidth = 6",
            "expectedOutput": "[\"Listen\",\"to  \",\"many,\",\"speak \",\"to   a\",\"few.  \"]"
          }
        ],
        "hints": [
          "Use a greedy approach to pack as many words as possible into each line.",
          "Calculate the number of spaces needed to fill the line.",
          "Distribute the spaces evenly between the words, with extra spaces going to the left.",
          "Handle the last line separately, left-justifying it with single spaces between words.",
          "Be careful to handle the case where a line contains only one word."
        ],
        "tags": ["Array", "String", "Simulation"]
      },
       {
        "problemId": 30,
        "courseId": "google",
        "title": "Bricks Falling When Hit",
        "difficulty": "Hard",
        "description": "You are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty space. A brick is stable if:\nIt is directly connected to the top of the grid, or\nAt least one other brick in its four adjacent cells is stable.\nYou are also given an array hits, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location hits[i] = (rowi, coli). The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the grid (i.e., it does not land on other stable bricks).\nReturn an array result, where each result[i] is the number of bricks that will fall after the ith erasure is applied.\nNote that an erasure may refer to a location with no brick, and if it does, no bricks drop.",
        "examples": [
          {
            "input": "grid = [[1, 0, 0, 0], [1, 1, 1, 0]], hits = [[1, 0]]",
            "output": "[2]",
            "explanation": "Starting with the grid:\n[[1,0,0,0],\n [1,1,1,0]]\nWe erase the underlined brick at (1,0), resulting in the grid:\n[[1,0,0,0],\n [0,1,1,0]]\nThe two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:\n[[1,0,0,0],\n [0,0,0,0]]\nHence the result is [2]."
          },
          {
            "input": "grid = [[1, 0, 0, 0], [1, 1, 0, 0]], hits = [[1, 1], [1, 0]]",
            "output": "[0, 0]",
            "explanation": "Starting with the grid:\n[[1,0,0,0],\n [1,1,0,0]]\nWe erase the underlined brick at (1,1), resulting in the grid:\n[[1,0,0,0],\n [1,0,0,0]]\nAll remaining bricks are still stable, so no bricks fall. The grid remains the same:\n[[1,0,0,0],\n [1,0,0,0]]\nNext, we erase the underlined brick at (1,0), resulting in the grid:\n[[1,0,0,0],\n [0,0,0,0]]\nOnce again, all remaining bricks are still stable, so no bricks fall.\nHence the result is [0,0]."
          }
        ],
        "constraints": [
          "m == grid.length",
          "n == grid[i].length",
          "1 <= m, n <= 200",
          "grid[i][j] is 0 or 1.",
          "1 <= hits.length <= 4 * 10^4",
          "hits[i].length == 2",
          "0 <= xi <= m - 1",
          "0 <= yi <= n - 1",
          "All (xi, yi) are unique."
        ],
        "testCases": [
          {
            "input": "grid = [[1, 0, 0, 0], [1, 1, 1, 0]], hits = [[1, 0]]",
            "expectedOutput": "[2]"
          },
          {
            "input": "grid = [[1, 0, 0, 0], [1, 1, 0, 0]], hits = [[1, 1], [1, 0]]",
            "expectedOutput": "[0, 0]"
          },
          {
            "input": "grid = [[1, 0, 0, 0], [1, 1, 0, 0]], hits = [[1, 1], [1, 0], [0, 0]]",
            "expectedOutput": "[0, 0, 1]"
          },
          {
            "input": "grid = [[1, 1, 1], [0, 1, 0], [0, 0, 0]], hits = [[0, 2], [0, 0], [0, 1]]",
            "expectedOutput": "[0, 1, 3]"
          },
          {
            "input": "grid = [[1, 0, 0, 0], [1, 1, 1, 0], [0, 0, 1, 0]], hits = [[1, 0], [1, 2]]",
            "expectedOutput": "[3, 0]"
          },
          {
            "input": "grid = [[1,1,1],[1,1,1],[1,1,1]], hits = [[1,1],[0,1],[2,1]]",
            "expectedOutput": "[0,3,3]"
          }
        ],
        "hints": [
          "Simulate the erasures in reverse order.",
          "After each erasure, use depth-first search (DFS) or union-find to determine the number of bricks that become unstable.",
          "Reverse the result array to get the correct order of erasures.",
          "Handle the case where an erasure refers to an empty space."
        ],
        "tags": ["Array", "Union Find", "Matrix"]
      }
]